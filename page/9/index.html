<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://tukuai.github.io/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Tukuai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-计算机网络/第四层-传输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E5%9B%9B%E5%B1%82-%E4%BC%A0%E8%BE%93%E5%B1%82/" class="article-date">
  <time datetime="2020-03-15T06:36:27.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E5%9B%9B%E5%B1%82-%E4%BC%A0%E8%BE%93%E5%B1%82/">第四层-传输层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="传输层要解决主要问题"><a href="#传输层要解决主要问题" class="headerlink" title="传输层要解决主要问题"></a><strong>传输层要解决主要问题</strong></h2><p>传输连接的建立。<br>流量控制。<br>拥塞控制。<br>在计算机网络中，传输层处于非常重要的位置。传输层，也称为运输层，无论在OIS还是在TCP/IP模型中，传输层都处于面向应用部分的最低层和面向通信部分的最高层。<br>在网络通信中，传输层有着承上启下的作用，实现了一种将面向应用（进程）的通信需求转变为面向网络设备的通信服务。</p>
<h2 id="端到端的通信"><a href="#端到端的通信" class="headerlink" title="端到端的通信"></a><strong>端到端的通信</strong></h2><p>计算机网络由网络边缘和网络核心两大部分所组成<br><strong>1、网络边缘</strong></p>
<blockquote>
<p>在计算机网络中，网络边缘通常是指由主机、存储、服务器、数据库等各种软硬件设备组成，是网络信息资源的集散地。<br>由于集中了数量极其庞大且标准不同、结构互异的硬件资源、软件资源和信息资源，因此网络边缘历来是计算机网络研究中最为复杂和困难的领域，也是最具吸引力的领域，有“决战在边缘”、“价值在边缘”之说。<br>在网络边缘的主机平台上，运行着从物理层到应用层完整的TCP/IP协议。</p>
</blockquote>
<p><strong>2、网络核心</strong><br>相对于网络边缘，网络核心就显得非常单纯。网络核心由提供数据转发服务的网络路由器，以及连接各路由器的链路（如光纤、通信卫星等）组成。<br>在网络核心的路由器平台上，运行着从物理层到网际层的TCP/IP协议。所以，这类网络设备也称为三层设备，即具有路由能力的网络设备。<br>除了路由器等三层设备，网络核心中还有大量只运行物理层和数据链路层（网络接口层）。这类设备通常只运行物理层和数据链路层协议，所以称为二层设备。</p>
<p><strong>3、传输层的作用和主要功能</strong><br>传输层（运输层）的主要作用是为运行在网络边缘的不同主机上的各应用程序之间提供通信服务。<br>因此，传输层面向的不是主机而是应用，或者说是面向进程的网络通信服务，是一种真正的端到端的通信服务。<br>传输层通信为不同进程之间提供了逻辑通信服务。<br>传输层的另外一个主要作用是在应用层和网络层之间充当复用器的作用。各种各样的网络应用，通过传输层的端口被提交统一的网络层，并由IP协议用统一的方式将它们发送到网络中。<br><img src="/images/123.png" alt=""><br>在OSI/RM中，传输层位于资源子网与通信子网之间，发挥着以下主要功能：<br>对高层应用屏蔽了通信（低层）的细节，无需过多考虑各种通信因素对网络通信过程本身的影响。<br>提供端到端之间的无差错保证，弥补网络层提供服务的差异和不足。</p>
<p><strong>4、传输层协议与网络层协议的主要区别</strong><br><img src="/images/124.png" alt=""><br>传输层提供的服务<br>在TCP/IP中，传输层提供了：面向连接和面向无连接的两种服务。其中：<br>面向连接的服务<br>TCP服务，通信可靠，对数据有校验和重发等机制，但实现复杂，代价较大，通信速率相对较低。<br>如TCP/IP模型中应用层协议FTP、Telnet等<br>面向无连接的服务<br>UDP服务，对数据无校验和重发，实现简单，通信速率高<br>如TCP/IP模型中应用层协议SNMP、DNS等 </p>
<p><strong>1、TCP</strong></p>
<blockquote>
<p>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的传输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。<br>其协议数据单元称为 TCP 报文段(segment)<br>TCP 报文段是在传输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的传输层是否建立了 TCP 连接。 </p>
</blockquote>
<p><strong>2、UDP</strong> </p>
<blockquote>
<p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，也不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。<br>UDP 协议数据单元协议称为 UDP 报文或用户数据报。<br>传输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但UDP 用户数据报是在传输层的端到端抽象的逻辑信道中传送。</p>
</blockquote>
<h2 id="传输层的端口与地址"><a href="#传输层的端口与地址" class="headerlink" title="传输层的端口与地址"></a><strong>传输层的端口与地址</strong></h2><p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。<br>解决这个问题的方法就是在传输层中使用协议端口号(protocol port number)，或通常简称为端口(port)。<br>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。<br><strong>1、硬件端口与软件端口</strong><br>路由器或交换机上的端口是硬件端口。<br>硬件端口是不同硬件设备进行交互的接口。<br>在协议栈层间的抽象的协议端口是软件端口。<br>而软件端口是应用层的各种协议进程与传输层协议进行层间交互的一种接口。 </p>
<p><strong>2、端口号</strong><br>传输层端口用一个 16 位端口号进行标志。<br>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。<br>在因特网中，不同计算机的相同端口号之间并无特别的关联性。</p>
<p><strong>3、传输服务访问点</strong><br>在OSI/RM中，当两个不同主机的两个进程需要通信时，必须指明对方是哪一个进程，这个标记称为传输层地址，也称为传输服务访问点（Transport Service Access Point，TSAP）<br>即，传输层地址（TSAP）=主机IP地址+端口号<br><img src="/images/125.png" alt=""></p>
<p>套接字<br>套接字（Socket）是为了使应用程序能够方便地使用协议栈软件进行通信的一种方法。<br>套接字以标准的UNIX 文件描述符加以标识，应用程序通过对文件描述符的调用，实现与其他程序进行通信。<br>在BSD的定义，每个Socket 都可以用一个被称为半相关方式进行描述：<br>Socket={协议，本地地址，本地端口}<br>对于一个完整的Socket， 则用一个相关描述：<br>{协议，本地地址，本地端口，远程地址，远程端口}<br>从套接字(Socket)所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议栈进行通信的接口，是应用程序与网络协议栈进行交互的接口。 </p>
<p>1、流式套接字(Stream Socket)<br>提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送，且按发送顺序接收。内设流量控制，避免数据流超限；数据被看作是字节流，无长度限制。<br>2、数据报式套接字(Datagram Socket)<br>提供无连接服务。数据包以独立包形式发送，不提供无差错保证，数据可能丢失或重复，并且接收顺序混乱。<br>3、原始套接字(Raw Socket)<br>原始式套接字允许对较低层次的协议，如IP、ICMP直接访问，用于检验新的协议的实现。 </p>
<h1 id="用户数据报协议-（UDP）"><a href="#用户数据报协议-（UDP）" class="headerlink" title="用户数据报协议 （UDP）"></a><strong>用户数据报协议 （UDP）</strong></h1><p>用户数据报协议（User Datagram Protocol，UDP）是OSI参考模型和TCP/IP模型中都有的一种面向无连接的传输层协议。<br>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。<br><strong>1、UDP 的主要特点</strong><br>UDP是无连接协议，在发送数据之前不需要建立连接。<br>UDP使用尽最大努力交付，不保证可靠交付，同时也不使用拥塞控制。<br>UDP是面向报文，没有拥塞控制，很适合多媒体通信的要求。<br>UDP支持一对一、一对多、多对一和多对多的交互通信。<br>UDP 的首部开销小，只有 8 个字节。<br><strong>2、面向报文的 UDP</strong><br>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。<br>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。<br>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。<br>应用程序必须选择合适大小的报文。<br><img src="/images/126.png" alt=""><br>UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。<br>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p>
<h1 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a><strong>传输控制协议（TCP）</strong></h1><p>传输控制协议（Transmission Control Protocol，TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。TCP与UDP同处于传输层，是TCP/IP协议簇中最复杂也是最精彩的协议。</p>
<p><strong>TCP协议的特点：</strong><br>TCP 是面向连接的传输层协议。<br>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br>TCP 提供全双工通信。<br>面向字节流。<br><img src="/images/127.png" alt=""><br>TCP 连接是一种虚连接而不是真正的物理连接。<br>TCP不关心应用程序一次把多长的报文发送到TCP 的缓存中。<br>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。<br>TCP可把太长的数据块划分短一些再传送，也可等待积累足够多的字节后再构成报文段发送出去<br>TCP 连接的建立都是采用客户服务器方式：<br>主动发起连接建立的应用进程称为客户端(client)。<br>被动等待连接建立的应用进程称为服务器(server)。<br><img src="/images/128.png" alt=""></p>
<h2 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a><strong>TCP 的连接</strong></h2><p><strong>1、TCP连接</strong><br>TCP把连接作为最基本的抽象。<br>每一条TCP连接有两个端点。<br>TCP连接的端点叫做套接字(socket)或插口。<br>端口号拼接到(contatenated with) IP 地址即构成了<strong>套接字{协议，本地地址，本地端口，远程地址，远程端口}</strong><br>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：<br>TCP 连接 ::= {socket1, socket2}         =     {(IP1: port1), (IP2: port2)} </p>
<p><strong>2、TCP连接的三个阶段</strong><br>传输连接就有三个阶段，即：<strong>连接建立、数据传送和连接释放。</strong>传输连接的管理就是使传输连接的建立和释放都能正常地进行。<br>连接建立过程中要解决以下三个问题：<br>要使每一方能够确知对方的存在。<br>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。<br>能够对传输实体资源（如缓存大小，连接表中的项目等）进行分配。  </p>
<p><strong>3、TCP连接的建立</strong><br><strong>TCP连接的建立过程也被称为三次握手</strong><br>第一次: 客户端–&gt;服务器。客户端向服务器提出连接建立请求，即发出同步请求报文。<br>第二次: 客户端&lt;–服务器。服务器收到客户端的连接请求后，向客户端发出同意建立连接的同步确认报文。<br>第三次: 客户端–&gt;服务器。客户端在收到服务器的同步确认报文后，向服务器发出确认报文。<br>当服务器收到来自客户端的确认报文后，连接即被建立。<br><img src="/images/129.png" alt=""></p>
<p><strong>4、TCP连接的释放</strong><br><strong>TCP连接释放的建立过程也被称为四次挥手</strong><br>第一次: 客户端–&gt;服务器。客户端向服务器发出一个连接释放报文。<br>第二次: 客户端&lt;–服务器。服务器收到客户端的释放连接请求后，向客户端发出确认报文。<br>第三次: 客户端&lt;–服务器。服务器在发送完最后的数据后，向客户端发出连接释放确认报文。<br>第四次: 客户端–&gt;服务器。客户端在收到服务器连接释放报文后，向服务器发出确认报文。<br><img src="/images/130.png" alt=""><br><strong>TCP 连接必须经过时间 2MSL 后才真正释放掉。</strong><br>MSL（Maximum Segment Lifetime）是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃。RFC 793中规定MSL为2分钟，不同的操作系统在实现时各不相同，常用的有30秒、1分钟、2分钟等。<br><strong>必须等待 2MSL 的时间的原因：</strong></p>
<blockquote>
<p>第一，为了保证客户端发送的最后一个ACK 报文段能够到达服务器。<br>第二，防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</blockquote>
<h2 id="TCP的计时器"><a href="#TCP的计时器" class="headerlink" title="TCP的计时器"></a><strong>TCP的计时器</strong></h2><p>为了保证传输的可靠性和协议栈的稳定，一条TCP连接可以用多达9种不同类型的定时器为其保驾护航。<br>TCP要保证正常工作，至少应该有四种计时器：重传计时器、持久计时器、保活计时器和时间等待计时器。<br><strong>1、重传计时器</strong><br>当接收端收到一个TCP报文后，就会向发送方发出一个确认报文，并指示对方下次传送数据的起始位置。<br>由于网络的不确定性，发送的数据报文和确认报文都有可能在传输过程中丢失。<br>重传计时器（Retransmission Timer），当发送方发出数据报文后即启动该计时器（一般为60秒）：<br>在设定时间截至之前收到确认报文，则传输成功，撤销计时器；否则，传输失败，重新发送数据报文。<br><strong>2、坚持计时器</strong><br>当接收方发出一个零窗口确认报文，发送方立即停止发送数据报文直到接收方发出非零窗口的确认报文。<br>由于TCP不会对确认报文进行确认，因此接收方在发出非零窗口确认报文后即进入等待发送方发送数据报文。<br>如果此确认报文在中途丢失，在通信会陷入死锁。<br>坚持计时器（Persistent Timer）即为破解此死锁而设定。<br>当发送方收到一个零窗口确认时，即启动坚持计时器 。<br>若在设定时间到达之前收到接收方的非零窗口确认报文，则撤销该计时器，恢复正常发送数据报文。<br>若设定时间到达仍未收到接收方的非零窗口确认报文，则发送方发出一个只有一个字节数据的探测报文并消耗一个序号，但该序号会被确认报文所忽略。<br>探测报文的目的，即提醒接收方：确认丢失，重新发送。<br>坚持计时器的值与重传计时器相同。若在截止时间后没有收到接收方的非零窗口确认报文，则发送另一个探测报文，并加倍设置坚持计时器值，如此反复直到收到接收方的非零窗口确认报文为止。<br>坚持计时器的值有最大值限制（门限值，通常为60秒）。<br><strong>3、保活计时器</strong><br>保活计时器（keepalive timer）用于判断两个TCP端点之间长久的连接是否正常。<br>当客户端与服务器建立了TCP连接后，保活计时器即被激活，并设置计时值（通常为2小时）。每当服务器收到来自客户端的报文，即重置计时器。<br>当计时截止后仍未收到客户端的报文，则服务器将向客户端发出探测报文，并每隔75秒发送一个探测报文。<br>如果发出10个探测报文后依然没有得到客户端的确认报文，则服务器假定客户端遇到了故障，，于是强制关闭这条连接。<br><strong>4、时间等待计时器</strong><br>时间等待计时器（Time_Wait Timer）也叫2MSL计时器，是TCP终止连接时启动的计时器。<br>设置这个计时器的主目的是为了能够正常关闭服务端的连接！</p>
<h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a><strong>停止等待协议</strong></h2><p>1、简单流控<br>假设：<br>（1）传输过程中不会出错<br>（2）接收端不保证总能及时接受发送端发出的数据<br>流量控制<br>基本思想：由接收端控制发送端发送数据的速度这种思想是现代网络中各种流量控制方法的基础。<br>停止等待协议的基本算法：<br>发送端<br>（1）等待从上层应用中获得数据<br>（2）获得数据并封装成可发送的数据报文<br>（3）发送报文，等待接收端的确认报文转（1）<br>接收端<br>（1）等发送端发送数据<br>（2）获得数据并转交到上层应用<br>（3）向发送端发送确认报文，转（1）<br>显然，具有简单流量控制的停止等待协议不会由于来不及接受而丢失数据，但其通信效率极低。</p>
<p>2、有差错的流控<br>在不可靠的信道中，假设不会丢失报文，则对应的停止等待协议算法：<br>发送端<br>（1）从上层获得数据并计算校验码，封装报文并缓存。<br>（2）发送报文并等待接收端应答报文。<br>（3）收到接收端应答报文。若肯定，删除缓存并转（1）；若否定，提取缓存数据报文并转（2）。<br>接收端端<br>（1）等待并获得发送端发送的报文，缓存并校验。<br>（2）若校验错，删缓存并发否定报文，转（1）；若校验正确，上交缓存并删缓存，发肯定报文，转（1）。</p>
<p>3、有报文丢失的流控<br>无论是数据报文（发送端发送）还是应答报文（接收端发送），都有可能在传输过程中丢失。<br>若数据报文丢失，接收端未收到数据报文，等待发送端发送。<br>若应答报文丢失，发送端未收到应答报文，等待接收端发送。<br>上述两种情况，都会使发送端等待接收端发送应答报文，而接收端等待发送端发送数据报文。死锁！<br>（1）解决死锁的办法<br>设置重发计时器<br>发送端在发出报文后即启动重发计时器，若在设置的时间tout内未收到接收端的应答报文，则认为报文已丢失，从而重发报文。 通常，Tout略大于报文平均往返时间。</p>
<p>4、对停止等待协议的改进<br>针对采用重传计时器后出现的新问题，有如下改进方法：<br>对报文编号，接收方对收到的报文进行编号重复检查，丢弃编号重复的报文，从而解决重复报文的问题。<br>接收方不再发送否定应答报文，只对无差错的数据报文发送肯定应答报文（并改名为确认报文）。对于有差错的报文，由于没有收到确认报文而超时，导致发送方重发该报文。<br>在确认报文中添加确认信息，以明确被确认的报文。<br>接收方收到重复报文后，在丢弃重复报文的同时，也要向发送方发出针对该重复报文的确认报文。</p>
<p>5、改进的停止等待协议中的报文序号<br>序号会消耗通信资源，序号越长消耗的资源越多。<br>由于只需要区分前后报文，在停止等待协议中报文序号只需要一位即可。</p>
<p>6、改进后的停止等待协议总结<br>只要传输层采用有效的检错重传机制，可以在不可靠的网络上为应用层建立可靠的传输服务。<br>每个报文发送后均需暂时缓存，以备重传。<br>超时计时器的阈值应该适当大于数据传输的平均往返时间。<br>由于具备了超时自动重传的能力，改进后的停止等待协议也被称为停止等待自动重传请求协议（Automatic Repeat reQuest，ARQ），简称停等ARQ协议。</p>
<h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a><strong>连续ARQ协议</strong></h2><p>1、概念<br>发送方可连续发送多个报文，不必每发完一个报文就停止并等待接收方的确认。也被称为流水线传输。<br>流水线传输<br>发送方在TD+RTT+TA的时间周期内不必每发送一个报文就等待接收方的确认，而是连续的发送多个报文。</p>
<p>信道利用率U=nTD/(TD+RTT+TA)<br>其中：n为在时间周期内可以发送的数据报文的数量。<br>问题：在信道利用率优先的前提下，n取多大比较合适？<br>由于信道利用率不会超过100%，因此在n达到某个值之后，信道利用率不可能继续提高。        n的增加也意味着缓冲区的增加，成本也随之上升。</p>
<p>报文序号<br>为了能够区分尚未确认的报文，需要有更多报文序号。通常，如果n=N，则序号范围为0~ N，共n+1个序号。<br>在不可靠的网络中，为了避免由于超时造成序号产生误认，序号的范围需要有更大的取值范围。</p>
<p>2、GO-Back-N的连续ARQ<br>如果接收方正在校验的报文出错或丢失，则发送方重传这个出错的报文以及其后所有已经发送的报文。<br>在返回N协议中，发送方为所有已经发送但尚未确认的报文进行缓存，直到被确认。接收方只能缓存当前正在校验的报文即可。<br>特点：<br>控制简单；缓冲区较少（发送方N个缓存，接收方1个缓存）。</p>
<p>3、滑动窗口<br>滑动窗口（Sliding window，SW）是一种流控方法，用于约束发送方可发送报文的数量。窗口是指发送方最多可发送未被确认报文的数量，而滑动则是指每收到一个确认报文，窗口可向前滑动一个报文，从而纳入新的待发送的报文。<br>因此，停等ARQ协议是连续ARQ协议窗口为1的特例：</p>
<p>4、应答机制改进<br>（1）捎带应答<br>收到正确报文时<br>若有数据报文发送给对方，则在数据报文中应答。<br>若一定时间内没有数据报文给对方，则发送应答报文。<br>捎带方式<br>在数据报文首部增加应答字段N(R)，表示对报文序号为N(R)的报文的确认。</p>
<p>（2）累积应答<br>不必对每个收到的数据报文都应答<br>在收到一定数量的正确报文后再对最后一个收到的正确报文进行确认应答，表示到这个报文为止所有的报文都正确。<br>通常与捎带应答结合使用<br>无数据报文时暂不应答。<br>收到正确报文后的一定时间内至少应答一次<br>避免对方因为超时而重发正确报文。<br>累积应答的优点是简单，容易实现，即使确认丢失也不必重传；缺点是不能及时反映接收已经接收到的正确报文。</p>
<hr>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a><strong>TCP 可靠传输的实现</strong></h2><p>简单的把停等协议或连续ARQ协议等可靠通信原理照搬到真实的TCP运行环境并不适合。<br>在TCP中，每个连接的两端都各两个窗口：一个发送窗口和一个接收窗口。<br>TCP为其传输的每个字节都编制一个序号，并以此为基础构建可靠传输。同样，TCP的确认也都是基于（字节）序号而不是报文序号。<br>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。  </p>
<hr>
<p><strong>以字节为单位的滑动窗口</strong><br>滑动窗口用于<br>差错控制：控制“连续ARQ”的参数<br>流量控制：控制发送报文的速率<br>TCP滑动窗口的特点之一：面向字节流<br>以字节为单位进行控制<br>TCP报文首部中的窗口字段即为接收方可允许发送方可以发送的字节数，以约束发送方的发送量。<br>发送方根据接收方给出的窗口值，构造自己的发送窗口尺寸。通常不大于对方的窗口值。</p>
<p><strong>1.发送窗口的结构</strong><br><img src="/images/131.png" alt=""><br>发送窗口内的序号都已用完，但还没有收到确认，必须停止发送。 </p>
<p><strong>2.接收窗口</strong><br>TCP 标准没有规定对不按序到达的数据如何处理。<br>通常的方法：<br>先临时存放在接收窗口中，等收到字节流中所缺少的字节后，再一并交付上层应用程序。<br>因此，接收窗口大小不为1（通常，与发送窗口一样大）</p>
<p><strong>3.发送窗口的调整</strong><br>可用窗口大小、发送窗口的移动<br>根据连续ARQ的要求调整<br>发送窗口大小<br>根据流量控制（接收方的接收窗口）调整<br>规则<br>接收窗口控制发送窗口大小的变动</p>
<p><strong>4.缓存与接收缓存的作用</strong></p>
<blockquote>
<p>发送缓存用来暂时存放：<br>发送应用程序传送给发送方 TCP 准备发送的数据；<br>TCP已发送出但尚未收到确认的数据。</p>
</blockquote>
<blockquote>
<p>接收缓存用来暂时存放：<br>按序到达的、但尚未被接收应用程序读取的数据；<br>不按序到达的数据。 </p>
</blockquote>
<p><strong>5.另外：</strong><br>发送窗口并不总是和对应的接收窗口一样大（因为有一定的时间滞后）。<br>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。<br>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 </p>
<p><strong>超时重传时间的选择</strong><br>重传机制是TCP中最重要和最复杂的问题之一，也是TCP可靠传输的基石。<br>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。<br>超时重传时间（RetransmissionTime-Out，RTO）的确定对TCP的性能有重大影响。<br>往返时间（Round Trip Time，RTT）是确定超时重传时间的最重要的基础。<br>在真实网络环境中，RTT的测量是有非常大的不确定性。<br><strong>指数避退</strong><br>在TCP中，当超时而发生连续多次重传时，在两次重传之间的超时阈值的设置遵循“指数避退”原则：<br>当超时第一次重传后，第二次重传等待时间是第一次的2倍，第三次重传等待时间是第二次的2倍,2为退避因子，直到收到重传数据包的应答，RTO退避因子回复为1。<br>这样为了当网络处于无法快速交付数据报文状态时减小网络负担。</p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a><strong>TCP的流量控制</strong></h2><ol>
<li>利用滑动窗口实现流量控制<br>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。<br>流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。<br>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </li>
<li>持续计时器<br>TCP 为每一个连接设有一个持续计时器。<br>只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。<br>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。<br>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。<br>若窗口不是零，则死锁的僵局就可以打破了。 </li>
<li>传输效率的思考<br>可以用不同的机制来控制 TCP 报文段的发送时机:<br>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。<br>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。<br>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li>
</ol>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a><strong>TCP的拥塞控制</strong></h2><p>拥塞<br>即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。<br>拥塞控制<br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<br>拥塞控制的前提：<br>网络能够承受现有的网络负荷。</p>
<ol>
<li><p>拥塞发生的原因<br>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。<br>出现资源拥塞的条件：</p>
<pre><code>对资源需求的总和 &gt; 可用资源</code></pre><p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。<br>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 </p>
</li>
<li><p>拥塞控制与流量控制的关系<br>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。<br>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。<br>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
</li>
<li><p>开环控制和闭环控制<br>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。<br>闭环控制是基于反馈环路的概念。属于闭环控制的有以下几种措施：<br>监测网络系统以便检测到拥塞在何时、何处发生。<br>将拥塞发生的信息传送到可采取行动的地方。<br>调整网络系统的运行以解决出现的问题。</p>
</li>
</ol>
<h2 id="拥塞控制的一般方法"><a href="#拥塞控制的一般方法" class="headerlink" title="拥塞控制的一般方法"></a><strong>拥塞控制的一般方法</strong></h2><ol>
<li>慢开始和拥塞避免<br>发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口小于等于拥塞窗口。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</li>
</ol>
<p>慢开始算法的原理<br>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。<br>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。<br>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理</p>
<p>传输轮次<br>使用慢开始算法后，每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<br>一个传输轮次所经历的时间其实就是往返时间 RTT。</p>
<p>门限状态变量及其设置方法：<br>门限状态变量（ssthresh）是指网络状态达到某个临界点，继续延续这种状态将导致状态发生转变。<br>当 cwnd &lt; ssthresh 时，使用慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。<br>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p><strong>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。<br>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</strong> </p>
<p><strong>快重传和快恢复</strong><br>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。<br>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。<br>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 </p>
<p>(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。<br>(2) 由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E5%9B%9B%E5%B1%82-%E4%BC%A0%E8%BE%93%E5%B1%82/" data-id="ckb22iugp00cnzwu847le5515" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/第三层-网络层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E5%B1%82-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="article-date">
  <time datetime="2020-03-14T07:24:19.000Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E5%B1%82-%E7%BD%91%E7%BB%9C%E5%B1%82/">第三层:网络层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a><strong>网络层功能</strong></h2><p>在数据链路层的支持下，为传输层提供源/目的主机间的报文分组传输服务。</p>
<h2 id="网络层要解决主要问题："><a href="#网络层要解决主要问题：" class="headerlink" title="网络层要解决主要问题："></a><strong>网络层要解决主要问题：</strong></h2><p>路由选择<br>拥塞控制<br>异构网络互联<br>网络安全</p>
<h2 id="结点间数据交换方式主要有以下三种："><a href="#结点间数据交换方式主要有以下三种：" class="headerlink" title="结点间数据交换方式主要有以下三种："></a><strong>结点间数据交换方式主要有以下三种：</strong></h2><p>电路交换<br>分组交换<br>信元交换</p>
<p><strong>1.电路交换方式起源于电话系统。</strong><br>建立电路<br>传送数据<br>拆除电路</p>
<ul>
<li>优点<br>实时性，可靠性好。</li>
<li>缺点<br>信道利用率低。</li>
</ul>
<p><strong>2.分组交换</strong><br>报文<br>一份完整的信息称为一个报文。<br>分组（Packet）<br>报文分组的简称，又叫信息包，将报文划分为若干格式化信息单位作为网络层的数据传输单元，这样的格式化信息单位称为报文分组。<br><img src="/images/113.png" alt=""></p>
<ul>
<li>基本原理 ：将一份完整的报文划分为若干组，每个分组以存储/转发方式独立的从源结点传输到目的结点，目的结点收到这些分组重新组装成原报文。<br>特点：化整为零，存储转发<br>优点：使多路数据能够复用一条链路，提高链路的利用率。有利于差错控制。减少结点缓冲区容量。<br>缺点：当网络拥塞时，会导致分组传输延迟增加，尽管对传输的文本文件，二进制文件影响并不大，但对流媒体影响较大</li>
</ul>
<p>分组交换技术的两种实现方式 </p>
<ul>
<li>虚电路<br>数据报</li>
</ul>
<p><strong>虚电路</strong><br>主机HA要和HC进行数据交换<br>首先主机HA向HC发一虚呼叫（虚电路连接请求），该虚呼叫选择一条适当的路径传送到Hc,记下沿途所经过的路程作为虚电路，如HA-A-E-B-C-Hc，并给其赋一个虚电路号VC1。<br>如果Hc准备就绪，则发一响应给HA，HA收到该响应，则虚电路VC1已建立完毕。<br><strong>HA和HC的数据交换必须通过该虚电路进行。<br>数据交换完毕，则释放虚电路。</strong><br><img src="/images/114.png" alt=""></p>
<p>通信前发送方和接收方之间必须建立连接（虚电路），所以虚电路是面向连接的网络服务。<br>虚电路只是一种逻辑电路，而不是真正的物理电路。报文分组在虚电路上传输不像再物理线路上那样中畅通无阻。而是要中间节点的存储转发。<br>一条链路上允许建立多个虚电路。<br>一旦虚电路建立完毕，本地通信的所有分组必须经过该虚电路进行。因此，虚电路能够保证分组的顺序接收。<br>仅当建立虚电路时需要源/目的结点地址，数据分组需分配一个虚电路号而无须源/目的结点地址。<br>虚呼叫沿途经过每一结点要向该结点提出请求，任一结点拒绝请求（由于资源不足），均导致虚电路建立失败<br>一条链路上允许建立多个虚电路。如VC1和VC2共同复用了BC链路。</p>
<p><strong>数据报</strong><br>数据报无需建立连接，每个报文分组携带完整的源/目的地址，独立的选择路径，通过不同的路径到达目的主机<br>无需建立连接就可传输报文分组，因此数据报称为无连接网络服务。<br>不同的报文分组可以通过不同的路由到达目的主机，先发出的分组未必先到达，因此数据报服务不能保证报文分组顺序接收。<br>每个报文分组携带完整的源/目的地址，独立的选择路径<br><img src="/images/115.png" alt=""></p>
<h1 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a><strong>路由选择</strong></h1><p>无论是虚电路，还是数据报都要进行路由选择。</p>
<ul>
<li><p>虚电路：需要一次路由选择<br>数据报：每个分组要进行路由选择。<br>路由选择<br>根据某种策略，选择一条最佳的路径到达目的主机，对路由器而言，路由选择实质上是选择最佳输出端口。</p>
</li>
<li><p><strong>分类</strong><br>静态策略<br>动态策略</p>
</li>
</ul>
<h2 id="静态策略"><a href="#静态策略" class="headerlink" title="静态策略"></a><strong>静态策略</strong></h2><p>按某种固定的规则进行路由选择，不随网络流量和拓扑结构变化而变化<br><strong>1.扩散法（洪泛法）</strong><br>当结点收到一个分组后，把该分组向除进来的链路外的所有其他链路转发，结果至少有一个分组以最快的速度到达目的结点。<br>问题：扩散过程产生大量重复分组，导致网络无法运行。<br>解决措施：<br>每个分组设置一个下跳数字段，每经过一个结点，下跳数减1，当下跳数为0时，丢弃该分组。<br><strong>2.固定式路由选择</strong><br>每个结点保存一张固定的路由表，当某一分组到达时，根据分组的目的结点，在路由表中找到其对应的输出链路，然后将分组从该链路转发出去。<br>一般由网管中心根据最佳路由算法为每个路由产生固定路由表并发给该结点。固定路由表一旦生成，就不再改变，除非网管中心重新生成新的路由表<br>优点：简单<br>缺点：无法适应网络流量和拓扑结构的变化</p>
<h2 id="动态策略"><a href="#动态策略" class="headerlink" title="动态策略"></a><strong>动态策略</strong></h2><ul>
<li>动态策略根据当前拓扑结构和流量的变化来动态改变路由，又称为自适应路由。<br>孤立路由算法。<br>集中路由选择。<br>分布路由选择。</li>
</ul>
<p><strong>1.孤立路由算法</strong><br><strong>热土豆算法</strong><br>基本思想：当你手里拿着一个烫手的热土豆时，你一定会想办法以最快的速度脱手。当一个结点收到一个分组后，选择一条输出队列最短的链路尽快的将其转发出去，而不管目的节点位于何方。<br>优点：提高链路的利用率。<br>缺点：具有很大盲目性。<br>改进：与固定路由算法混合使用。<br>首先根据固定路由算法选择可能链路，并给这些链路赋上一定权值，再根据链路队列长度给赋上一定权值，选择这两个权值和最小的链路。</p>
<p><strong>2.集中路由选择</strong><br>逆向自学习算法<br>每个分组中包含一个结点计数器，每经过一个结点，该结点计数器加1。<br>当一个结点R从链路L收到一个来自源结点S的分组时，如果结点计数器为n，就知道经L到达S的路径的距离不会超过n。<br>若它以前纪录到S的最短路径超过n时，则将链路L作为到达S的最短输出链路，纪录当前最短路径长度n。<br>经过一段时间的自学习，结点R会找到它到其它结点的最短路径及最小距离值。<br>优点<br>对好消息反应灵敏<br>缺点<br>对于坏消息无法了解到（如一条链路崩溃）。<br>改进<br>每隔一段时间T，删除这段时间内没有刷新的记录。</p>
<p><strong>3.分布路由选择</strong><br><strong>3.1距离向量路由选择 (D-V算法)</strong><br>基本思想：每个结点都保存一张路由表，路由表包括三个主要字段，即目的地址，最短距离、最佳输出链路。与固定路由选择不同的是：相邻结点之间定期交换路由信息（如每隔十秒），并根据最新路由信息，刷新路由表。<br>要交换的路由信息由二元组（V,D）组成，其中V为目的地址，D为到达目的地址的距离。又称距离向量算法。<br>优点：运算量和交换的信息量较小<br>缺点：对网络变化需经若干周期才能作出反应。特别是对好消息反应快，对坏消息反应迟钝。<br><img src="/images/117.png" alt=""><br>结点A加入网络的消息（好消息）经过4次,交换路由信息后即可传遍全网<br>结点A崩溃的消息（坏消息）要经过无穷次交换才能传遍全网。这就是距离向量法的无穷计数问题。</p>
<ul>
<li>无穷计数问题的解决方法 </li>
</ul>
<p>1.规定足够大的数作为无穷大，如RIP规定无穷大为16，负作用是限制了网络规模<br>2.水平分割法<br>基本思想：结点不向相邻结点报告从该相邻结点获取的路由信息<br>若链路AB出现故障，由于C不会向B报告到A的路由，所以B把到A的距离置为∞<br>水平分割有时会失败</p>
<p><strong>3.2链路状态路由选择（L-S算法）</strong><br>从1979年开始，ARPANET以及后来的Internet的内部网关协议由距离向量改为链路状态。<br>基本思想：每个结点定期广播路由信息，并根据最新路由信息刷新路由表。<br>发现邻居结点。<br>当一个路由器启动以后，它的第一个任务就是要知道谁是它的邻居结点。通过向每个端口发送特殊的HELLO分组来发现邻居结点，收到HELLO分组的路由器应返回一个应答来说明它的网络地址。<br>测量链路开销。<br>通过发送一个特殊的ECHO分组来实现，测量其往返时间再除以2。<br>向所有结点广播L-S分组<br>结点获得最新L-S状态后，用最短路径算法计算到每个其他结点的最短路由，并刷新路由表。<br>优点：对网络反应迅速<br>缺点：广播L-S分组占用信道容量大<br>应用：OSPF（开放路径优先）采用L-S算法，作为Internet的AS内标准路由协议。<br><img src="/images/116.png" alt=""></p>
<h2 id="路由协议简介"><a href="#路由协议简介" class="headerlink" title="路由协议简介"></a><strong>路由协议简介</strong></h2><p>1.路由信息协议（RIP）<br>RIP采用D-V算法，用于小规模网络。<br>技术特点<br>距离：下跳数，允许对下跳数加权。<br>交换路由信息周期：30秒<br>为了解决无穷计算问题，RIP选择16作为∞；为了加快收敛速度，RIP采用水平分割技术。<br>RIP消息通过UDP协议传输，端口号为520</p>
<p>2.开放最短路由优先协议（OSPF）<br>OSPF采用L-S算法，是目前Internet的主要内部网关协议。<br>技术特点：<br>距离：允许网管人员配置选择多种距离度量，如延迟，数据率，通信费用，下跳数等。<br>OSPF支持区域概念<br>OSPF支持认证服务，防止非法向路由器发送假路由信息来愚弄路由。</p>
<p>3.边界网关协议（BGP）<br>BGP采用改进型的D-V算法，作为Internet外部网关协议。<br>技术特点：<br>路由表中记录到达目的地的确切路由，而不是“距离”，从而解决无穷计算问题。<br>支持策略路由。</p>
<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a><strong>IP协议</strong></h1><p>概述<br>IP协议是Internet体系结构的核心协议，已成为连接异构网络的工业标准。<br>IP提供无连接的数据报服务，每个IP分组长度≤64K字节，<strong>不能保证分组可靠的、按序到达，这些留给高层协议解决。</strong><br>IP协议需要路由协议ICMP，ARP，RARP等协议支持<br><img src="/images/118.png" alt=""><br>版本：4位，表示IP协议版本，通常为0100（v4），若为0110则表示为v6版<br>首部检验和：16位，只检验数据报首部，不检验数据部分。<br>源地址：32位，发送端主机IP地址。<br>目的地址：32位，接收端主机IP地址。</p>
<h2 id="IP地址及管理"><a href="#IP地址及管理" class="headerlink" title="IP地址及管理"></a><strong>IP地址及管理</strong></h2><p>TCP/IP网络模型将整个Internet视为一个单一的、抽象的网络，IP地址就是给每个连接在这个网络上的主机、路由器或其他设备分配的一个在全世界范围唯一的 32 位标识符。<br><strong>分类IP地址：</strong>基本的编址方法，由1981年的标准协议所确定。<br><strong>子网划分IP地址：</strong>基于分类IP地址编址方法的改进，其标准[RFC 950]在1985年成为国际标准。<br><strong>超网IP地址：</strong>目前应用最广泛的方法，对于缓解IPv4地址耗尽和路由表过于臃肿庞大有一定的作用。1993年提出后很快就得到推广应用。<br><img src="/images/120.png" alt=""></p>
<p><strong>分类IP地址</strong></p>
<blockquote>
<p>IP地址被分为五类，分别称为A类、B类、C类、D类和E类。<br>A、B和C类地址分别有两个固定长度的字段组成，其中一个字段是网络号（net-id），表示联网主机（或网络设备）所在的网络，另一个字段是主机号（host-id），表示联网主机（或网络设备）本身。<br>D类和E类地址不区分网络和主机。<br><img src="/images/119.png" alt=""></p>
</blockquote>
<p><strong>划分子网IP地址</strong></p>
<blockquote>
<p>划分子网法是在1985年提出一种IP地址表示方式（RFC 950）<br>将一个IP类网划分成几个较小的子网（subnet）<br>多个物理网共享同一个IP类网前缀<br>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}<br>对外，网络号仍然表示整个网络；对内，则由子网号表示多个不同的子网。IP地址具体所属的子网以及子网规模，则由子网掩码（subnet mask）加以表示。<br>子网的规模与借用主机字段的位数有关。借用位数越多，子网规模越小。<br>子网掩码格式：32比特，网络号(包括子网号)部分全为“1”，主机号部分全为“0”。<br><img src="/images/121.png" alt=""><br>前面的例子中：网络号24位，子网号3位，总共27位。所以子网掩码为：<br> 11111111   11111111   11111111   11100000<br>即 255   .  255     .  255     .  224<br>子网掩码∧ IP地址，结果就是该 IP地址的网络号。<br>主机之间要能够通信，它们必须在同一子网内，否则需要使用路由器（或网关）实现互联。<br>举例<br>网络分配了一个C类地址：201.222.5.0。假设需要20个子网，每个子网有5台主机。<br>试确定各子网地址和子网掩码。<br>1）对C类地址，要从最后8位中分出几位作为子网地址：<br>      ∵2^4＜20＜2^5，∴选择5位作为子网地址，共可提供<br>          30个子网地址。<br>2）检查剩余的位数能否满足每个子网中主机台数的要求：<br>      ∵ 子网地址为5位，故还剩3位可以用作主机地址。而<br>           2^3＞5+2，所以可以满足每子网5台主机的要求。<br>3）子网掩码为255.255.255.248。<br>    （11111000B = 248 ）<br>4）子网地址可在8、16、24、32、……、240共30个地<br>      址中任意选择20个。</p>
</blockquote>
<p><strong>超网IP地址</strong></p>
<blockquote>
<p>超网也称为无分类域间路由（Classless Inter-Domain Routing，CIDR）编址方法<br>CIDR中，不再有传统的A类、B类和C类等地址以及划分子网的概念，因而可以更加有效地分配IPv4 的地址空间。<br>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。<br>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}<br>CIDR常使用“斜线记法”(Slash notation)，即在IP地址后面加上一个斜线“/”和一个代表网络前缀所占位数的数字，如/20。<br>将网络前缀都相同的连续的IP地址称为“CIDR地址块”<br>一个CIDR地址块可以表示很多地址，因此这种地址的聚合被称为路由聚合(route aggregation) 。利用路由聚合可以在路由表中用一个项目代表很多个传统分类地址的路由项目，从而大大缓解了路由表的臃肿现象。<br>因为路由聚合相当于把原来的多个子网聚合成为一个网络，所以也称为超网(Supernetting)。<br>CIDR虽然不使用子网，但仍然使用“掩码”这一名词（但不叫子网掩码）。<br>CIDR地址块中的IP地址数量一定是2的整数次幂。<br><img src="/images/122.png" alt=""></p>
</blockquote>
<p><strong>IP寻址</strong><br>每个路由器中都保存一张路由表（无论是静态还是动态）。路由表的主要项目有两个：网络号、下一跳地址（最佳输出链路）。</p>
<h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a><strong>网际控制报文协议 ICMP</strong></h2><p>为了提高IP数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。<br>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>ICMP 不是高层协议，而是 IP 层的协议。<br>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。<br>1、ICMP 作用和主要功能<br>IP协议提供了以无连接为特征的“尽力而为”的数据通信服务，并不能解决数据报丢失、重复、延迟或乱序等问题。<br>ICMP的目的就是希望对IP包无法传输时提供报告，这些差错报告帮助发送方了解网络中发生了什么问题，以确定应用程序后续操作。<br><strong>ICMP的主要功能包括：</strong></p>
<blockquote>
<p>通告网络错误<br>通告网络拥塞<br>协助解决故障<br>通告超时</p>
</blockquote>
<p>ICMP是少数几个可以直接从应用层操作的协议，不经过传输层。<br>ICMP是一个网际层协议，但却需要利用另一个网际层协议–IP协议进行封装，因此ICMP是一种需要两次封装的网际层协议。<br>首先由网络层的IP协议对ICMP协议报文进行封装，其次再由数据链路层协议对相应的IP报文进行封装。经过两次封装后的ICMP报文才能被传输。<br>ICMP报文是由IP协议封装，因此其也和IP协议一样是一个不可靠的协议，既不能保证报文的到达，也不能保证报文按序到达。</p>
<p>ICMP 报文的种类有两种，即ICMP差错报告报文和 ICMP 询问报文。 </p>
<p><strong>ICMP的应用举例</strong><br>PING (Packet InterNet Groper)用来测试两个主机之间的连通性。</p>
<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a><strong>地址解析协议ARP</strong></h2><p><strong>1、MAC地址</strong><br>无论OSI还是TCP/IP，都奉行的是对等层通信原则。在这一原则下，低层只是向上层提供支持，即将上层的协议报文作为载荷封装在本层相关协议的数据单元中。在低层，无法获得也不能理解被封装的高层协议报文的内容。一句话，低层协议看不见高层数据。<br>当IP报文被数据链路层协议封装后，包括IP地址在内的IP协议细节均无法被数据链路层协议获得。<strong>为了能够在数据链路层的协议中描述源/目的节点，需要在数据链路层设计相应的节点标识符，即数据链路层地址。<br>在以太网中，这个地址就称为MAC（Media Access Control）地址。</strong>由于数据链路层向下紧邻物理层，受到物理层许多因素的影响，因此也被称为物理地址或硬件地址或机器地址。对应的，IP地址也常常被称为逻辑地址。</p>
<p>MAC地址有48位二进制数表示。为了便于记忆，用12个16进制数代表，每2个16进制数之间用冒号分割，比如如：08:00:20:0A:8C:6D就是一个合适的MAC地址。<br>在48位二进制数字中，IEEE负责向从事以太网产品生产的厂商分配前24位，由厂商负责编写后24位，并确保所有MAC地址的唯一性。</p>
<p><strong>2、ARP协议</strong><br>地址解析协议（Address Resolution Protocol，ARP）是IP协议最重要的配套协议之一，其目的就是是将IP地址转化成MAC（物理或硬件）地址。</p>
<p>ARP协议工作原理：</p>
<blockquote>
<p>当主机A有信息向主机B发送时：<br>主机A查找本地ARP表，若表中有主机B的IP地址，则按照对应的MAC地址，将要发送的IP包封装成以太帧，并向主机B发送。<br>若ARP表中没有主机B的数据项，则以广播方式发出ARP请求包，在本网段内寻找与主机B的MAC地址。<br>主机B收到主机A的ARP请求报文后，向主机A发出单播的ARP响应包，并将主机A的IP地址和MAC地址填入自己的ARP表中。<br>主机A在收到响应报文后，将主机B的MAC地址填写到自己的ARP表中，按照获得的MAC地址将IP包封装到以太帧，并向主机B发送。</p>
</blockquote>
<p>根据报文中地址项的填写内容，ARP分为标准（也称有偿）和无偿（gratuitous，也称免费）两种类型：<br>标准ARP<br>ARP请求报文的各相关地址项：源IP和源MAC为发出ARP请求的主机的IP地址和MAC地址，目标IP为希望获得其MAC地址的主机的IP地址，目标MAC为全“0”。<br>无偿ARP<br>也称为免费ARP，是一种特殊的ARP请求报文，当一个ARP请求报文满足以下条件时：<br>源IP地址和目标IP地址都是发出这个ARP报文的主机的IP地址。<br>源MAC地址是发出这个ARP报文的MAC地址。<br>目的MAC地址是广播地址。</p>
<p>无偿ARP有什么作用？<br>答：1. 确定其它设备的IP地址是否与本机的IP地址冲突。当其它设备收到免费ARP报文后，如果发现报文中的IP地址和自己的IP地址相同，则给发送免费ARP报文的设备返回一个ARP应答，告知该设备IP地址冲突。<br>2.设备改变了硬件地址，通过发送免费ARP报文通知其它设备更新ARP表项。<br>3.定时发送免费ARP功能可以及时通知下行设备更新ARP表项或者MAC地址表项，可防止仿冒网关的ARP攻击，防止主机ARP表项老化，防止VRRP虚拟IP地址冲突。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E5%B1%82-%E7%BD%91%E7%BB%9C%E5%B1%82/" data-id="ckb22iugn00cezwu86o88h9gu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/第二层-数据链路层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E5%B1%82-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="article-date">
  <time datetime="2020-03-14T06:44:16.000Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E5%B1%82-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">第二层:数据链路层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a><strong>差错控制</strong></h2><p>差错控制方法<br>通过特殊的编码（差错控制码），使接收端能够发现甚至自动纠正错误。<br>常用的差错控制编码有两类 </p>
<ul>
<li>检错码<br>Ø 能够发现差错，但无法自动纠正差错，通过发送方重传来获得正确的数据。 </li>
<li>纠错码<br>Ø 不但能过发现差错，而且能够知道哪里出错，从而自动纠正差错</li>
<li><em>海明码*</em><br><img src="/images/109.png" alt=""><br><img src="/images/110.png" alt=""><br>海明距离只能纠正一位出错，而实际通信过程中经常发生的是突发性错误<br>只要将发送方式稍做改变，就能利用纠正一位出错的海明码来纠正突发错。</li>
</ul>
<hr>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h2><p><strong>1.停—等协议</strong><br>发送方发送一帧后，等待对方的应答。<br>接收端收到一帧后，检查校验位串。若出错，返回“否认”信息；若无错，返回“确认”信息。<br>发送端收到“确认”后，立即发送下一帧；收到“否认”则重发该帧。<br>发送端发送一帧后，立即启动超时计时器。若超时中断，重发该帧。<br>接收端应保存最近收到的帧序号，若下一个到达帧的序号与该序号相同，则丢弃并返回“确认”信息。<br>缺点</p>
<ul>
<li>信道利用率低 </li>
</ul>
<p>优点</p>
<ul>
<li>简单 </li>
</ul>
<p><strong>2.滑动窗口协议</strong><br>基本思想 </p>
<ul>
<li>为提高信道利用率，允许发送方连续发送若干帧后再等待对方应答。<br>基本概念 </li>
<li>窗口：可容纳数据帧的缓冲区。 </li>
<li>发送窗口：发送方用来保存已发送但尚未经确认的数据帧。 </li>
<li>接收窗口：接收方用来保存已正确接受但尚未提交给主机(网络层)数据帧。 </li>
<li>窗口尺寸：窗口中可以保存的帧数目称为窗口尺寸。<br>帧序号 </li>
<li>为了保证接收方能按正确次序向主机递交数据帧而设立的临时帧序号。 </li>
<li>一般在帧控制字段中用若干位来表示帧序号。如果用3位来表示，则帧序号为0—7。当一次通信超过8帧时，则顺序重复使用这8个帧序号。<br>窗口号：对应帧序号</li>
</ul>
<p><strong>2.1顺序接收管道协议（回退n）</strong><br>接收窗口尺寸为1的滑动窗口协议，也称回退n协议。设发送窗口尺寸WT=n, 接收窗口尺寸WR=1. </p>
<ul>
<li>发送方可连续发送n帧而无需对方应答，但需要将已发出但尚未收到确认的帧保存在发送窗口中，以备由于出错或丢失而重发。 </li>
<li>接收方将正确的且帧序号落入当前接收窗口的帧存入接收窗口，同时按序将接收窗口的帧送交给主机（网络层）。出错或帧序号未落入当前窗口的帧全部予以丢弃。 </li>
<li>当某帧丢失或出错时，则其后到达的帧均丢弃，并返回否认信息，请求对方从出错帧开始重发。 </li>
<li>发送方设置一个超时计时器，当连续发送n帧后，立即启动超时计时器。当超时计时器满且未收到应答，则重发这n帧。<br><img src="/images/111.png" alt=""></li>
</ul>
<p><strong>2.2选择重传协议</strong><br>顺序接收管道协议 </p>
<ul>
<li>优点：仅需一个接收缓冲区 </li>
<li>缺点：当信道误码率较高时，会产生大量重发帧<br>另一种更好的方法：选择重传协议 </li>
<li>若某一帧出错，后面正确到达的帧虽然不能立即送网络层，但接收方可将其保存在接收窗口，仅要求发送方重传那个发错帧。</li>
</ul>
<p><strong>停—等协议 、顺序接收管道协议、选择重传协议都可以看成是滑动窗口协议，其差别仅在窗口的尺寸不同。如下表所示</strong><br><img src="/images/112.png" alt=""></p>
<p><strong>数据链路层协议举例</strong><br>HDLC协议<br>HDLC(High Level Data Control)协议是一种<br>面向比特的链路层协议。</p>
<p>标志 </p>
<ul>
<li>固定为0111110，标志着一个帧的开始和结束。 </li>
<li>具有帧之间的同步作用。 </li>
<li>在连续发送多帧时，可用一个标志字段，既表示帧的开始，又表示帧的结束</li>
</ul>
<p>为了避免其它字段中出现“0111_1110”，产生误解，HDLC采用插“0”技术<br>发送方：除标志位外，连续发现5个“1”后自动插“0”。<br>接收方：连续发现5个“1”后其后为“0”，则自动去掉该“0”。其后为“1”，则检查下一位 为“0”则为标志位，为“1”则出错。</p>
<p>控制：该字段表示帧类型，帧编号及其他控制信息。</p>
<p><strong>HDLC工作原理</strong><br>分三个阶段: </p>
<ul>
<li>建立数据链路连接 </li>
<li>传输数据帧<br>当数据链路建立完毕，发送/接收方按照某种流量控制策略发送和接收数据帧，并允许捎带应答。 </li>
<li>拆除链路连线<br>全部数据发送完毕，发送方发出DISC（拆除连接）无编号帧，接收方返回UA作为响应，此时释放链路层实体占用的资源。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E5%B1%82-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" data-id="ckb22iugo00clzwu81rv2h1xl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/第一层-物理层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E5%B1%82-%E7%89%A9%E7%90%86%E5%B1%82/" class="article-date">
  <time datetime="2020-03-14T06:20:04.000Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E5%B1%82-%E7%89%A9%E7%90%86%E5%B1%82/">第一层:物理层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="通信系统模型"><a href="#通信系统模型" class="headerlink" title="通信系统模型"></a><strong>通信系统模型</strong></h2><p><img src="/images/106.png" alt=""></p>
<ul>
<li>信源：将各种信息转换成原始物理信号，如计算机，手机，电话机等。 </li>
<li>变换器/反变换器：对原始物理信号进行变换/反变换，以便适合在给定<br>的信道上传输，如MODEM ， TA(终端适配器) ，光/电转换器等。 </li>
<li>信道：传输信号的一条通路。一条物理线路可构成一个或多个信道。 </li>
<li>噪声源：信道自身的噪声以及周围环境对信道的干扰。如热噪声，闪电，<br>电磁场干扰等。 </li>
<li>信宿：将物理信号转换为信息，如计算机，手机，电话机等。</li>
</ul>
<h3 id="模拟通信与数字通信"><a href="#模拟通信与数字通信" class="headerlink" title="模拟通信与数字通信"></a><strong>模拟通信与数字通信</strong></h3><p>模拟信号: 信号在传输过程中连续变化。<br>数字信号: 信号在传输过程中离散变化。<br>模拟通信：通过模拟信号来传输数据。<br>数字通信：通过数字信号来传输数据。<br><strong>数字通信的优点</strong></p>
<ol>
<li>抗干扰能力强。 </li>
<li>适合远距离传输。 </li>
<li>有利于安全性。 </li>
<li>适合多媒体信息传输。</li>
</ol>
<p><strong>信号带宽</strong><br>信号带宽: 信号能量所集中的频率范围（频谱）。<br><strong>信道带宽</strong><br>信道带宽：信道允许传输信号的频率范围，单位为Hz。<br>如普通电话线的带宽是4000Hz。<br><strong>物理传输媒体（通信介质）</strong><br>1.双绞线<br>非屏蔽双绞线（UTP）<br>三类UTP<br>五类UTP（目前常用）<br>超五类UTP 六类UTP<br>屏蔽双绞线（STP）<br>2.同轴电缆<br>3.光纤<br>4.无线传播媒体</p>
<hr>
<h2 id="数字调制技术"><a href="#数字调制技术" class="headerlink" title="数字调制技术"></a><strong>数字调制技术</strong></h2><p>数字信号的模拟传输<br><img src="/images/107.png" alt=""><br>基带信号：由信源产生的原始电信号。 </p>
<ul>
<li>载波：频率较高的正弦波信号。 </li>
<li>调制：将基带信号加载到载波上，即按基带信号的变化规律去改变载<br>波的某些参数（振幅、频率、相位）。 </li>
<li>解调：从载波中提取基带信号</li>
</ul>
<p><strong>调制技术</strong></p>
<ul>
<li>调幅：用载波信号不同振幅表示数据,，又称幅移键控法ASK。<br>易受突发干扰，适合低速数据传输，典型为1200bps。 </li>
<li>调频: 用载波信号不同频率表示数据，又称频移键控法FSK 。<br>抗干扰优于调幅方式，但频带利用率不高。 </li>
<li>调相：用载波信号不同相位表示数据，又称相移键控法PSK。<br>抗干扰能力强，数据率高，可达9600bps。</li>
</ul>
<hr>
<h2 id="物理层协议"><a href="#物理层协议" class="headerlink" title="物理层协议"></a><strong>物理层协议</strong></h2><p>DTE：数据终端设备            DCE：数据通信设备<br>物理层协议实际上就是通信接口标准，其意义是：只要遵循相同的通信接口标准，任何DTE和DCE均能够衔接而无需关心对方的实现细节。<br>美国电子工业协会EIA制定的RS-232-C，RS-422A，RS-423A，RS-449，<br>RS-485，RS-530等串行接口标准。<br>CCITT(现改名为ITU)制定的X系列和V系列接口标准。<br>V系列定义了数字设备与模拟信道的接口标准，适用于电话信道的数据<br>通信。<br>X系列定义了数据设备与数据信道的接口标准，适用于公用数据网的数<br>据通信。<br>ISO制定的ISO2110, ISO4902,ISO4903, ISO1177等接口标准。<br>IEEE802物理层规范。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E5%B1%82-%E7%89%A9%E7%90%86%E5%B1%82/" data-id="ckb22iugm00cazwu86pqp8wiu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/网络体系结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-03-14T06:09:41.000Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">网络体系结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络构建要素"><a href="#网络构建要素" class="headerlink" title="网络构建要素"></a><strong>网络构建要素</strong></h2><blockquote>
<p>连通性：网络内任何两个节点之间都是连通的<br>交换（Switching）：将来自一条链路 的数据向另一条链路转发，在一个计算机网络内交换机为间接相连的主机提供数据转发功能<br>寻址（Addressing）：任何节点都有能够区别于其它节点的标识/地址<br>路由选择（Routing）：将来自一个网络的数据向另一个网络转发，在互连网中，路由器为不同计算机网络提供数据转发功能<br>路由器是一种专用计算机，具有存储转发，路由选择，差错控制，流量控制等功能的机器。<br>协议（Protocol）：保证数据能够被网络中不同节点按照预定的相同规则进行处理，从而实现特定的网络服务</p>
</blockquote>
<hr>
<h2 id="服务与协议"><a href="#服务与协议" class="headerlink" title="服务与协议"></a><strong>服务与协议</strong></h2><p>服务定义了某层向上一层提供的操作，服务由层之间的接口定义，低层是服务的提供者，而上层是服务的用户<br>协议定义了实现某层服务而需要在不同节点的相同层之间交换的数据的格式、含义以及流程<br>各层协议相互独立，两个通信节点可以自由改变各自相同层所使用的协议，但是层间的接口即低层向上层提供的服务不变<br><img src="/images/104.png" alt=""></p>
<hr>
<h2 id="协议封装"><a href="#协议封装" class="headerlink" title="协议封装"></a><strong>协议封装</strong></h2><p>封装：在发送节点上，每一层都给来自上层的协议数据单元（PDU：Protocol Data Unit）加上代表协议控制信息的头标或者尾部，向下层协议递交。<br>解封装：在目的节点上，每一层协议根据该层协议控制信息完成该层PDU处理后，去掉该层协议相关的头标或者尾部，向上层协议递交。</p>
<hr>
<h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a><strong>网络体系结构</strong></h2><p>Internet 参考模型<br>Internet参考模型中两个核心协议为TCP和IP协议，所以Internet参考模型也称为TCP/IP参考模型。<br><img src="/images/105.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" data-id="ckb22iugn00chzwu8aqcuh1pg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络/计算机网络概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2020-03-14T05:10:33.000Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/">计算机网络概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络的产生和发展"><a href="#计算机网络的产生和发展" class="headerlink" title="计算机网络的产生和发展"></a><strong>计算机网络的产生和发展</strong></h2><ol>
<li>世界上最早的计算机网络ARPANET（Internet的前身），由美国 国防部高级计划研究署研制。 </li>
<li>ARPANET于1969年开通。最初连接美国本土的四个节点（加州 大学洛杉矶分校，加州大学伯克利分校，斯坦福研究所，犹他大学）。 </li>
<li>1972年时， ARPANET网上的网点数已经达到40个。 </li>
<li>1983年MILNET从ARPANET中分离， Internet由此诞生。随后 网络规模不断扩大，连接的主机数目越来越多,由最初的纯军事网络演变成为面向教育、科研、商业的全球性互联网络。 </li>
<li>80年代中期到90年代，Internet经历了两次快速发展。 </li>
</ol>
<hr>
<h2 id="计算机网络定义（供参考）："><a href="#计算机网络定义（供参考）：" class="headerlink" title="计算机网络定义（供参考）："></a><strong>计算机网络定义（供参考）：</strong></h2><p>将若干台具有独立功能的计算机系统，用某种或多种通信介质连接起来，通过完善的网络协议，在数据交换的基础上，实现网络资源共享的系统称为计算机网络。</p>
<ol>
<li>一个网络中包含多个独立的计算机系统。“独立”的含义是指每台计算机可运行各自独立的操作系统，各计算机系统之间的地位平等，无主从之分，任何一台计算机不能干预或强行控制其他计算机的正常运行。 </li>
<li>网络协议是计算机网络的关键技术。 </li>
<li>数据交换是网络的最基本功能，各种资源共享都是建立在数据交换的基础上的。 </li>
<li>资源共享是网络最终目的。</li>
</ol>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a><strong>计算机网络的分类</strong></h2><p><strong>一.按地理范围分类</strong><br>1.局域网LAN (Local Area Network)<br>覆盖范围一般不超过数公里。通常安装在一幢大楼内，大学校园内或厂区内 </p>
<p>2.城域网MAN (Metropolitan Area Network)<br>覆盖范围通常是一个大城市，大约数十公里到上百公里。 </p>
<p>3.广域网WAN (Wide Area Network)<br>覆盖范围一般在数百公里以上<br>Internet就是目前最大的广域网</p>
<p><strong>二.按拓扑结构分类</strong><br>1.星型网<br><img src="/images/100.png" alt=""><br>传输介质从中央结点向外辐射连接其他节点。任何两个结点之间的信息交换必须经过中央结点转发。<br>中央结点的可靠性十分重要，一旦中央结点发生故障，会引起整个网络瘫痪 </p>
<p>2.环形网<br><img src="/images/101.png" alt=""><br>网络上所有的结点通过传输介质连接成一个闭环，<br>任何两个结点的数据交换必须沿环进行<br>一旦结点或链路发生故障，则环路断开，导致网<br>络瘫痪 </p>
<p>3.总线网络<br><img src="/images/102.png" alt=""><br>一条总线连接所有的结点，任何一个结点发送数据其他节点都能收到。<br>任何结点故障都不会影响整个网络正常运行。</p>
<p>4.不规则型网<br><img src="/images/103.png" alt=""><br>每个结点至少要和其他两个结点连接，可靠性好，任何一个结点或一条链路发生故障都 不会影响网络的连通性 布线灵活，几乎不受任何拓扑结构的约束。</p>
<p>局域网：总线型，星型，环型<br>广域网：不规则型<br>点—点通信：独占信道：星型、不规则型<br>多点通信：共享信道：总线型、环型</p>
<p><strong>三.数据交换方式分类</strong><br>1.电路交换网<br>步骤： </p>
<ul>
<li>建立连接 </li>
<li>传输数据 </li>
<li>拆除连接<br>特征： </li>
<li>独占信道资源<br>优缺点: </li>
<li>实时性好 </li>
<li>信道利用率低</li>
</ul>
<p>2.分组交换网<br>特征: </p>
<ul>
<li>化整为零，存储转发<br>优点： </li>
<li>信道利用率高 </li>
<li>有利于差错控制 </li>
<li>有利于安全性<br>缺点: </li>
<li>传输延迟较大，实时性差 </li>
</ul>
<p>3.信元交换网<br>特征: </p>
<ul>
<li>53字节的信元 </li>
<li>高速光纤信道 </li>
<li>高速ATM交换机<br>优点： </li>
<li>克服分组交换网实时性差、电路交换网信道利用<br>率低的缺点 </li>
</ul>
<p><strong>网络带宽（Bandwidth）</strong> </p>
<ul>
<li>特定一段时间内网络所能传送的比特数，单位一般为bps（bit/s）（Kbps、<br>Mbps、Gpbs等）<br>网络吞吐量（Throughput） </li>
<li>网络的可用带宽，也就是应用感受到的有用带宽<br>例如802.11b的带宽为11Mbps，但受各种低效因素的影响网络层感受到的吞吐量只有4Mbps左右<br>与带宽相比，吞吐量用来度量网络性能更加有意义<br>由于网络协议栈的每一层协议都有相应的头标和尾部等开销，还有协议实现机制的开销，因此准确的吞吐量应该指明是哪一个协议的吞吐量</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" data-id="ckb22iugs00czzwu87y5jhzu1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/弗洛伊德(Floyd)算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E7%AE%97%E6%B3%95/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7(Floyd)%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-13T12:50:18.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E7%AE%97%E6%B3%95/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7(Floyd)%E7%AE%97%E6%B3%95/">弗洛伊德(Floyd)算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法九：弗洛伊德-Floyd-算法"><a href="#算法九：弗洛伊德-Floyd-算法" class="headerlink" title="算法九：弗洛伊德(Floyd)算法"></a><strong>算法九：弗洛伊德(Floyd)算法</strong></h2><p><strong>弗洛伊德(Floyd)算法介绍</strong></p>
<ol>
<li>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li>
<li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</li>
<li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li>
<li>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。<br>示例：求最短路径为例说明<br><img src="/images/94.png" alt=""><br><img src="/images/96.png" alt=""><br><img src="/images/97.png" alt=""><br>第一轮循环中，以A(下标为：0)作为中间顶点，距离表和前驱关系更新为：<br><img src="/images/98.png" alt=""><br>分析如下：<br>1)以A顶点作为中间顶点是，B-&gt;A-&gt;C的距离由N-&gt;9，同理C到B；C-&gt;A-&gt;G的距离由N-&gt;12，同理G到C<br>2)更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</li>
</ol>
<p><strong>算法核心</strong><br>三层for循环，一次将每个顶点都作为中间点来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package 算法;</span><br><span class="line"></span><br><span class="line">public class FlodyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char vertexs[] &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;</span><br><span class="line">        final int N&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        int [][]matrix&#x3D;new int[vertexs.length][vertexs.length];</span><br><span class="line">        matrix[0]&#x3D;new int[] &#123;0, 5,  7,  N,  N,  N,  2&#125; ;</span><br><span class="line">        matrix[1]&#x3D;new int[] &#123;5, 0,  N,  9,  N,  N,  3&#125; ;</span><br><span class="line">        matrix[2]&#x3D;new int[] &#123;7, N,  0,  N,  8,  N,  N&#125; ;</span><br><span class="line">        matrix[3]&#x3D;new int[] &#123;N, 9,  N,  0,  N,  4,  N&#125; ;</span><br><span class="line">        matrix[4]&#x3D;new int[] &#123;N, N,  8,  N,  0,  5,  4&#125; ;</span><br><span class="line">        matrix[5]&#x3D;new int[] &#123;N, N,  N,  4,  5,  0,  6&#125; ;</span><br><span class="line">        matrix[6]&#x3D;new int[] &#123;2, 3,  N,  N,  4,  6,  0&#125; ;</span><br><span class="line">        Flody f&#x3D;new Flody(matrix,vertexs);</span><br><span class="line">        f.flody();</span><br><span class="line">        f.findway(&#39;A&#39;,&#39;D&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Flody</span><br><span class="line">&#123;</span><br><span class="line">    int[][] dis;&#x2F;&#x2F;图中各个点的距离表</span><br><span class="line">    int[][] mid;&#x2F;&#x2F;图中各个点的中间结点表，初始化邻接点</span><br><span class="line">    char[] vs;</span><br><span class="line">    Flody(int[][] dis,char[] v)</span><br><span class="line">    &#123;</span><br><span class="line">        this.dis&#x3D;dis;</span><br><span class="line">        mid&#x3D;new  int[dis.length][dis.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mid.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; mid.length; j++) &#123;</span><br><span class="line">                mid[i][j]&#x3D;j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vs&#x3D;v;</span><br><span class="line">    &#125;</span><br><span class="line">    public void flody()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int k &#x3D; 0; k &lt; dis.length; k++) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    if(dis[i][k]+dis[k][j]&gt;&#x3D;0&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dis[i][j]&#x3D;dis[i][k]+dis[k][j];</span><br><span class="line">                        mid[i][j]&#x3D;mid[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mid.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; mid.length; j++) &#123;</span><br><span class="line">                System.out.print(vs[mid[i][j]]+&quot;   &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void findway(char V1,char V2)</span><br><span class="line">    &#123;   int v1&#x3D;0,v2&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vs.length; i++) &#123;</span><br><span class="line">            if(vs[i]&#x3D;&#x3D;V1) v1&#x3D;i;</span><br><span class="line">            if(vs[i]&#x3D;&#x3D;V2) v2&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        findway(v1,v2);</span><br><span class="line">        System.out.println(vs[v2]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void findway(int v1,int v2)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(vs[v1]);</span><br><span class="line">        if(mid[v1][v2]!&#x3D;v2)</span><br><span class="line">            findway(mid[v1][v2],v2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/13/%E7%AE%97%E6%B3%95/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7(Floyd)%E7%AE%97%E6%B3%95/" data-id="ckb22iugh00bszwu831x1hian" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/迪杰斯特拉算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E7%AE%97%E6%B3%95/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-13T08:30:32.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E7%AE%97%E6%B3%95/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/">迪杰斯特拉算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法八：迪杰斯特拉算法"><a href="#算法八：迪杰斯特拉算法" class="headerlink" title="算法八：迪杰斯特拉算法"></a><strong>算法八：迪杰斯特拉算法</strong></h2><p><strong>应用场景-最短路径问题</strong><br><img src="/images/94.png" alt=""></p>
<ol>
<li>战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</li>
<li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li>
<li>问：如何计算出G村庄到 其它各个村庄的最短距离? </li>
<li>如果从其它点出发到各个点的最短距离又是多少?</li>
</ol>
<p><strong>迪杰斯特拉(Dijkstra)算法介绍</strong><br>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。<br><strong>迪杰斯特拉(Dijkstra)算法过程</strong></p>
<p>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</p>
<ol>
<li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径，记vi为访问过的(只有确认了最短路径才能别成为访问过得，而不是广度优先遍历遍历到的)</li>
<li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</li>
<li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束<br>需要用到的数组为：visited[]:记录是否最短路径确认过,dis[]到出发点的距离,pre[]：最短路径中自己的前驱结点.</li>
</ol>
<p><strong>实例：</strong><br><img src="/images/95.png" alt=""></p>
<h3 id="Dijkstra算法核心"><a href="#Dijkstra算法核心" class="headerlink" title="Dijkstra算法核心"></a><strong>Dijkstra算法核心</strong></h3><ol>
<li><strong>找</strong>//1.循环遍历未确定的节点，找出距起点路径最小的那个节点temi</li>
<li><strong>确认</strong>//2.将temi标记确认</li>
<li><strong>更新</strong>//3.更新该确认节点的邻接节点的dis</li>
</ol>
<p><strong>需要特别注意的是：</strong>因为程序中设不相连节点距离为无穷大，所以距离相加的时候要特别注意值越界<br>if ((dis[i] + matrix[i][j])&gt;0&amp;&amp; dis[i] + matrix[i][j]&lt; dis[j])</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package 算法;</span><br><span class="line"></span><br><span class="line">        import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class DijkstraDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int inf&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        int[][] matraix&#x3D;&#123;</span><br><span class="line">                &#123;0,4,inf,inf,inf,inf,inf,8,inf&#125;,</span><br><span class="line">                &#123;4,0,8,inf,inf,inf,inf,3,inf&#125;,</span><br><span class="line">                &#123;inf,8,0,7,inf,4,inf,inf,2&#125;,</span><br><span class="line">                &#123;inf,inf,7,0,9,14,inf,inf,inf&#125;,</span><br><span class="line">                &#123;inf,inf,inf,9,0,10,inf,inf,inf&#125;,</span><br><span class="line">                &#123;inf,inf,4,14,10,0,2,inf,inf&#125;,</span><br><span class="line">                &#123;inf,inf,inf,inf,inf,2,0,6,6&#125;,</span><br><span class="line">                &#123;8,3,inf,inf,inf,inf,6,0,1&#125;,</span><br><span class="line">                &#123;inf,inf,2,inf,inf,inf,6,1,0&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Dijkstra d&#x3D;new Dijkstra(matraix);</span><br><span class="line">        d.dijikstra(4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dijkstra</span><br><span class="line">&#123;</span><br><span class="line">    int[][] matrix;&#x2F;&#x2F;图的邻接矩阵</span><br><span class="line">    int[] visited;&#x2F;&#x2F;表示顶点是否被访问过</span><br><span class="line">    int[] dis;&#x2F;&#x2F;出发点到该顶点的最短距离</span><br><span class="line">    int[] pre;&#x2F;&#x2F;前驱顶点</span><br><span class="line">    int num&#x3D;0;&#x2F;&#x2F;表示已确定的顶点个数</span><br><span class="line">    private static final int inf&#x3D;Integer.MAX_VALUE;</span><br><span class="line">   &#x2F;&#x2F;图的初始化</span><br><span class="line">    Dijkstra(int[][] matrix)</span><br><span class="line">    &#123;</span><br><span class="line">        dis&#x3D;new int[matrix.length];</span><br><span class="line">        pre&#x3D;new int[matrix.length];</span><br><span class="line">        visited&#x3D;new int[matrix.length];</span><br><span class="line">        this.matrix&#x3D;matrix;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">            dis[i]&#x3D;inf;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pre.length; i++) &#123;</span><br><span class="line">            pre[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;迪杰斯特拉算法主体</span><br><span class="line">    public void dijikstra(int start)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;先初始化出发节点start</span><br><span class="line">        visited[start]&#x3D;1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; matrix[start].length; i++) &#123;</span><br><span class="line">            dis[i]&#x3D;matrix[start][i];</span><br><span class="line">            if(dis[i]!&#x3D;inf&amp;&amp;dis[i]!&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]&#x3D;start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        &#x2F;&#x2F;循环遍历，每遍历一次，确定的节点就会增加一个，所以只需要遍历dis.length次</span><br><span class="line">        while(num&lt;dis.length)</span><br><span class="line">        &#123;</span><br><span class="line">            int temmin&#x3D;inf;&#x2F;&#x2F;临时变量记录最小值</span><br><span class="line">            int temi&#x3D;0;&#x2F;&#x2F;临时变量，记录最小值下标</span><br><span class="line">            &#x2F;&#x2F;1.循环遍历未确定的节点，找出距起点路径最小的那个节点temi</span><br><span class="line">            for (int i &#x3D; 0; i &lt; visited.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(visited[i]&#x3D;&#x3D;0)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(dis[i]&lt;temmin)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temmin&#x3D;dis[i];</span><br><span class="line">                        temi&#x3D;i;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;2.将temi标记确认</span><br><span class="line">            visited[temi]&#x3D;1;</span><br><span class="line">            &#x2F;&#x2F;3.更新该确认节点的邻接节点的dis</span><br><span class="line">            update(temi);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(pre));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;更新下标为i的邻接节点的dis[]</span><br><span class="line">    public void update(int i) &#123;</span><br><span class="line">        int temmin &#x3D; inf;&#x2F;&#x2F;临时变量记录最小值</span><br><span class="line">        int temi &#x3D; -1;&#x2F;&#x2F;临时变量，记录最小值下标</span><br><span class="line">        for (int j &#x3D; 0; j &lt; matrix[i].length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (visited[j] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;   &#x2F;&#x2F;更新dis表</span><br><span class="line">                if ((dis[i] + matrix[i][j])&gt;0&amp;&amp; dis[i] + matrix[i][j]&lt; dis[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[j] &#x3D; dis[i] + matrix[i][j];</span><br><span class="line">                    pre[j]&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/13/%E7%AE%97%E6%B3%95/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/" data-id="ckb22iugj00c2zwu8amz73j19" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/普利姆(Prim)算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/%E7%AE%97%E6%B3%95/%E6%99%AE%E5%88%A9%E5%A7%86(Prim)%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-11T01:23:10.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/%E7%AE%97%E6%B3%95/%E6%99%AE%E5%88%A9%E5%A7%86(Prim)%E7%AE%97%E6%B3%95/">普利姆(Prim)算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法六：普利姆-Prim-算法"><a href="#算法六：普利姆-Prim-算法" class="headerlink" title="算法六：普利姆(Prim)算法"></a><strong>算法六：普利姆(Prim)算法</strong></h2><p><strong>应用场景-修路问题</strong><br>看一个应用场景和问题：<br><img src="/images/90.png" alt=""><br>有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通<br>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里<br>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?<br>思路: 将10条边，连接即可，但是总的里程数不是最小.<br>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. </p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a><strong>最小生成树</strong></h3><p>修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。</p>
<ol>
<li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 . </li>
<li>N个顶点，一定有N-1条边</li>
<li>包含全部顶点</li>
<li>N-1条边都在图中</li>
<li>举例说明(如图:)<br><img src="/images/91.png" alt=""></li>
<li>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</li>
</ol>
<h3 id="普里姆算法介绍"><a href="#普里姆算法介绍" class="headerlink" title="普里姆算法介绍"></a><strong>普里姆算法介绍</strong></h3><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图<br>普利姆的算法如下:</p>
<ol>
<li>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </li>
<li>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</li>
<li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</li>
<li>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</li>
<li>提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.<br><img src="/images/90.png" alt=""><blockquote>
<p>从A开始的话，找到已有节点A的最小边(连接未有结点)<br> 是A–&gt;G:2<br> 然后G-&gt;B:3<br> G-&gt;E:4<br> G-&gt;F:5<br> F-&gt;D:4<br> A-&gt;C:7</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class PrimDeom</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Prim P&#x3D;new Prim();</span><br><span class="line">            P.prim(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Prim &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;NodeP&gt; nop&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;NodeP&gt; yes&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    Prim()</span><br><span class="line">    &#123;</span><br><span class="line">        NodeP A&#x3D;new NodeP(&#39;A&#39;);</span><br><span class="line">        NodeP B&#x3D;new NodeP(&#39;B&#39;);</span><br><span class="line">        NodeP C&#x3D;new NodeP(&#39;C&#39;);</span><br><span class="line">        NodeP D&#x3D;new NodeP(&#39;D&#39;);</span><br><span class="line">        NodeP E&#x3D;new NodeP(&#39;E&#39;);</span><br><span class="line">        NodeP F&#x3D;new NodeP(&#39;F&#39;);</span><br><span class="line">        NodeP G&#x3D;new NodeP(&#39;G&#39;);</span><br><span class="line">        A.add(B,5);A.add(C,7);A.add(G,2);</span><br><span class="line">        B.add(A,5);B.add(G,3);B.add(D,9);</span><br><span class="line">        C.add(A,7);C.add(E,8);</span><br><span class="line">        D.add(B,9);D.add(F,4);</span><br><span class="line">        F.add(G,6);F.add(D,4);F.add(E,5);</span><br><span class="line">        E.add(F,5);E.add(C,8);E.add(G,4);</span><br><span class="line">        G.add(A,2);G.add(B,3);G.add(F,6);G.add(E,4);</span><br><span class="line">        nop.add(A);nop.add(B);nop.add(C);nop.add(D);</span><br><span class="line">        nop.add(E);nop.add(F);nop.add(G);</span><br><span class="line">    &#125;</span><br><span class="line">    public void prim(int n)</span><br><span class="line">    &#123;   yes.add(nop.get(n));</span><br><span class="line">        nop.remove(n);</span><br><span class="line">        while(nop.size()&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;求出最小边，v1记录yes中的NodeP，v2记录nop中的NodeP</span><br><span class="line">            &#x2F;&#x2F;并随便假定一个最小边</span><br><span class="line">            NodeP v1&#x3D;yes.get(0);</span><br><span class="line">            NodeP v2&#x3D;nop.get(0);</span><br><span class="line">            for (NodeP py : yes)</span><br><span class="line">            &#123;</span><br><span class="line">                for (NodeP pn : nop)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(py.neighbour.get(pn)!&#x3D;null</span><br><span class="line">                            &amp;&amp;v1.neighbour.get(v2)&#x3D;&#x3D;null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        v1&#x3D;py;v2&#x3D;pn;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(py.neighbour.get(pn)!&#x3D;null</span><br><span class="line">                       &amp;&amp;v1.neighbour.get(v2)!&#x3D;null</span><br><span class="line">                       &amp;&amp;py.neighbour.get(pn)&lt;v1.neighbour.get(v2))</span><br><span class="line">                    &#123;</span><br><span class="line">                        v1&#x3D;py;v2&#x3D;pn;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(v1.c+&quot;-&gt;&quot;+v2.c+&quot;权值&quot;+v1.neighbour.get(v2));</span><br><span class="line">            yes.add(v2);</span><br><span class="line">            nop.remove(v2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class NodeP</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    HashMap&lt;NodeP,Integer&gt;  neighbour&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public NodeP(char c) &#123;</span><br><span class="line">        this.c &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(NodeP np,int i)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbour.put(np,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/11/%E7%AE%97%E6%B3%95/%E6%99%AE%E5%88%A9%E5%A7%86(Prim)%E7%AE%97%E6%B3%95/" data-id="ckb22iugf00blzwu8emm6hr6b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/贪心算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-10T13:14:23.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">贪心算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法五：贪心算法"><a href="#算法五：贪心算法" class="headerlink" title="算法五：贪心算法"></a><strong>算法五：贪心算法</strong></h2><p><strong>贪心算法介绍</strong></p>
<ol>
<li>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</li>
<li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li>
</ol>
<p><strong>应用场景-集合覆盖问题</strong><br>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号<br><img src="/images/88.png" alt=""><br>思路分析:<br>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ -1 个,假设每秒可以计算10个子集， 如图:<br><img src="/images/89.png" alt=""><br>使用贪婪算法，效率高:<br>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:</p>
<ol>
<li>遍历所有的广播电台, 找到一个<strong>覆盖了最多未覆盖的地区</strong>的电台(此电台可能包含一些已覆盖的地区，但没有关系） </li>
<li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li>
<li>重复第1步直到覆盖了全部的地区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;贪心算法</span><br><span class="line">public class GreedyAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GreedyAlgorithm g&#x3D;new GreedyAlgorithm();</span><br><span class="line">        g.choose();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;String&gt; allAreas&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;String[]&gt; k&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    String[] k1&#x3D;&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;天津&quot;&#125;;</span><br><span class="line">    String[] k2&#x3D;&#123;&quot;广州&quot;, &quot;北京&quot;, &quot;深圳&quot;&#125;;</span><br><span class="line">    String[] k3&#x3D;&#123;&quot;成都&quot;, &quot;上海&quot;, &quot;杭州&quot;&#125;;</span><br><span class="line">    String[] k4&#x3D;&#123;&quot;上海&quot;, &quot;天津&quot;&#125;;</span><br><span class="line">    String[] k5&#x3D;&#123;&quot;杭州&quot;, &quot;大连&quot;&#125;;</span><br><span class="line">    int[] num&#x3D;new int[5];</span><br><span class="line">    ArrayList&lt;Integer&gt; choices&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    public void choose()</span><br><span class="line">    &#123;</span><br><span class="line">        allAreas.add(&quot;北京&quot;);</span><br><span class="line">        allAreas.add(&quot;上海&quot;);</span><br><span class="line">        allAreas.add(&quot;天津&quot;);</span><br><span class="line">        allAreas.add(&quot;广州&quot;);</span><br><span class="line">        allAreas.add(&quot;深圳&quot;);</span><br><span class="line">        allAreas.add(&quot;成都&quot;);</span><br><span class="line">        allAreas.add(&quot;杭州&quot;);</span><br><span class="line">        allAreas.add(&quot;大连&quot;);</span><br><span class="line">        k.add(k1);k.add(k2);k.add(k3);k.add(k4);k.add(k5);</span><br><span class="line">       while(allAreas.size()&gt;0)</span><br><span class="line">       &#123;</span><br><span class="line">           int i&#x3D;0,max;</span><br><span class="line">           &#x2F;&#x2F;遍历每个电台，并用num[]记录各个电台的覆盖未被覆盖地区的数量</span><br><span class="line">           for (String[] strings : k)</span><br><span class="line">           &#123;</span><br><span class="line">               for (String s : strings)</span><br><span class="line">               &#123;</span><br><span class="line">                   if(allAreas.contains(s))</span><br><span class="line">                       num[i]++;</span><br><span class="line">               &#125;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;遍历num[]数组，找出覆盖最大的那个电台</span><br><span class="line">           max&#x3D;0;</span><br><span class="line">           for (int i1 &#x3D; 0; i1 &lt; num.length; i1++) &#123;</span><br><span class="line">               if(num[i1]&gt;num[max])</span><br><span class="line">                   max&#x3D;i1;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;将num[]重置</span><br><span class="line">           for (int i1 &#x3D; 0; i1 &lt; num.length; i1++) &#123;</span><br><span class="line">               num[i1]&#x3D;0;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;将覆盖最大的加入选择名单里</span><br><span class="line">           choices.add(max+1);</span><br><span class="line">           &#x2F;&#x2F;所以地区中将这个电台覆盖的地区移除</span><br><span class="line">           for (String s : k.get(max)) &#123;</span><br><span class="line">               allAreas.remove(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(Arrays.toString(choices.toArray()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/10/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" data-id="ckb22iugj00byzwu88qh66g7s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/10/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>