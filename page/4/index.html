<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://tukuai.github.io/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Tukuai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式/观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-19T04:50:16.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="天气预报项目需求"><a href="#天气预报项目需求" class="headerlink" title="天气预报项目需求"></a><strong>天气预报项目需求</strong></h2><p>天气预报项目需求,具体要求如下：</p>
<p>1) 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。<br>2) 需要设计开放型API，便于其他第三方也能接入气象站获取数据。<br>3) 提供温度、气压和湿度的接口<br>4) 测量数据更新时，要能实时的通知给第三方</p>
<h3 id="天气预报设计方案1-普通方案"><a href="#天气预报设计方案1-普通方案" class="headerlink" title="天气预报设计方案1-普通方案"></a><strong>天气预报设计方案1-普通方案</strong></h3><p>WeatherData类 通过对气象站项目的分析，我们可以初步设计出一个WeatherData类 说明:</p>
<p>1) 通过getXxx方法，可以让第三方接入，并得到相关信息.<br>2) 当数据有更新时，气象站通过调用dataChange() 去更新数据，当第三方再次获取时，就能得到最新数据，当然也可以推送。<br><img src="/images/230.png" alt=""></p>
<p><strong>示意图</strong><br><img src="/images/231.png" alt=""><br>CurrentConditions(当前的天气情况) 可以理解成是我们气象局的网站 //推送</p>
<p><strong>代码实现</strong></p>
<p><strong>气象局</strong></p>
<pre><code>public class WeatherData {
    private float temperatrue;
    private float pressure;
    private float humidity;
    private CurrentConditions currentConditions;
    public WeatherData(CurrentConditions currentConditions) {
        this.currentConditions = currentConditions;
    }
    public float getTemperature() {
        return temperatrue;
    }
    public float getPressure() {
        return pressure;
    }
    public float getHumidity() {
        return humidity;
    }
    public void dataChange() {
        currentConditions.update(getTemperature(), getPressure(), getHumidity());
    }
    public void setData(float temperature, float pressure, float humidity) {
        this.temperatrue = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        dataChange();
    }
}</code></pre><p><strong>第三方网站</strong></p>
<pre><code>public class CurrentConditions {
    private float temperature;
    private float pressure;
    private float humidity;
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        display();
    }
    public void display() {
        System.out.println(&quot;***Today mTemperature: &quot; + temperature + &quot;***&quot;);
        System.out.println(&quot;***Today mPressure: &quot; + pressure + &quot;***&quot;);
        System.out.println(&quot;***Today mHumidity: &quot; + humidity + &quot;***&quot;);
    }
}</code></pre><p><strong>测试</strong></p>
<pre><code>public class InternetWeather {
    public static void main(String[] args) {
        CurrentConditions currentConditions = new CurrentConditions();
        WeatherData weatherData = new WeatherData(currentConditions);
        weatherData.setData(30, 150, 40);
    }
}</code></pre><p><strong>问题分析</strong></p>
<p>1) 其他第三方接入气象站获取数据的问题<br>2) 无法在运行时动态的添加第三方 (新浪网站)<br>3) 违反ocp原则=&gt;观察者模式<br>//在WeatherData中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到dataChange, 不利于维护，也不是动态加入</p>
<pre><code>public void dataChange() {
currentConditions.update(getTemperature(), getPressure(), getHumidity());
}</code></pre><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><strong>观察者模式</strong></h2><p><strong>观察者模式(Observer)原理</strong></p>
<ul>
<li>观察者模式类似订牛奶业务<br>1) 奶站/气象局：Subject<br>2) 用户/第三方网站：Observer</li>
<li>Subject：登记注册、移除和通知<br>1) registerObserver 注册<br>2) removeObserver 移除<br>3) notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，看具体需求定</li>
<li>Observer：接收输入</li>
<li>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer,Subject通知Observer变化,比如这里的奶站是Subject，是1的一方。用户时Observer，是多的一方。</li>
</ul>
<h3 id="观察者模式解决天气预报需求"><a href="#观察者模式解决天气预报需求" class="headerlink" title="观察者模式解决天气预报需求"></a><strong>观察者模式解决天气预报需求</strong></h3><p><strong>思路分析图解(类图)</strong><br><img src="/images/232.png" alt=""><br><strong>观察者模式的好处</strong></p>
<p>1) 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。<br>2) 这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类WeatherData不会修改代码，遵守了ocp原则。</p>
<p><strong>代码实现</strong><br><strong>气象局接口</strong></p>
<pre><code>public interface Subject {    
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();
}</code></pre><p><strong>气象局实体类</strong></p>
<pre><code>/**
 * 类是核心
 * 1. 包含最新的天气情况信息 
 * 2. 含有 观察者集合，使用ArrayList管理
 * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息
 * @author Administrator
 *
 */
public class WeatherData implements Subject {
    private float temperatrue;
    private float pressure;
    private float humidity;
    //观察者集合
    private ArrayList&lt;Observer&gt; observers;

    //加入新的第三方
    public WeatherData() {
        observers = new ArrayList&lt;Observer&gt;();
    }
    public float getTemperature() {
        return temperatrue;
    }
    public float getPressure() {
        return pressure;
    }
    public float getHumidity() {
        return humidity;
    }
    public void dataChange() {
        //调用 接入方的 update

        notifyObservers();
    }
    //当数据有更新时，就调用 setData
    public void setData(float temperature, float pressure, float humidity) {
        this.temperatrue = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        //调用dataChange， 将最新的信息 推送给 接入方 currentConditions
        dataChange();
    }
    //注册一个观察者
    @Override
    public void registerObserver(Observer o) {
        // TODO Auto-generated method stub
        observers.add(o);
    }
    //移除一个观察者
    @Override
    public void removeObserver(Observer o) {
        // TODO Auto-generated method stub
        if(observers.contains(o)) {
            observers.remove(o);
        }
    }
    //遍历所有的观察者，并通知
    @Override
    public void notifyObservers() {
        // TODO Auto-generated method stub
        for(int i = 0; i &lt; observers.size(); i++) {
            observers.get(i).update(this.temperatrue, this.pressure, this.humidity);
        }
    }
}</code></pre><p><strong>观察者接口，有观察者来实现</strong></p>
<pre><code>public interface Observer {
    public void update(float temperature, float pressure, float humidity);
}</code></pre><p><strong>第三方网站1</strong></p>
<pre><code>public class CurrentConditions implements Observer {
    // 温度，气压，湿度
    private float temperature;
    private float pressure;
    private float humidity;
    // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        display();
    }
    // 显示
    public void display() {
        System.out.println(&quot;***Today mTemperature: &quot; + temperature + &quot;***&quot;);
        System.out.println(&quot;***Today mPressure: &quot; + pressure + &quot;***&quot;);
        System.out.println(&quot;***Today mHumidity: &quot; + humidity + &quot;***&quot;);
    }
}</code></pre><p><strong>第三方网站2</strong></p>
<pre><code>public class BaiduSite implements Observer {
    // 温度，气压，湿度
    private float temperature;
    private float pressure;
    private float humidity;
    // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        display();
    }
    // 显示
    public void display() {
        System.out.println(&quot;===百度网站====&quot;);
        System.out.println(&quot;***百度网站 气温 : &quot; + temperature + &quot;***&quot;);
        System.out.println(&quot;***百度网站 气压: &quot; + pressure + &quot;***&quot;);
        System.out.println(&quot;***百度网站 湿度: &quot; + humidity + &quot;***&quot;);
    }
}</code></pre><p><strong>测试</strong></p>
<pre><code>public class Client {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //创建一个WeatherData
        WeatherData weatherData = new WeatherData();                
        //创建观察者
        CurrentConditions currentConditions = new CurrentConditions();
        BaiduSite baiduSite = new BaiduSite();

        //注册到weatherData
        weatherData.registerObserver(currentConditions);
        weatherData.registerObserver(baiduSite);

        //测试
        System.out.println(&quot;通知各个注册的观察者, 看看信息&quot;);
        weatherData.setData(10f, 100f, 30.3f);


        weatherData.removeObserver(currentConditions);
        //测试
        System.out.println();
        System.out.println(&quot;通知各个注册的观察者, 看看信息&quot;);
        weatherData.setData(10f, 100f, 30.3f);
    }
}</code></pre><p><strong>结果</strong></p>
<pre><code>通知各个注册的观察者, 看看信息
***Today mTemperature: 10.0***
***Today mPressure: 100.0***
***Today mHumidity: 30.3***
===百度网站====
***百度网站 气温 : 10.0***
***百度网站 气压: 100.0***
***百度网站 湿度: 30.3***
通知各个注册的观察者, 看看信息
===百度网站====
***百度网站 气温 : 10.0***
***百度网站 气压: 100.0***
***百度网站 湿度: 30.3***</code></pre><h2 id="观察者模式在Jdk应用的源码分析"><a href="#观察者模式在Jdk应用的源码分析" class="headerlink" title="观察者模式在Jdk应用的源码分析"></a><strong>观察者模式在Jdk应用的源码分析</strong></h2><p>1) Jdk的Observable类(类似于上述Subject)和Observer接口(类似于上述Observer)就使用了观察者模式</p>
<p>2) 代码分析+模式角色分析<br><img src="/images/233.png" alt=""><br><img src="/images/235.png" alt=""><br><img src="/images/234.png" alt=""><br><img src="/images/236.png" alt=""><br>3) 模式角色分析</p>
<ul>
<li>Observable 的作用和地位等价于 我们前面讲过Subject</li>
<li>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer的方法 add.. delete .. notify… </li>
<li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有update</li>
<li>Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是类，通过继承来实现观察者模式</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugv00ddzwu8gadp1wft" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/迭代器模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-18T14:18:41.000Z" itemprop="datePublished">2020-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">迭代器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="看一个具体的需求"><a href="#看一个具体的需求" class="headerlink" title="看一个具体的需求"></a><strong>看一个具体的需求</strong></h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图：<br><img src="/images/225.png" alt=""></p>
<h2 id="使用传统的设计方案"><a href="#使用传统的设计方案" class="headerlink" title="使用传统的设计方案"></a><strong>使用传统的设计方案</strong></h2><p><img src="/images/226.png" alt=""></p>
<p><strong>传统的方式的问题分析</strong></p>
<p>1) 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的<br>2) 实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的遍历的操作<br>3) 解决方案：=&gt; 迭代器模式</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><strong>迭代器模式</strong></h2><h3 id="迭代器模式基本介绍"><a href="#迭代器模式基本介绍" class="headerlink" title="迭代器模式基本介绍"></a><strong>迭代器模式基本介绍</strong></h3><p>1) 迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式<br>2) 如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。<br>3) 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。</p>
<h3 id="迭代器模式的原理类图"><a href="#迭代器模式的原理类图" class="headerlink" title="迭代器模式的原理类图"></a>迭代器模式的原理类图</h3><p>迭代器模式的原理类图<br><img src="/images/227.png" alt=""><br><strong>对原理类图的说明-即(迭代器模式的角色及职责)</strong> </p>
<p>1) Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove<br>2) ConcreteIterator : 具体的迭代器类，管理迭代<br>3) Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦<br>4) ConcreteAggreage : 具体的聚合持有对象集合， 并提供一个方法，返回一个迭代器， 该迭代器可以正确遍历 集合<br>5) Client :客户端， 通过 Iterator 和 Aggregate 依赖子类</p>
<h3 id="迭代器模式应用实例"><a href="#迭代器模式应用实例" class="headerlink" title="迭代器模式应用实例"></a>迭代器模式应用实例</h3><p>迭代器模式应用实例</p>
<p>1) 应用实例要求编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。<br>2) 设计思路分析<br><img src="/images/228.png" alt=""><br>3) 代码实现<br><strong>系</strong></p>
<pre><code>public class Department {
    private String name;
    private String desc;
    public Department(String name, String desc) {
        super();
        this.name = name;
        this.desc = desc;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getDesc() {
        return desc;
    }
    public void setDesc(String desc) {
        this.desc = desc;
    }
}</code></pre><p><strong>学院接口</strong></p>
<pre><code>public interface College {
    public String getName();
    //增加系的方法 
    public void addDepartment(String name, String desc);
    //返回一个迭代器,遍历 
    public Iterator createIterator();
}</code></pre><p><strong>计算机学院实例</strong></p>
<pre><code>public class ComputerCollege implements College {
    Department[] departments;
    int numOfDepartment = 0;// 保存当前数组的对象个数 
    public ComputerCollege() {
        departments = new Department[5];
        addDepartment(&quot;Java 专业&quot;, &quot; Java 专业 &quot;);
        addDepartment(&quot;PHP 专业&quot;, &quot; PHP 专业 &quot;);
        addDepartment(&quot;大数据专业&quot;, &quot; 大数据专业 &quot;);
    }
    @Override
    public String getName() {
        return &quot;计算机学院&quot;;
    }
    @Override
    public void addDepartment(String name, String desc) {
        Department department = new Department(name, desc);
        departments[numOfDepartment] = department;
        numOfDepartment += 1;
    }
    @Override
    public Iterator createIterator() {
        return new ComputerCollegeIterator(departments);
    }
}</code></pre><p><strong>计算机学院迭代器</strong></p>
<pre><code>public class ComputerCollegeIterator implements Iterator {
    //这里我们需要 Department 是以怎样的方式存放=&gt;数组 
    Department[] departments;
    int position = 0; //遍历的位置 
    public ComputerCollegeIterator(Department[] departments) {
        this.departments = departments;
    }
    //判断是否还有下一个元素 
    @Override
    public boolean hasNext() {
        if (position &gt;= departments.length || departments[position] == null) {
            return false;
        } else {
            return true;
        }
    }
    @Override
    public Object next() {
        Department department = departments[position];
        position += 1;
        return department;
    }
    //删除的方法，默认空实现 
    public void remove() {
    }
}</code></pre><p><strong>信息工程学院</strong></p>
<pre><code>public class InfoCollege implements College {
    List&lt;Department&gt; departmentList;
    public InfoCollege() {
        departmentList = new ArrayList&lt;Department&gt;();
        addDepartment(&quot;信息安全专业&quot;, &quot; 信息安全专业 &quot;);
        addDepartment(&quot;网络安全专业&quot;, &quot; 网络安全专业 &quot;);
        addDepartment(&quot;服务器安全专业&quot;, &quot; 服务器安全专业 &quot;);
    }
    @Override
    public String getName() {
        return &quot;信息工程学院&quot;;
    }
    @Override
    public void addDepartment(String name, String desc) {
        Department department = new Department(name, desc);
        departmentList.add(department);
    }
    @Override
    public Iterator createIterator() {
        return departmentList.iterator();
    }
}</code></pre><p><strong>信息工程学院迭代器,可以使用JDK自带的iterator()</strong></p>
<p><strong>完成对所有学院的输出</strong></p>
<pre><code>public class OutPutImpl {
    //学院集合 
    List&lt;College&gt; collegeList;
    public OutPutImpl(List&lt;College&gt; collegeList) {
        this.collegeList = collegeList;
    }
    //遍历所有学院,然后调用 printDepartment 输出各个学院的系 
    public void printCollege() {
        //从 collegeList 取出所有学院, Java 中的 List 已经实现 Iterator 
        Iterator&lt;College&gt; iterator = collegeList.iterator();
        while (iterator.hasNext()) {
            //取出一个学院 
            College college = iterator.next();
            System.out.println(&quot;=== &quot; + college.getName() + &quot;=====&quot;);
            printDepartment(college.createIterator()); //得到对应迭代器 
        }
    }
    /*输出 学院输出 系*/ 
    public void printDepartment(Iterator iterator) {
        while (iterator.hasNext()) {
            Department d = (Department) iterator.next();
            System.out.println(d.getName());
        }
    }
}</code></pre><p><strong>客户端</strong></p>
<pre><code> public class Client {
    public static void main(String[] args) {
        //创建学院 
        List&lt;College&gt; collegeList = new ArrayList&lt;College&gt;();
        ComputerCollege computerCollege = new ComputerCollege();
        InfoCollege infoCollege = new InfoCollege();
        collegeList.add(computerCollege);
        collegeList.add(infoCollege); 
        OutPutImpl outPutImpl = new OutPutImpl(collegeList);
        outPutImpl.printCollege();
    }
}</code></pre><p><strong>输出</strong></p>
<pre><code>=== 计算机学院=====
Java 专业
PHP 专业
大数据专业
=== 信息工程学院=====
信息安全专业
网络安全专业
服务器安全专业</code></pre><h3 id="迭代器模式在JDK-ArrayList集合应用的源码分析"><a href="#迭代器模式在JDK-ArrayList集合应用的源码分析" class="headerlink" title="迭代器模式在JDK-ArrayList集合应用的源码分析"></a>迭代器模式在JDK-ArrayList集合应用的源码分析</h3><p>迭代器模式在JDK-ArrayList集合应用的源码分析</p>
<p>1) JDK的ArrayList 集合中就使用了迭代器模式<br>2) 代码分析+类图+说明<br><img src="/images/215.png" alt=""></p>
<pre><code>public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException(&quot;remove&quot;);
    }
}
public interface List&lt;E&gt; extends Collection&lt;E&gt; {
    Iterator&lt;E&gt; iterator();
    }</code></pre><p><strong>在ArrayList源代码里面实现了iterator</strong></p>
<pre><code>public Iterator&lt;E&gt; iterator() {
            return listIterator();
        }
 private class Itr implements Iterator&lt;E&gt; {
int cursor;       // index of next element to return
int lastRet = -1; // index of last element returned; -1 if no such
int expectedModCount = modCount;
Itr() {}
public boolean hasNext() {
    return cursor != size;
}
@SuppressWarnings(&quot;unchecked&quot;)
public E next() {
    checkForComodification();
    int i = cursor;
    if (i &gt;= size)
        throw new NoSuchElementException();
    Object[] elementData = ArrayList.this.elementData;
    if (i &gt;= elementData.length)
        throw new ConcurrentModificationException();
    cursor = i + 1;
    return (E) elementData[lastRet = i];
}
public void remove() {
    if (lastRet &lt; 0)
        throw new IllegalStateException();
    checkForComodification();
    try {
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException ex) {
        throw new ConcurrentModificationException();
    }
}</code></pre><p>3) 角色分析说明</p>
<ul>
<li>内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类</li>
<li>List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象</li>
<li>ArrayList 是实现聚合接口List 的子类，实现了iterator()</li>
<li>Iterator 接口系统提供</li>
<li>迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</li>
</ul>
<h3 id="迭代器模式的注意事项和细节"><a href="#迭代器模式的注意事项和细节" class="headerlink" title="迭代器模式的注意事项和细节"></a>迭代器模式的注意事项和细节</h3><p>迭代器模式的注意事项和细节<br><strong>优点</strong></p>
<p>1) 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。<br>2) 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。<br>3) 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。<br>4) 当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式<br><strong>缺点</strong><br>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugx00dlzwu8d8pf5wh0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/代理模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-18T08:28:41.000Z" itemprop="datePublished">2020-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a><strong>代理模式(Proxy)</strong></h2><p>代理模式的基本介绍</p>
<p>1) 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。<br>2) 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象<br>3) 代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代理)和 Cglib代理 (可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴)<br>4) 代理模式示意图<br><img src="/images/221.png" alt=""></p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h2><h3 id="静态代码模式的基本介绍"><a href="#静态代码模式的基本介绍" class="headerlink" title="静态代码模式的基本介绍"></a><strong>静态代码模式的基本介绍</strong></h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类 应用实例</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a><strong>应用实例</strong></h3><p><strong>具体要求</strong></p>
<p>1) 定义一个接口:ITeacherDao<br>2) 目标对象TeacherDAO实现接口ITeacherDAO<br>3) 使用静态代理方式,就需要在代理对象TeacherDAOProxy中也实现ITeacherDAO<br>4) 调用的时候通过调用代理对象的方法来调用目标对象.<br>5) 特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法。<br><img src="/images/222.png" alt=""></p>
<p><strong>接口</strong></p>
<pre><code>public interface ITeacherDao {    
    void teach(); // 授课的方法
}</code></pre><p><strong>目标对象</strong></p>
<pre><code>public class TeacherDao implements ITeacherDao {
    @Override
    public void teach() {
        // TODO Auto-generated method stub
        System.out.println(&quot; 老师授课中  。。。。。&quot;);
    }
}</code></pre><p><strong>代理对象,静态代理</strong></p>
<pre><code>public class TeacherDaoProxy implements ITeacherDao{    
    private ITeacherDao target; // 目标对象，通过接口来聚合    
    //构造器
    public TeacherDaoProxy(ITeacherDao target) {
        this.target = target;
    }
    @Override
    public void teach() {
        // TODO Auto-generated method stub
        System.out.println(&quot;开始代理  完成某些操作。。。。。 &quot;);//方法
        target.teach();
        System.out.println(&quot;提交。。。。。&quot;);//方法
    }
}</code></pre><p><strong>客户端</strong></p>
<pre><code>public class Client {
    public static void main(String[] args) {
        //创建目标对象(被代理对象)
        TeacherDao teacherDao = new TeacherDao();        
        //创建代理对象, 同时将被代理对象传递给代理对象
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);        
        //通过代理对象，调用到被代理对象的方法
        //即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 
        teacherDaoProxy.teach();
    }
}</code></pre><p><strong>结果</strong></p>
<pre><code>开始代理  完成某些操作。。。。。 
 老师授课中  。。。。。
提交。。。。。</code></pre><p>静态代理优缺点</p>
<p>1) 优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展<br>2) 缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类<br>3) 一旦接口增加方法,目标对象与代理对象都要维护</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><strong>动态代理</strong></h2><p><strong>动态代理模式的基本介绍</strong></p>
<p>1) 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理<br>2) 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象<br>3) 动态代理也叫做：JDK代理、接口代理<br><strong>JDK中生成代理对象的API</strong></p>
<p>1) 代理类所在包:java.lang.reflect.Proxy<br>2) JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:<br>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理应用实例<br><strong>应用实例要求</strong><br>将前面的静态代理改进成动态代理模式(即：JDK代理模式)<br><strong>思路图解(类图)</strong></p>
<p><strong>代码实现</strong></p>
<p><strong>接口</strong></p>
<pre><code>public interface ITeacherDao {
    void teach(); // 授课方法
    void sayHello(String name);
}</code></pre><p><strong>目标对象</strong></p>
<pre><code>public class TeacherDao implements ITeacherDao {
    @Override
    public void teach() {
        // TODO Auto-generated method stub
        System.out.println(&quot; 老师授课中.... &quot;);
    }
    @Override
    public void sayHello(String name) {
        // TODO Auto-generated method stub
        System.out.println(&quot;hello &quot; + name);
    }    
}</code></pre><p><strong>代理对象,动态代理</strong></p>
<pre><code>public class ProxyFactory {
    //维护一个目标对象 , Object
    private Object target;
    //构造器 ， 对target 进行初始化
    public ProxyFactory(Object target) {        
        this.target = target;
    }     
    //给目标对象 生成一个代理对象
    public Object getProxyInstance() {        
        //说明
        /*
         *  public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)                                        
            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定
            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型
            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入
         */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                new InvocationHandler() {                    
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(&quot;JDK代理开始~~&quot;);
                        //反射机制调用目标对象的方法
                        Object returnVal = method.invoke(target, args);
                        System.out.println(&quot;JDK代理提交&quot;);
                        return returnVal;
                    }
                }); 
    }        
}</code></pre><p><strong>客户端</strong></p>
<pre><code>public class Client {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //创建目标对象
        ITeacherDao target = new TeacherDao();        
        //给目标对象，创建代理对象, 可以转成 ITeacherDao
        ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();    
        // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象
        System.out.println(&quot;proxyInstance=&quot; + proxyInstance.getClass());        
        //通过代理对象，调用目标对象的方法
        proxyInstance.teach();        
        proxyInstance.sayHello(&quot; tom &quot;);
    }
}</code></pre><p><strong>结果</strong></p>
<pre><code>JDK代理开始~~
 老师授课中.... 
JDK代理提交
JDK代理开始~~
hello  tom 
JDK代理提交</code></pre><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理模式的基本介绍</p>
<p>1) 静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现代理-这就是Cglib代理<br>2) Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。<br>3) Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截<br>4) 在AOP编程中如何选择代理模式：</p>
<ol>
<li>目标对象需要实现接口，用JDK代理</li>
<li>目标对象不需要实现接口，用Cglib代理<br>5) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</li>
</ol>
<h3 id="Cglib代理-1"><a href="#Cglib代理-1" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理模式实现步骤</p>
<p>1) 需要引入cglib的jar文件<br>2) 在内存中动态构建子类，注意代理的类不能为final，否则报错java.lang.IllegalArgumentException:<br>3) 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</p>
<h3 id="Cglib代理-2"><a href="#Cglib代理-2" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理模式应用实例<br><strong>应用实例要求</strong><br>将前面的案例用Cglib代理模式实现<br><strong>思路图解(类图)</strong><br><img src="/images/224.png" alt=""><br><strong>代码实现</strong></p>
<pre><code>public class TeacherDao {
    public String teach() {
        System.out.println(&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;);
        return &quot;hello&quot;;
    }
}
public class ProxyFactory implements MethodInterceptor {
    //维护一个目标对象
    private Object target;    
    //构造器，传入一个被代理的对象
    public ProxyFactory(Object target) {
        this.target = target;
    }
    //返回一个代理对象:  是 target 对象的代理对象
    public Object getProxyInstance() {
        //1. 创建一个工具类
        Enhancer enhancer = new Enhancer();
        //2. 设置父类
        enhancer.setSuperclass(target.getClass());
        //3. 设置回调函数
        enhancer.setCallback(this);
        //4. 创建子类对象，即代理对象
        return enhancer.create();        
    }    
    //重写  intercept 方法，会调用目标对象的方法
    @Override
    public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {
        // TODO Auto-generated method stub
        System.out.println(&quot;Cglib代理模式 ~~ 开始&quot;);
        Object returnVal = method.invoke(target, args);
        System.out.println(&quot;Cglib代理模式 ~~ 提交&quot;);
        return returnVal;
    }
}
public class Client {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //创建目标对象
        TeacherDao target = new TeacherDao();
        //获取到代理对象，并且将目标对象传递给代理对象
        TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();
        //执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用
        String res = proxyInstance.teach();
        System.out.println(&quot;res=&quot; + res);
    }
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugt00d6zwu81tjofh7t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/装饰者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-18T02:22:41.000Z" itemprop="datePublished">2020-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">装饰者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="星巴克咖啡订单项目"><a href="#星巴克咖啡订单项目" class="headerlink" title="星巴克咖啡订单项目"></a><strong>星巴克咖啡订单项目</strong></h2><p><strong>星巴克咖啡订单项目（咖啡馆）：</strong></p>
<p>1) 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)<br>2) 调料：Milk、Soy(豆浆)、Chocolate<br>3) 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便<br>4) 使用OO的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</p>
<h3 id="方案1-较差的方案"><a href="#方案1-较差的方案" class="headerlink" title="方案1-较差的方案"></a><strong>方案1-较差的方案</strong></h3><p><img src="/images/215.png" alt=""></p>
<p>1) Drink 是一个抽象类，表示饮料<br>2) des就是对咖啡的描述, 比如咖啡的名字<br>3) cost() 方法就是计算费用，Drink 类中做成一个抽象方法.<br>4) Decaf 就是单品咖啡， 继承Drink, 并实现cost<br>5) Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多<br>6) 问题：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸</p>
<h3 id="方案2-好点"><a href="#方案2-好点" class="headerlink" title="方案2(好点)"></a><strong>方案2(好点)</strong></h3><p>前面分析到方案1因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink类，这样就不会造成类数量过多。从而提高项目的维护性(如图)<br>说明: milk,soy,chocolate 可以设计为Boolean,表示是否要添加相应的调料.<br><img src="/images/216.png" alt=""></p>
<p><strong>方案2-的问题分析</strong></p>
<p>1) 方案2可以控制类的数量，不至于造成很多的类<br>2) 在增加或者删除调料种类时，代码的维护量很大<br>3) 考虑到用户可以添加多份相同调料时，可以将hasMilk 返回一个对应int<br>4) 考虑使用 装饰者 模式</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a><strong>装饰者模式</strong></h3><p>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p>
<p><strong>装饰者模式(Decorator)原理</strong></p>
<p>1) 装饰者模式就像打包一个快递 </p>
<ul>
<li>主体：比如：陶瓷、衣服 (Component) // 被装饰者</li>
<li>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</li>
</ul>
<p>2) </p>
<ul>
<li>Component主体：比如类似前面的Drink</li>
<li>ConcreteComponent：具体的主体，比如前面的各个单品咖啡</li>
<li>Decorator: 装饰者，比如各调料.</li>
</ul>
<p>3) Component与ConcreteComponent之间，如果ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象成一个类。</p>
<p><strong>用装饰者模式设计的方案</strong><br><img src="/images/218.png" alt=""><br><strong>1)  Drink 类就是前面说的抽象类， Component</strong></p>
<pre><code>public abstract class Drink {
    public String des; // 描述
    private float price = 0.0f;
    public String getDes() {
        return des;
    }
    public void setDes(String des) {
        this.des = des;
    }
    public float getPrice() {
        return price;
    }
    public void setPrice(float price) {
        this.price = price;
    }    
    //计算费用的抽象方法
    //子类来实现
    public abstract float cost();    
}</code></pre><p><strong>2) 具体的主体，咖啡</strong></p>
<pre><code>//咖啡缓冲层，提取公共部分
public class Coffee  extends Drink {
    @Override
    public float cost() {
        // TODO Auto-generated method stub
        return super.getPrice();
    }    
}
public class ShortBlack extends Coffee{    
    public ShortBlack() {
        setDes(&quot; shortblack &quot;);
        setPrice(4.0f);
    }
}
public class LongBlack extends Coffee {
    public LongBlack() {
        setDes(&quot; longblack &quot;);
        setPrice(5.0f);
    }
}
public class Espresso extends Coffee {    
    public Espresso() {
        setDes(&quot; 意大利咖啡 &quot;);
        setPrice(6.0f);
    }
}
public class DeCaf extends Coffee {
    public DeCaf() {
        setDes(&quot; 无因咖啡 &quot;);
        setPrice(1.0f);
    }
}</code></pre><p><strong>3) 装饰者，调料</strong><br><strong>装饰者类，继承(多态原理,利用调料子类创建Drink父类)   加组合    (与未加本调料前的Drink组合)</strong><br><strong>之后将二者的价格和描述进行合并，形成崭新的Drink类(本质上还是刚创建那个，只不过修改了其内部方法)</strong></p>
<pre><code>public class Decorator extends Drink {
    private Drink obj;    
    public Decorator(Drink obj) { //组合
        // TODO Auto-generated constructor stub
        this.obj = obj;
    }    
    @Override
    public float cost() {
        // TODO Auto-generated method stub
        // getPrice 自己价格
        return super.getPrice() + obj.cost();
    }    
    @Override
    public String getDes() {
        // TODO Auto-generated method stub
        // obj.getDes() 输出被装饰者的信息
        return des + &quot; &quot; + getPrice() + &quot; &amp;&amp; &quot; + obj.getDes();
    }
}
public class Chocolate extends Decorator {
    public Chocolate(Drink obj) {
        super(obj);
        setDes(&quot; 巧克力 &quot;);
        setPrice(3.0f); // 调味品 的价格
    }
}
public class Soy extends Decorator{
    public Soy(Drink obj) {
        super(obj);
        // TODO Auto-generated constructor stub
        setDes(&quot; 豆浆  &quot;);
        setPrice(1.5f);
    }
}
public class Milk extends Decorator {
    public Milk(Drink obj) {
        super(obj);
        // TODO Auto-generated constructor stub
        setDes(&quot; 牛奶 &quot;);
        setPrice(2.0f); 
    }
}</code></pre><p><strong>4) 咖啡厅</strong></p>
<pre><code>public class CoffeeBar {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack
        // 1. 点一份 LongBlack
        Drink order = new LongBlack();
        System.out.println(&quot;费用1=&quot; + order.cost());
        System.out.println(&quot;描述=&quot; + order.getDes());
        // 2. order 加入一份牛奶
        order = new Milk(order);
        System.out.println(&quot;order 加入一份牛奶 费用 =&quot; + order.cost());
        System.out.println(&quot;order 加入一份牛奶 描述 = &quot; + order.getDes());
        // 3. order 加入一份巧克力
        order = new Chocolate(order);
        System.out.println(&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot; + order.cost());
        System.out.println(&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot; + order.getDes());
        // 3. order 加入一份巧克力
        order = new Chocolate(order);
        System.out.println(&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot; + order.cost());
        System.out.println(&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot; + order.getDes());    
        System.out.println(&quot;===========================&quot;);        
        Drink order2 = new DeCaf();        
        System.out.println(&quot;order2 无因咖啡  费用 =&quot; + order2.cost());
        System.out.println(&quot;order2 无因咖啡 描述 = &quot; + order2.getDes());        
        order2 = new Milk(order2);        
        System.out.println(&quot;order2 无因咖啡 加入一份牛奶  费用 =&quot; + order2.cost());
        System.out.println(&quot;order2 无因咖啡 加入一份牛奶 描述 = &quot; + order2.getDes());    
    }
}</code></pre><p><strong>装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</strong><br><img src="/images/219.png" alt=""><br><strong>说明</strong></p>
<p>1) Milk包含了LongBlack<br>2) 一份Chocolate包含了(Milk+LongBlack)<br>3) 一份Chocolate包含了(Chocolate+Milk+LongBlack)<br>4) 这样不管是什么形式的单品咖啡+调料组合，通过递归方式可以方便的组合和维护。</p>
<p><strong>结论</strong><br>可以看出装饰者模式的原理就是，将coffee类不断的包装包装，而结果还是Drink所以不管怎样包装都可以进行下去。</p>
<h2 id="装饰者模式在JDK应用的源码分析"><a href="#装饰者模式在JDK应用的源码分析" class="headerlink" title="装饰者模式在JDK应用的源码分析"></a><strong>装饰者模式在JDK应用的源码分析</strong></h2><p>Java的IO结构，FilterInputStream就是一个装饰者<br><img src="/images/220.png" alt=""></p>
<pre><code>public abstract class InputStream implements Closeable{} //是一个抽象类，即Component
public class FilterInputStream extends InputStream { 
    //是一个装饰者类Decorator
    protected volatile InputStream in //被装饰的对象 
}
class DataInputStream extends FilterInputStream implements DataInput { 
    //FilterInputStream 子类
    public DataInputStream(InputStream in) {
        super(in);
    }
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugv00dfzwu8g06wfmdb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/适配器模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-16T13:54:14.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><strong>适配器模式</strong></h2><h3 id="适配器模式基本介绍"><a href="#适配器模式基本介绍" class="headerlink" title="适配器模式基本介绍"></a><strong>适配器模式基本介绍</strong></h3><p>1) 适配器模式(Adapter Pattern)又叫变压器模式，或者包装模式，将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)<br>2) 适配器模式属于结构型模式<br>3) 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a><strong>组件</strong></h2><p><strong>Target(目标抽象类)</strong>：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
<p><strong>Adapter(适配器类)</strong>：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p>
<p><strong>Adaptee(适配者类)</strong>：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</p>
<h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a><strong>类适配器</strong></h2><p><img src="/images/213.png" alt=""><br><strong>首先有一个已存在的将被适配的类</strong></p>
<pre><code>public class Adaptee {
    public void adapteeRequest() {
        System.out.println(&quot;被适配者的方法&quot;);
    }
}</code></pre><p><strong>定义一个目标接口</strong></p>
<pre><code>public interface Target {
    void request();
}</code></pre><p><strong>怎么才可以在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法呢？<br>如果直接实现 Target 是不行的</strong></p>
<pre><code>public class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println(&quot;concreteTarget目标方法&quot;);
    }
}</code></pre><p><strong>如果通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() 即可实现</strong></p>
<pre><code>public class Adapter extends Adaptee implements Target{
    @Override
    public void request() {
        //...一些操作...
        super.adapteeRequest();
        //...一些操作...
    }
}</code></pre><p><strong>测试</strong></p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();
        Target adapterTarget = new Adapter();
        adapterTarget.request();
    }
}</code></pre><p><strong>输出</strong></p>
<pre><code>concreteTarget目标方法
被适配者的方法</code></pre><p><strong>这样我们即可在新接口 Target 中适配旧的接口或类</strong></p>
<h3 id="类适配器模式注意事项和细节"><a href="#类适配器模式注意事项和细节" class="headerlink" title="类适配器模式注意事项和细节"></a><strong>类适配器模式注意事项和细节</strong></h3><p>1) Java是单继承机制，所以类适配器需要继承Adaptee类这一点算是一个缺点, 因为这要求Target必须是接口，有一定局限性;<br>2) Adaptee类的方法在Adapter中都会暴露出来，也增加了使用的成本。<br>3) 由于其继承了Adaptee类，所以它可以根据需求重写Adaptee类的方法，使得Adapter的灵活性增强了。</p>
<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a><strong>对象适配器</strong></h2><p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 Adapter 类即可将转变为对象适配器<br><img src="/images/214.png" alt=""></p>
<pre><code>public class Adapter implements Target{
    // 适配者是对象适配器的一个属性
    private Adaptee adaptee = new Adaptee();
    @Override
    public void request() {
        //...
        adaptee.adapteeRequest();
        //...
    }
}</code></pre><p>注意这里的 Adapter 是将 Adaptee 作为一个成员属性，而不是继承它</p>
<h3 id="对象适配器模式注意事项和细节"><a href="#对象适配器模式注意事项和细节" class="headerlink" title="对象适配器模式注意事项和细节"></a><strong>对象适配器模式注意事项和细节</strong></h3><p>1) 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承Adaptee的局限性问题，也不再要求Target必须是接口。<br>2) 使用成本更低，更灵活。</p>
<h3 id="接口适配器-也称为缺省适配器模式"><a href="#接口适配器-也称为缺省适配器模式" class="headerlink" title="接口适配器,也称为缺省适配器模式"></a><strong>接口适配器,也称为缺省适配器模式</strong></h3><p>1) 一些书籍称为：接口适配器模式(Default Adapter Pattern)或缺省适配器模式。<br>2) 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求<br>3) 适用于一个接口不想使用其所有的方法的情况。</p>
<p><strong>例如有如下接口：</strong></p>
<pre><code>public interface MobilePhoneBrand {
    String xiaomi();
    String huawei();
    String apple();
    String vivo();
    String oppo();
    String samsung();
}</code></pre><p><strong>对应的抽象类如下：</strong><br>这里抽象类默认实现所有接口方法，那为什么还要用抽象类呢？原因是不想别人new该类直接使用，而是希望对默认实现的方法有进一步实现。</p>
<pre><code>public abstract class MobilePhoneDefault implements MobilePhoneBrand{
    public String xiaomi(){
        return null;
    }
    public String huawei(){
        return null;
    }
    public String apple(){
        return null;
    }
    public String vivo(){
        return null;
    }
    public String oppo(){
        return null;
    }
    public String samsung(){
        return null;
    }
}</code></pre><p><strong>实现类中我只想使用中国品牌的手机，所以只需实现部分方法就可以了。</strong></p>
<pre><code>public class ChinaMobilePhone extends MobilePhoneDefault {
    public String xiaomi(){
        return &quot;小米&quot;;
    }
    public String huawei(){
        return &quot;华为&quot;;
    }
    public String vivo(){
        return &quot;VIVO&quot;;
    }
    public String oppo(){
        return &quot;OPPO&quot;;
    }
}</code></pre><h2 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a><strong>适配器模式总结</strong></h2><p><strong>主要优点：</strong></p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<p><strong>适配器模式的注意事项和细节</strong></p>
<ul>
<li>三种命名方式，是根据 Adaptee是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。<ul>
<li>类适配器：以类给到，在Adapter里，就是将Adaptee当做类，继承</li>
<li>对象适配器：以对象给到，在Adapter里，将Adaptee作为一个对象，持有</li>
<li>接口适配器：以接口给到，在Adapter里，将Adaptee作为一个接口，实现</li>
</ul>
</li>
<li>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li>
<li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li>
</ul>
<h3 id="适配器模式在SpringMVC框架应用的源码分析"><a href="#适配器模式在SpringMVC框架应用的源码分析" class="headerlink" title="适配器模式在SpringMVC框架应用的源码分析"></a><strong>适配器模式在SpringMVC框架应用的源码分析</strong></h3><p>1) SpringMvc中的HandlerAdapter, 就使用了适配器模式<br>2) SpringMVC处理请求的流程回顾<br>3) 使用HandlerAdapter的原因分析:可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。<br>4) 动手写SpringMVC通过适配器设计模式获取到对应的Controller的源码<br><strong>说明：</strong></p>
<ul>
<li>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类 </li>
<li>适配器代替controller执行相应的方法 </li>
<li>扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugz00dvzwu8ap542y6a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java基础/深浅拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/16/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time datetime="2020-04-16T09:23:12.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">深浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浅复制与深复制概念"><a href="#浅复制与深复制概念" class="headerlink" title="浅复制与深复制概念"></a><strong>浅复制与深复制概念</strong></h2><p>1.浅复制（浅克隆）<br>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>2.深复制（深克隆）<br>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<h2 id="Java的clone-方法"><a href="#Java的clone-方法" class="headerlink" title="Java的clone()方法"></a><strong>Java的clone()方法</strong></h2><p>1.clone方法将对象复制了一份并返回给调用者。一般而言，clone（）方法满足：</p>
<ul>
<li>对任何的对象x，都有x.clone() !=x//克隆对象与原对象不是同一个对象</li>
<li>对任何的对象x，都有x.clone().getClass()= =x.getClass()//克隆对象与原对象的类型一样</li>
<li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li>
</ul>
<p>2.Java中对象的克隆</p>
<ul>
<li>为了获取对象的一份拷贝，我们可以利用Object类的clone()方法。</li>
<li>在派生类中覆盖基类的clone()方法，并声明为public。</li>
<li>在派生类的clone()方法中，调用super.clone()。</li>
<li>在派生类中实现Cloneable接口。</li>
</ul>
<p><strong>请看如下代码：</strong></p>
<pre><code>class Student implements Cloneable   
{   
     String name;   
    int age;   
     Student(String name,int age)   
     {   
        this.name=name;   
        this.age=age;   
     }   
    public Object clone()   
     {   
         Object o=null;   
        try   
         {   
         o=(Student)super.clone();//Object 中的clone()识别出你要复制的是哪一个对象。   
         }   
        catch(CloneNotSupportedException e)   
         {   
             System.out.println(e.toString());   
         }   
        return o;   
     }   
}   

public static void main(String[] args)   
{   
   Student s1=new Student(&quot;zhangsan&quot;,18);   
   Student s2=(Student)s1.clone();   
   s2.name=&quot;lisi&quot;;   
   s2.age=20;   
   System.out.println(&quot;name=&quot;+s1.name+&quot;,&quot;+&quot;age=&quot;+s1.age);//修改学生2后，不影响学生1的值。   
}   </code></pre><p><strong>说明：</strong></p>
<ul>
<li><p>为什么我们在派生类中覆盖Object的clone()方法时，一定要调用super.clone()呢？在运行时刻，Object中的clone()识别出你要复制的是哪一个对象，然后为此对象分配空间，并进行对象的复制，将原始对象的内容一一复制到新对象的存储空间中。</p>
</li>
<li><p>继承自java.lang.Object类的clone()方法是浅复制。以下代码可以证明之。</p>
<pre><code>class Professor {
    String name;
    int age;
    Professor(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
class Student implements Cloneable {
    String name;// 常量对象。   
    int age;
    Professor p;// 学生1和学生2的引用值都是一样的。   
    Student(String name, int age, Professor p) {
        this.name = name;
        this.age = age;
        this.p = p;
    }
    public Object clone() {
        Student o = null;
        try {
            o = (Student) super.clone();
        } catch (CloneNotSupportedException e) {
            System.out.println(e.toString());
        }
        return o;
    }
}
public static void main(String[] args) {
    Professor p = new Professor(&quot;wangwu&quot;, 50);
    Student s1 = new Student(&quot;zhangsan&quot;, 18, p);
    Student s2 = (Student) s1.clone();
    s2.p.name = &quot;lisi&quot;;
    s2.p.age = 30;
    System.out.println(&quot;name=&quot; + s1.p.name + &quot;,&quot; + &quot;age=&quot; + s1.p.age);//学生1的教授成为lisi,age为30。   
} </code></pre></li>
</ul>
<p><strong>那应该如何实现深层次的克隆，即修改s2的教授不会影响s1的教授？代码改进如下。</strong><br>改进使学生1的Professor不改变（深层次的克隆）</p>
<pre><code>class Professor implements Cloneable   
{   
     String name;   
     int age;   
     Professor(String name,int age)   
     {   
        this.name=name;   
        this.age=age;   
     }   
    public Object clone()   
     {   
         Object o=null;   
        try   
         {   
             o=super.clone();   
         }   
        catch(CloneNotSupportedException e)   
         {   
             System.out.println(e.toString());   
         }   
        return o;   
     }   
}   
class Student implements Cloneable   
{   
     String name;   
     int age;   
     Professor p;   
     Student(String name,int age,Professor p)   
     {   
        this.name=name;   
        this.age=age;   
        this.p=p;   
     }   
    public Object clone()   
     {   
         Student o=null;   
        try   
         {   
             o=(Student)super.clone();   
         }   
        catch(CloneNotSupportedException e)   
         {   
             System.out.println(e.toString());   
         }   
         o.p=(Professor)p.clone();   
        return o;   
     }   
}   
public static void main(String[] args)   
     {   
       Professor p=new Professor(&quot;wangwu&quot;,50);   
       Student s1=new Student(&quot;zhangsan&quot;,18,p);   
       Student s2=(Student)s1.clone();   
       s2.p.name=&quot;lisi&quot;;   
       s2.p.age=30;   
System.out.println(&quot;name=&quot;+s1.p.name+&quot;,&quot;+&quot;age=&quot;+s1.p.age);//学生1的教授不 改变。   
}   </code></pre><h2 id="利用串行化来做深复制"><a href="#利用串行化来做深复制" class="headerlink" title="利用串行化来做深复制"></a><strong>利用串行化来做深复制</strong></h2><p>把对象写到流里的过程是串行化（Serilization）过程，但是在Java程序师圈子里又非常形象地称为“冷冻”或者“腌咸菜（picking）”过程；而把对象从流中读出来的并行化（Deserialization）过程则叫做 “解冻”或者“回鲜(depicking)”过程。</p>
<p>应当指出的是，写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面，因此“腌成咸菜”的只是对象的一个拷贝，Java咸菜还可以回鲜。<br>在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里（腌成咸菜），再从流里读出来（把咸菜回鲜），便可以重建对象。<br><strong>如下为深复制源代码。</strong></p>
<pre><code>public Object deepClone()   
{   
//将对象写到流里   
ByteArrayOutoutStream bo=new ByteArrayOutputStream();   
ObjectOutputStream oo=new ObjectOutputStream(bo);   
oo.writeObject(this);   
//从流里读出来   
ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());   
ObjectInputStream oi=new ObjectInputStream(bi);   
return(oi.readObject());   
}   </code></pre><p>这样做的前提是对象以及对象内部所有引用到的对象都是可串行化的，否则，就需要仔细考察那些不可串行化的对象可否设成transient，从而将之排除在复制过程之外。上例代码改进如下。</p>
<pre><code>class Teacher implements Serializable {
    String name;
    int age;
    Teacher(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
class Student implements Serializable {
    String name;//常量对象
    int age;
    Teacher t;//学生1和学生2的引用值都是一样的。
    Student(String name, int age, Teacher t) {
        this.name = name;
        this.age = age;
        this.p = p;
    }
    public Object deepClone() throws IOException, OptionalDataException, ClassNotFoundException {//将对象写到流里
        ByteArrayOutoutStream bo = new ByteArrayOutputStream();
        ObjectOutputStream oo = new ObjectOutputStream(bo);
        oo.writeObject(this);//从流里读出来
        ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
        ObjectInputStream oi = new ObjectInputStream(bi);
        return (oi.readObject());
    }
}
public static void main(String[] args) {
    Teacher t = new Teacher(&quot;tangliang&quot;, 30);
    Student s1 = new Student(&quot;zhangsan&quot;, 18, t);
    Student s2 = (Student) s1.deepClone();
    s2.t.name = &quot;tony&quot;;
    s2.t.age = 40;
    System.out.println(&quot;name=&quot; + s1.t.name + &quot;,&quot; + &quot;age=&quot; + s1.t.age);//学生1的老师不改变
}</code></pre><h2 id="用fastjson从Object转成json，然后转回object，本质上是反射："><a href="#用fastjson从Object转成json，然后转回object，本质上是反射：" class="headerlink" title="用fastjson从Object转成json，然后转回object，本质上是反射："></a><strong>用fastjson从Object转成json，然后转回object，本质上是反射：</strong></h2><pre><code>private Object deepCopyByJson(Object obj) {
    String json = JSON.toJSONString(obj);
    return JSON.parseObject(json, Object.class);
}</code></pre><h2 id="关于能否彻底深拷贝这里有一篇文章"><a href="#关于能否彻底深拷贝这里有一篇文章" class="headerlink" title="关于能否彻底深拷贝这里有一篇文章"></a><strong>关于能否彻底深拷贝这里有一篇文章</strong></h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484930&amp;idx=1&amp;sn=68bcd988c1658377e288a26a8effa17d&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484930&amp;idx=1&amp;sn=68bcd988c1658377e288a26a8effa17d&amp;source=41#wechat_redirect</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/16/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="ckb22iuea003rzwu8gbia0i12" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-16T02:51:41.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>注：以下部分内容摘自其他博客：<a href="https://www.cnblogs.com/yssjun/p/11102162.html" target="_blank" rel="noopener">https://www.cnblogs.com/yssjun/p/11102162.html</a></strong></p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><strong>简单工厂模式</strong></h2><p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：<br><img src="/images/208.png" alt=""><br>下面我们使用手机生产来讲解该模式：<br><strong>Phone类：手机标准规范类(AbstractProduct)</strong></p>
<pre><code>public interface Phone {
    void make();
}</code></pre><p><strong>MiPhone类：制造小米手机（Product1）</strong></p>
<pre><code>public class MiPhone implements Phone {
    public MiPhone() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make xiaomi phone!&quot;);
    }
}</code></pre><p><strong>IPhone类：制造苹果手机（Product2）</strong></p>
<pre><code>public class IPhone implements Phone {
    public IPhone() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make iphone!&quot;);
    }
}</code></pre><p><strong>PhoneFactory类：手机代工厂（Factory）</strong></p>
<pre><code>public class PhoneFactory {
    public Phone makePhone(String phoneType) {
        if(phoneType.equalsIgnoreCase(&quot;MiPhone&quot;)){
            return new MiPhone();
        }
        else if(phoneType.equalsIgnoreCase(&quot;iPhone&quot;)) {
            return new IPhone();
        }
        return null;
    }
}</code></pre><p><strong>演示：</strong></p>
<pre><code>public class Demo {
    public static void main(String[] arg) {
        PhoneFactory factory = new PhoneFactory();
        Phone miPhone = factory.makePhone(&quot;MiPhone&quot;);            // make xiaomi phone!
        IPhone iPhone = (IPhone)factory.makePhone(&quot;iPhone&quot;);    // make iphone!
    }
}</code></pre><h2 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a><strong>工厂方法模式(Factory Method)</strong></h2><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：<br><img src="/images/209.png" alt=""><br>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。<br>接下来继续使用生产手机的例子来讲解该模式。<br>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。<br><strong>AbstractFactory类：生产不同产品的工厂的抽象类</strong></p>
<pre><code>public interface AbstractFactory {
    Phone makePhone();
}</code></pre><p><strong>XiaoMiFactory类：生产小米手机的工厂（ConcreteFactory1</strong></p>
<pre><code>public class XiaoMiFactory implements AbstractFactory{
    @Override
    public Phone makePhone() {
        return new MiPhone();
    }
}</code></pre><p><strong>AppleFactory类：生产苹果手机的工厂（ConcreteFactory2）</strong></p>
<pre><code>public class AppleFactory implements AbstractFactory {
    @Override
    public Phone makePhone() {
        return new IPhone();
    }
}</code></pre><p><strong>演示：</strong></p>
<pre><code>public class Demo {
    public static void main(String[] arg) {
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        appleFactory.makePhone();        // make iphone!
    }
}</code></pre><h2 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a><strong>抽象工厂模式(Abstract Factory)</strong></h2><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品Phone（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p>
<p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p>
<p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p>
<p>其UML类图如下：<br><img src="/images/210.png" alt=""></p>
<p>从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。</p>
<p>接下来我们继续通过小米和苹果产品生产的例子来解释该模式。</p>
<p>为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：<br><img src="/images/211.png" alt=""></p>
<p><strong>PC类：定义PC产品的接口(AbstractPC)</strong></p>
<pre><code>public interface PC {
    void make();
}</code></pre><p><strong>MiPC类：定义小米电脑产品(MIPC)</strong></p>
<pre><code>public class MiPC implements PC {
    public MiPC() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make xiaomi PC!&quot;);
    }
}</code></pre><p><strong>MAC类：定义苹果电脑产品(MAC)</strong></p>
<pre><code>public class MAC implements PC {
    public MAC() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println(&quot;make MAC!&quot;);
    }
}</code></pre><p>下面需要修改工厂相关的类的定义：</p>
<p><strong>AbstractFactory类：增加PC产品制造接口</strong></p>
<pre><code>public interface AbstractFactory {
    Phone makePhone();
    PC makePC();
}</code></pre><p><strong>XiaoMiFactory类：增加小米PC的制造（ConcreteFactory1</strong>）</p>
<pre><code>public class XiaoMiFactory implements AbstractFactory{
    @Override
    public Phone makePhone() {
        return new MiPhone();
    }
    @Override
    public PC makePC() {
        return new MiPC();
    }
}</code></pre><p><strong>AppleFactory类：增加苹果PC的制造（ConcreteFactory2）</strong></p>
<pre><code>public class AppleFactory implements AbstractFactory {
    @Override
    public Phone makePhone() {
        return new IPhone();
    }
    @Override
    public PC makePC() {
        return new MAC();
    }
}</code></pre><p><strong>演示：</strong></p>
<pre><code>public class Demo {
    public static void main(String[] arg) {
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        miFactory.makePC();                // make xiaomi PC!
        appleFactory.makePhone();        // make iphone!
        appleFactory.makePC();            // make MAC!
    }
}</code></pre><p><strong>总结：</strong><br>上面介绍的三种工厂模式有各自的应用场景，实际应用时能解决问题满足需求即可，可灵活变通，无所谓高级与低级。<br>此外无论哪种模式，由于可能封装了大量对象和工厂创建，新加产品需要修改已定义好的工厂相关的类，因此对于产品和工厂的扩展不太友好，利弊需要权衡一下。</p>
<h3 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a><strong>工厂模式小结</strong></h3><p>1) 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。<br>2) 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)<br>3) 设计模式的依赖抽象原则</p>
<ul>
<li>创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li>
<li>不要让类继承具体类，而是继承抽象类或者是实现interface(接口)</li>
<li>不要覆盖基类中已经实现的方法。</li>
</ul>
<h3 id="工厂模式源码分析"><a href="#工厂模式源码分析" class="headerlink" title="工厂模式源码分析"></a>工厂模式源码分析</h3><p>工厂模式在JDK-Calendar 应用的源码分析</p>
<p><strong>Calendar源码</strong><br>可以看出来，利用的简单工厂模式，根据不同的情况，创建不同的实例对象并返回</p>
<pre><code>public static Calendar getInstance()
{
    return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));
}
private static Calendar createCalendar(TimeZone zone,
                                       Locale aLocale)
{
    CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                             .getCalendarProvider();
    if (provider != null) {
        try {
            return provider.getInstance(zone, aLocale);
        } catch (IllegalArgumentException iae) {
            // fall back to the default instantiation
        }
    }
    Calendar cal = null;
    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);
        if (caltype != null) {
            switch (caltype) {
            case &quot;buddhist&quot;:
            cal = new BuddhistCalendar(zone, aLocale);
                break;
            case &quot;japanese&quot;:
                cal = new JapaneseImperialCalendar(zone, aLocale);
                break;
            case &quot;gregory&quot;:
                cal = new GregorianCalendar(zone, aLocale);
                break;
            }
        }
    }
    if (cal == null) {          
        if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {
            cal = new BuddhistCalendar(zone, aLocale);
        } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;
                   &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {
            cal = new JapaneseImperialCalendar(zone, aLocale);
        } else {
            cal = new GregorianCalendar(zone, aLocale);
        }
    }
    return cal;
}</code></pre><p><strong>测试</strong></p>
<pre><code>class SimpleFactory {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        // 注意月份下标从0开始，所以取月份要+1
        System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR));
        System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1));
        System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH));
        System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY));
        System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE));
        System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND));
    }
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugu00d8zwu8hp3a36q4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-15T14:52:03.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a><strong>单例设计模式介绍</strong></h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。<br>比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。</p>
<h2 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a><strong>单例设计模式八种方式</strong></h2><p>单例模式有八种方式：</p>
<p>1) 饿汉式(静态常量)<br>2) 饿汉式（静态代码块）<br>3) 懒汉式(线程不安全)<br>4) 懒汉式(线程安全，同步方法)<br>5) 懒汉式(线程安全，同步代码块)<br>6) 双重检查<br>7) 静态内部类<br>8) 枚举</p>
<h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a><strong>饿汉式（静态常量）</strong></h3><p>饿汉式（静态常量）应用实例<br>步骤如下：</p>
<p>1) 构造器私有化 (防止 new )<br>2) 类的内部创建对象<br>3) 向外暴露一个静态的公共方法。getInstance<br>4) 代码实现</p>
<pre><code>//饿汉式(静态常量)
class Singleton {    
    //1. 构造器私有化, 外部不能new
    private Singleton() {        
    }    
    //2.本类内部创建对象实例
    private final static Singleton instance = new Singleton();    
    //3. 提供一个公有的静态方法，返回实例对象
    public static Singleton getInstance() {
        return instance;
    }    
}</code></pre><p><strong>优缺点说明：</strong></p>
<p>1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。<br>2) 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费<br>3) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果<br>4) 结论：这种单例模式可用，可能造成内存浪费</p>
<h3 id="懒汉式：双重检查"><a href="#懒汉式：双重检查" class="headerlink" title="懒汉式：双重检查"></a><strong>懒汉式：双重检查</strong></h3><p>代码演示：</p>
<pre><code>class Singleton {
    private static volatile Singleton instance;    
    private Singleton() {}    
    //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
    //同时保证了效率, 推荐使用
    public static  Singleton getInstance() {
        if(instance == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }            
        }
        return instance;
    }
}</code></pre><p><strong>应用实例</strong><br>优缺点说明：</p>
<p>1) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。<br>2) 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.<br>3) 线程安全；延迟加载；效率较高<br>4) 结论：在实际开发中，推荐使用这种单例设计模式</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类应用实例<br>代码演示：</p>
<pre><code>// 静态内部类完成， 推荐使用
class Singleton {
    private static volatile Singleton instance;
    //构造器私有化
    private Singleton() {}    
    //写一个静态内部类,该类中有一个静态属性 Singleton
    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton(); 
    }    
    //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE    
    public static synchronized Singleton getInstance() {        
        return SingletonInstance.INSTANCE;
    }
}</code></pre><p>优缺点说明：</p>
<p>1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。<br>2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。<br>3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。<br>4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高<br>5) 结论：推荐使用.</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举应用实例<br>代码演示：</p>
<pre><code>//使用枚举，可以实现单例, 推荐
enum Singleton {
    INSTANCE; //属性
    public void sayOK() {
        System.out.println(&quot;ok~&quot;);
    }
}</code></pre><p><strong>优缺点说明：</strong></p>
<p>1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。<br>2) 这种方式是Effective Java作者Josh Bloch 提倡的方式<br>3) 结论：推荐使用</p>
<h3 id="单例模式在JDK-应用的源码分析"><a href="#单例模式在JDK-应用的源码分析" class="headerlink" title="单例模式在JDK 应用的源码分析"></a><strong>单例模式在JDK 应用的源码分析</strong></h3><p>单例模式在JDK 应用的源码分析</p>
<p>1) 我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)</p>
<h3 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明*"></a><strong>单例模式注意事项和细节说明*</strong></h3><p>单例模式注意事项和细节说明</p>
<p>1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能<br>2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new<br>3) 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-id="ckb22iugs00d1zwu88h1l0l0w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式/UML类图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE/" class="article-date">
  <time datetime="2020-04-15T13:44:54.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE/">UML类图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UML基本介绍"><a href="#UML基本介绍" class="headerlink" title="UML基本介绍"></a><strong>UML基本介绍</strong></h2><p>1) UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果<br>2) UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，<br>如图:<br><img src="/images/206.png" alt=""><br>3) 使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</p>
<h2 id="UML图-画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理"><a href="#UML图-画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理" class="headerlink" title="UML图 画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理"></a><strong>UML图 画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理</strong></h2><p><strong>UML图分类：</strong></p>
<p>1) 用例图(use case)<br>2) 静态结构图：类图、对象图、包图、组件图、部署图<br>3) 动态行为图：交互图（时序图与协作图）、状态图、活动图 </p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>1) 用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。<br>2) 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合</p>
<h2 id="类图—依赖关系（Dependence）"><a href="#类图—依赖关系（Dependence）" class="headerlink" title="类图—依赖关系（Dependence）"></a><strong>类图—依赖关系（Dependence）</strong></h2><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
<p><strong>小结</strong></p>
<p>1) 类中用到了对方<br>2) 是类的成员属性<br>3) 是方法的返回类型<br>4) 是方法接收的参数类型<br>5) 方法中使用到</p>
<h2 id="类图—泛化关系-generalization）"><a href="#类图—泛化关系-generalization）" class="headerlink" title="类图—泛化关系(generalization）"></a><strong>类图—泛化关系(generalization）</strong></h2><p>泛化关系实际上就是继承关系，他是依赖关系的特例</p>
<p>小结:</p>
<p>1) 泛化关系实际上就是继承关系<br>2) 如果A类继承了B类，我们就说A和B存在泛化关系</p>
<h2 id="类图—实现关系（Implementation）"><a href="#类图—实现关系（Implementation）" class="headerlink" title="类图—实现关系（Implementation）"></a><strong>类图—实现关系（Implementation）</strong></h2><p>实现关系实际上就是A类实现B接口，他是依赖关系的特例</p>
<h2 id="类图—关联关系（Association）"><a href="#类图—关联关系（Association）" class="headerlink" title="类图—关联关系（Association）"></a><strong>类图—关联关系（Association）</strong></h2><p>关联关系实际上就是类与类之间的联系，他是依赖关系的特例<br>关联具有导航性：即双向关系或单向关系<br>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…* ”（表示至少m个）。</p>
<p><strong>单向一对一关系</strong></p>
<pre><code>public class Person {
    private IDCard card;
}
public class IDCard{}</code></pre><p><strong>双向一对一关系</strong></p>
<pre><code>public class Person {
    private IDCard card;
}
public class IDCard{
    private Person person
}</code></pre><h2 id="类图—聚合关系（Aggregation）"><a href="#类图—聚合关系（Aggregation）" class="headerlink" title="类图—聚合关系（Aggregation）"></a><strong>类图—聚合关系（Aggregation）</strong></h2><p>聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。<br>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：对应类图<br>如果我们认为Mouse,Monitor和Computer是不可分离的，则升级为组合关系</p>
<h2 id="类图—组合关系（Composition）"><a href="#类图—组合关系（Composition）" class="headerlink" title="类图—组合关系（Composition）"></a><strong>类图—组合关系（Composition</strong>）</h2><p>组合关系：也是整体与部分的关系，但是整体与部分不可以分开。<br>再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和Person 就是 组合，IDCard 和 Person 就是聚合。<br>但是如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard 和 Person 就是组合了.</p>
<pre><code>public class Person{
    private IDCard card;
    private Head head = new Head();
}
public class IDCard{}
public class Head{}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE/" data-id="ckb22iugq00cuzwu87zb81r2d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-Java虚拟机/内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/13/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-04-13T08:10:51.000Z" itemprop="datePublished">2020-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/13/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a><strong>java 内存模型</strong></h2><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。<br>关于它的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b" target="_blank" rel="noopener">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b</a><br>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障 </p>
<h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a><strong>1. 原子性</strong></h2><p>原子性在学习线程时讲过，下面来个例子简单回顾一下：<br>问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="** 问题分析**"></a>** 问题分析**</h3><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。<br>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：<br>而对应 i– 也是类似： </p>
<pre><code>getstatic i // 获取静态变量i的值 
iconst_1 // 准备常量1 
iadd // 加法 
putstatic i // 将修改后的值存入静态变量i 
getstatic i // 获取静态变量i的值 
iconst_1 // 准备常量1 
isub // 减法 
putstatic i // 将修改后的值存入静态变量i </code></pre><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：<br>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：<br>但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）</p>
<h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法"></a><strong>3.解决方法</strong></h3><p>如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。<br>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行count++ 代码。<br>这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。<br>当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入obj房间，反锁住门，执行它的count–代码。<br>注意：上例中 t1和t2线程必须用synchronized锁住同一个obj对象，如果t1锁住的是m1对象，t2锁住的是m2对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。 </p>
<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a><strong>2.可见性</strong></h2><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a><strong>退不出的循环</strong></h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：<br>为什么呢？分析一下： </p>
<ol>
<li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。 </p>
</li>
<li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高 速缓存中，减少对主存中 run 的访问，提高效率 </p>
<pre><code>static boolean run = true; 
public static void main(String[] args) throws InterruptedException { 
Thread t = new Thread(()-&gt;{ 
while(run){ 
// .... 
} 
}); 
t.start(); 
Thread.sleep(1000); 
run = false; // 线程t不会如预想的停下来 
} </code></pre></li>
<li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值 </p>
</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>volatile（易变关键字）<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存 </p>
<hr>
<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见<br><strong>不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：</strong><br>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错</p>
<pre><code>getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
putstatic run // 线程 main 修改 run 为 false， 仅此一次 
getstatic run // 线程 t 获取 run false </code></pre><p>注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于重量级操作，性能相对更低<br>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？ </p>
<h2 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a><strong>3.有序性</strong></h2><p><strong>诡异的结果</strong> </p>
<pre><code>public class ConcurrencyTest { 
    int num = 0; 
    boolean ready = false; 
        @Actor 
        public void actor1(I_Result r) { 
            if(ready) { 
            r.r1 = num + num; 
            } else { 
            r.r1 = 1; 
            } 
        }
        @Actor 
        public void actor2(I_Result r) { 
            num = 2; 
            ready = true; 
        } 
    } </code></pre><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？<br>有同学这么分析<br>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1<br>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结<br>果为1<br>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过<br>了）<br>但我告诉你，结果还有可能是 0 </p>
<p><strong>解决方法</strong><br>volatile 修饰的变量，可以禁用指令重排</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/13/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="ckb22iudm001bzwu8gyzyb0sm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>