<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://tukuai.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Tukuai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-多线程/Socket&amp;ServerSocket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Socket&ServerSocket/" class="article-date">
  <time datetime="2020-05-01T06:25:37.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Socket&ServerSocket/">Socket&amp;ServerSocket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>Java中有两种类型的TCP套接字，一种用于服务器，一种用于客户端。<br>ServerSocket类型设计成“监听器”，等待客户端连接的到来。因此，ServerSocket用于服务器。<br>Socket类用于客户端，它被设计成连接服务器套接字并且初始化协议的交换。<br><img src="/images/265.png" alt=""></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h2><p>Socket可以使客户程序与服务器程序通信<br><strong>使用Socket连接服务器的过程包含以下4个基本的步骤</strong></p>
<p>(1)创建Socket<br>(2)打开连接到Socket的输入/输出流<br>(3)按照一定协议对Socket执行读写操作<br>(4)关闭Socket</p>
<p><strong>构造函数</strong></p>
<ul>
<li>Socket()</li>
<li>Socket(InetAddress address, int port)throws UnknownHostException, IOException</li>
<li>Socket(InetAddress address, int port, InetAddress localAddress, int localPort)throws IOException</li>
<li>Socket(String host, int port)throws UnknownHostException, IOException</li>
<li>Socket(String host, int port, InetAddress localAddress, int localPort)throws IOException</li>
</ul>
<p>除去第一种不带参数的之外，其它构造函数会尝试建立与服务器的连接。如果失败会抛出IOException错误。如果成功，则返回Socket对象。<br>InetAddress是一个用于记录主机的类，其静态getHostByName(String msg)可以返回一个实例，其静态方法getLocalHost()也可以获得当前主机的IP地址，并返回一个实例。Socket(String host, int port, InetAddress localAddress, int localPort)构造函数的参数分别为目标IP、目标端口、绑定本地IP、绑定本地端口。</p>
<p><strong>Socket方法</strong></p>
<ul>
<li>getInetAddress();    　远程服务端的IP地址</li>
<li>getPort();    　　　　　远程服务端的端口</li>
<li>getLocalAddress()    　本地客户端的IP地址</li>
<li>getLocalPort()         本地客户端的端口</li>
<li>getInputStream();    　返回与调用的套接字相关联的输入流</li>
<li>getOutStream();    　　返回与调用的套接字相关联的输出流<br>值得注意的是，在这些方法里面，最重要的就是getInputStream()和getOutputStream()了。</li>
</ul>
<p><strong>Socket状态</strong></p>
<ul>
<li>isClosed();        　　　　//连接是否已关闭，若关闭，返回true；否则返回false</li>
<li>isConnect();　　　　　　//如果曾经连接过，返回true；否则返回false</li>
<li>isBound();        　　　　//如果Socket已经与本地一个端口绑定，返回true；否则返回false<br>如果要确认Socket的状态是否处于连接中，下面语句是很好的判断方式。</li>
</ul>
<p>boolean isConnection=socket.isConnected() &amp;&amp; !socket.isClosed();   //判断当前是否处于连接</p>
<p><strong>半关闭Socket</strong><br>很多时候，我们并不知道在获得的输入流里面到底读多长才结束。下面是一些比较普遍的方法：</p>
<ul>
<li>自定义标识符（譬如下面的例子，当收到“bye”字符串的时候，关闭Socket）</li>
<li>告知读取长度（有些自定义协议的，固定前几个字节表示读取的长度的）</li>
<li>读完所有数据</li>
<li>当Socket调用close的时候关闭的时候，关闭其输入输出流</li>
</ul>
<p>例：</p>
<pre><code>public class TestPort {
    public static void main(String[] args) throws IOException {
        String hostname  = &quot;www.baidu.com&quot;;
        InetAddress addr = InetAddress.getByName(hostname);
        Socket so = new Socket(addr,80);
        System.out.println(&quot;远程连接地址:&quot;+so.getInetAddress());
        System.out.println(&quot;远程连接端口:&quot;+so.getPort());
        System.out.println(&quot;本地连接地址:&quot;+so.getLocalAddress());
        System.out.println(&quot;本地连接端口:&quot;+so.getLocalPort());
        InputStream is  = so.getInputStream();
        /*
        这部分为客户端操作，需要一台远程服务器
        int c;
        while((c=is.read())!=-1){
            System.out.println(&quot;gas&quot;);
        }*/
        is.close();
        so.close();
    }
}</code></pre><p>运行结果：</p>
<pre><code>远程连接地址:www.baidu.com/14.215.177.39
远程连接端口:80
本地连接地址:/192.168.0.103
本地连接端口:55234</code></pre><h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a><strong>ServerSocket</strong></h2><p>在客户端/服务器端的通信模式中，服务器端用来监听特定端口上客户端的连接。并且可以发送信息，通过ServerSocket类实现，而客户端通过上面的Socket类实现。</p>
<p><strong>构造函数</strong></p>
<ul>
<li>ServerSocket()     创建非绑定服务器套接字。 </li>
<li>ServerSocket(int port)     创建绑定到特定端口的服务器套接字。 </li>
<li>ServerSocket(int port, int backlog)     利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。 </li>
<li>ServerSocket(int port, int backlog, InetAddress bindAddr)     使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。 </li>
</ul>
<p><strong>重要方法</strong></p>
<ul>
<li><p>Socket accept()  侦听并接受到此套接字的连接。 </p>
</li>
<li><p>void bind(SocketAddress endpoint) 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 </p>
</li>
<li><p>void bind(SocketAddress endpoint, int backlog) 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 </p>
</li>
<li><p>void close() 关闭此套接字。 </p>
</li>
<li><p>InetAddress getInetAddress() 返回此服务器套接字的本地地址。 </p>
</li>
<li><p>int getLocalPort() 返回此套接字在其上侦听的端口。 </p>
</li>
<li><p>SocketAddress getLocalSocketAddress() 返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。 </p>
</li>
<li><p>boolean isBound()  返回 ServerSocket 的绑定状态。 </p>
</li>
<li><p>boolean isClosed() 返回 ServerSocket 的关闭状态。 </p>
</li>
</ul>
<p>注意点：</p>
<ol>
<li>port：服务端要监听的端口；backlog：客户端连接请求的队列长度；bindAddr：服务端绑定IP</li>
<li>如果端口被占用或者没有权限使用某些端口会抛出BindException错误。譬如1~1023的端口需要管理员才拥有权限绑定。</li>
<li>如果设置端口为0，则系统会自动为其分配一个端口；</li>
<li>bindAddr用于绑定服务器IP，为什么会有这样的设置呢，譬如有些机器有多个网卡。</li>
<li>ServerSocket一旦绑定了监听端口，就无法更改。ServerSocket()可以实现在绑定端口前设置其他的参数。</li>
</ol>
<p>ServerSocket类可以通过getInetAddress方法返回此服务器套接字的本地地址，该方法要绑定一个本地的InetAddress，可以在构造方法 ServerSocket(int port, int backlog, InetAddress bindAddr)throws IOException 中通过参数bindAddr传递。<br>getLocalPort方法用来返回此套接字在其上侦听的接口。</p>
<p>例：返回服务器端信息</p>
<pre><code>public class GetServerIP {
    public static void main(String[] args) throws Exception{
        // TODO Auto-generated method stub
        InetAddress addr =InetAddress.getByName(&quot;localhost&quot;);
        ServerSocket se = new ServerSocket(10000,10,addr);
        System.out.println(se.getInetAddress());
        System.out.println(se.getLocalPort());    
    }
}</code></pre><p>运行结果</p>
<pre><code>localhost/127.0.0.1
10000</code></pre><p><strong>附：完整例子</strong></p>
<p>发送端 socket</p>
<pre><code>import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
public class SocketSender {
    public static void main(String[] args) {
        Socket socket = null;
        try {
            socket = new Socket(&quot;127.0.0.1&quot;, 27401);
            // 向服务端发送信息
            OutputStream outer = socket.getOutputStream();
            byte[] b = &quot;客户端：向服务端发送文字，\&quot;这是一行测试....\&quot;&quot;.getBytes();
            outer.write(b);
            outer.flush();
            System.out.println(&quot;发送完毕！&quot;);
            // 接收服务端的返回值
            InputStream inner = socket.getInputStream();
            int count = 0;
            while (count == 0) {
                count = inner.available();
            }
            byte[] recv = new byte[count];
            inner.read(recv);
            String str_recv = new String(recv);
            System.out.println(&quot;客户端：接收到服务端的文字：&quot; + str_recv);
        } catch (IOException e) {
            System.out.println(&quot;发送端出现异常&quot;);
        } finally {
            if (socket != null)
                try {
                    socket.close();
                } catch (IOException e) {
                    System.out.println(&quot;发送端 finally 出现异常&quot;);
                }
        }
    }
}</code></pre><p>接收端：方法一ServerSocket</p>
<pre><code>import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class SocketReceiver {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        try {
            serverSocket = new ServerSocket(27401);
            while (true) {
                Socket socket = serverSocket.accept();
                // 接收客户端的信息
                InputStream in = socket.getInputStream();
                int count = 0;
                while (count == 0) {
                    count = in.available();
                }
                byte[] b = new byte[count];
                in.read(b);
                String str = new String(b);
                System.out.println(str);
                // 向客户端发送确认消息
                OutputStream outer = socket.getOutputStream();
                byte[] b_out = &quot;已经收到，返回消息码200&quot;.getBytes();
                outer.write(b_out);
                outer.flush();
                // 关闭socket
                socket.close();
            }
        } catch (IOException e) {
            System.out.println(&quot;接收端出现异常&quot;);
        } finally {
            if (serverSocket != null)
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    System.out.println(&quot;接收端 finally 出现异常&quot;);
                }
        }
    }
}</code></pre><p>接收端：方法2，利用多线程，每一个发送端对应接收端的一个线程</p>
<pre><code>public class SocketReceiverWithThread {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        try {
            serverSocket = new ServerSocket(27401);
            while (true) {
                Socket socket = serverSocket.accept();
                new Thread(new Handler(socket)).start();
                //socket.close(); 注意 关闭socket不能在这里，而应该写在线程内，否则可能线程没结束就关闭了socket
            }
        } catch (IOException e) {
            System.out.println(&quot;接收端出现异常&quot;);
        } finally {
            if (serverSocket != null)
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    System.out.println(&quot;接收端 finally 出现异常&quot;);
                }
        }
    }
}
class Handler implements Runnable {
    private Socket socket;
    public Handler(Socket socket) {
        this.socket = socket;
    }
    public void run() {
        try {
            // 接收客户端的信息
            InputStream in = socket.getInputStream();
            int count = 0;
            while (count == 0) {
                count = in.available();
            }
            byte[] b = new byte[count];
            in.read(b);
            String str = new String(b);
            System.out.println(str);
            // 向客户端发送确认消息
            OutputStream outer = socket.getOutputStream();
            byte[] b_out = &quot;已经收到，返回消息码200&quot;.getBytes();
            outer.write(b_out);
            outer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭socket
            try {
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Socket&ServerSocket/" data-id="ckb22iufi007zzwu82s0hbd5g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-多线程/BIO编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/BIO%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-05-01T05:47:15.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/BIO%E7%BC%96%E7%A8%8B/">BIO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a><strong>BIO编程</strong></h2><p>BIO有的称之为basic(基本)IO,有的称之为block(阻塞)IO,主要应用于文件IO和网络IO,这里不再说文件IO,本次主要讲解网络IO。<br>在JDK1.4之前,我们建立网络连接的时候只能采用BIO,需要先在服务端启动一个ServerSocket,然后在客户端启动Socket来对服务端进行通信,默认情况下服务端需要对每个请求建立一个线程等待请求,而客户端发送请求后,先咨询服务端是否有线程响应,如果没有则会一直等待或者遭到拒绝,如果有的话,客户端线程会等待请求结束后才继续执行,这就是阻塞式 IO。</p>
<p>接下来通过一个例子复习回顾一下 BIO 的基本用法（基于 TCP）。 </p>
<pre><code>//BIO 服务器端程序 
public class TCPServer {
    public static void main(String[] args) throws Exception {
        //1.创建 ServerSocket 对象 
        ServerSocket ss=new ServerSocket(9999);
        while (true) {
        //2.监听客户端 
            Socket s = ss.accept(); //阻塞,除非有一个客户端发来请求。 
            //3.从连接中取出输入流来接收消息 
            InputStream is = s.getInputStream(); //阻塞 
            byte[] b = new byte[10];
            is.read(b);
            String clientIP = s.getInetAddress().getHostAddress();
            System.out.println(clientIP + &quot;说:&quot; + new String(b).trim());
            //4.从连接中取出输出流并回话 
            OutputStream os = s.getOutputStream();
            os.write(&quot;没钱&quot;.getBytes());
            //5.关闭            
            s.close();
        }
    }
}</code></pre><p>上述代码编写了一个服务器端程序,绑定端口号 9999,accept 方法用来监听客户端连接,如果没有客户端连接,就一直等待,程序会阻塞到这里。</p>
<pre><code>//BIO 客户端程序 
public class TCPClient {
    public static void main(String[] args) throws Exception {
        while (true) {
            //1.创建 Socket 对象 
            Socket s = new Socket(&quot;127.0.0.1&quot;, 9999);
            //2.从连接中取出输出流并发消息 
            OutputStream os = s.getOutputStream();
            System.out.println(&quot;请输入:&quot;);
            Scanner sc = new Scanner(System.in);
            String msg = sc.nextLine();
            os.write(msg.getBytes());
            //3.从连接中取出输入流并接收回话 
            InputStream is = s.getInputStream(); //阻塞 
            byte[] b = new byte[20];
            is.read(b);
            System.out.println(&quot;老板说:&quot; + new String(b).trim());
            //4.关闭 
            s.close();
        }
    }
}</code></pre><p>上述代码编写了一个客户端程序,通过 9999 端口连接服务器端,getInputStream 方法用来<br>等待服务器端返回数据,如果没有返回,就一直等待,程序会阻塞到这里。运行效果如下图<br>所</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/BIO%E7%BC%96%E7%A8%8B/" data-id="ckb22iufh007uzwu8afbtahb7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-多线程/生产者消费者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-05-01T05:47:15.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/">生产者消费者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a><strong>生产者消费者模式</strong></h2><p>该模式在现实生活中很常见，在项目开发中也广泛应用，它是线程间通信的经典应用。<br>生产者是一堆线程，消费者是另一堆线程，内存缓冲区可以使用List集合存储数据。该模式的关键之处是如何处理多线程之间的协调通信，内存缓冲区为空的时候，消费者必须等待，<br>而内存缓冲区满的时候，生产者必须等待，其他时候可以是个动态平衡。 </p>
<p><strong>案例</strong><br>下面的案例模拟实现农夫采摘水果放到筐里，小孩从筐里拿水果吃<br>农夫是一个线程，小孩是一个线程，水果筐放满了，农夫停；水果筐空了，小孩停。 </p>
<pre><code>public class Kuang { 
    //这个集合就是水果筐 假设最多存 10 个水果 
    public static ArrayList&lt;String&gt; kuang=new ArrayList&lt;String&gt;(); 
}</code></pre><p>上述代码定义一个静态集合作为内存缓冲区用来存储数据，同时这个集合也可以作为锁去被多个线程使用。 </p>
<pre><code>public class Farmer extends Thread {
    public void run() {
        while (true) {
            synchronized (Kuang.kuang) {
                //1.筐放满了就让农夫休息 
                if (Kuang.kuang.size() == 10) {
                    try {
                        Kuang.kuang.wait();
                    } catch (InterruptedException e) {
                    }
                }
                //2.往筐里放水果 
                Kuang.kuang.add(&quot;apple&quot;);
                System.out.println(&quot;农夫放了一个水果,目前筐里有&quot; + Kuang.kuang.size()
                        + &quot;个水果&quot;);
                //3.唤醒小孩继续吃 
                Kuang.kuang.notify();
            }
            //4.模拟控制速度 
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
    }
}</code></pre><p>上述代码就是农夫线程，不断的往集合（筐）里放水果，当筐满了就停，同时释放锁。 </p>
<pre><code>public class Child extends Thread {
    public void run() {
        while (true) {
            synchronized (Kuang.kuang) {
                //1.筐里没水果了就让小孩休息 
                if (Kuang.kuang.size() == 0) {
                    try {
                        Kuang.kuang.wait();
                    } catch (InterruptedException e) {
                    }
                }
                //2.小孩吃水果 
                Kuang.kuang.remove(&quot;apple&quot;);
                System.out.println(&quot;小孩吃了一个水果,目前筐里有&quot; + Kuang.kuang.size() + &quot;个水果&quot;);
                //3.唤醒农夫继续放水果 
                Kuang.kuang.notify();
            }
            //4.模拟控制速度 
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre><p>上述代码是小孩线程，不断的从集合（筐）里拿水果吃，当筐空了就停，同时释放锁。 </p>
<pre><code>public class TestFarmerChild { 
    public static void main(String[] args) { 
        new Farmer().start(); 
        new Child().start(); 
    } 
}</code></pre><p>我们创建两个线程同时运行，可以通过双方线程里的 sleep 方法模拟控制速度</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="ckb22iufk0088zwu8dyj05145" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/MySQL锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/" class="article-date">
  <time datetime="2020-04-29T06:24:20.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/">Mysql锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mysql锁的分类"><a href="#Mysql锁的分类" class="headerlink" title="Mysql锁的分类"></a><strong>Mysql锁的分类</strong></h2><p><img src="/images/257.png" alt=""><br><strong>加锁机制：</strong></p>
<ul>
<li>乐观锁：先修改，保存时判断是否被更新过，应用级别</li>
<li>悲观锁：先获取锁，再操作修改，数据库级别</li>
</ul>
<p><strong>锁粒度：</strong></p>
<ul>
<li>表级锁：开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。</li>
<li>页级锁：BDB存储引擎</li>
<li>行级锁：Innodb存储引擎，默认选项</li>
</ul>
<p><strong>兼容性：</strong></p>
<ul>
<li>S锁，也叫做读锁、共享锁，对应于我们常用的 select * from users where id =1 lock in share mode</li>
<li>X锁，也叫做写锁、排它锁、独占锁、互斥锁，对应对于select * from users where id =1 for update<br>下面这个表格是锁冲突矩阵，可以看到只有读锁和读锁之间兼容的，写锁和读锁、写锁都是冲突的。<br><img src="/images/259.png" alt=""><br>冲突的时候会阻塞当前会话，直到拿到锁或者超时<br>这里要提到的一点是，S锁 和 X锁是可以是表锁，也可以是行锁</li>
</ul>
<p><strong>锁模式分类</strong></p>
<ul>
<li>记录锁：单行记录上的锁，行锁是加在索引上的。</li>
<li>间隙锁(gap锁)：锁定记录之间的范围，但不包含记录本身。</li>
<li>间隙锁(Next Key Lock): 记录锁+ 间隙锁，锁定一个范围，包含记录本身。</li>
<li>意向锁( Intention Locks )<ul>
<li>IS: 意向共享锁</li>
<li>IX: 意向排他锁<br>  InnoDB为了支持多粒度(表锁与行锁)的锁并存，引入意向锁。意向锁是表级锁，<br>  事务在请求某一行的S锁和X锁前，需要先获得对应表的IS、IX锁。<br>  意向锁产生的主要目的是为了处理行锁和表锁之间的冲突，用于表明“某个事务正在某一行上持有了锁，或者准备去持有锁”。比如，表中的某一行上加了X锁，就不能对这张表加X锁。<br>  如果不在表上加意向锁，对表加锁的时候，都要去检查表中的某一行上是否加有行锁，多麻烦。         </li>
</ul>
</li>
<li>插入意向锁（Insert Intention Lock）<br>Gap Lock中存在一种插入意向锁，在insert操作时产生。<br>有两个作用：<ul>
<li>和next-key互斥，阻塞next-key 锁，防止插入数据，这样就不会幻读。</li>
<li>插入意向锁互相是兼容的，允许相同间隙、不同数据的并发插入</li>
</ul>
</li>
</ul>
<h2 id="加锁的sql语法"><a href="#加锁的sql语法" class="headerlink" title="加锁的sql语法"></a><strong>加锁的sql语法</strong></h2><p>后面会有多个SQL语句，先说明一下表结构</p>
<pre><code>CREATE TABLE user (
id int(11) unsigned NOT NULL AUTO_INCREMENT,
id_no varchar(255) DEFAULT NULL COMMENT &apos;身份证号&apos;,
name varchar(255) DEFAULT NULL COMMENT &apos;姓名&apos;,
mobile varchar(255) DEFAULT NULL COMMENT &apos;手机号&apos;,
age int(11) DEFAULT NULL COMMENT &apos;年龄&apos;,
address varchar(255) DEFAULT NULL COMMENT &apos;地址&apos;,
PRIMARY KEY (id),
UNIQUE KEY uniq_id_no (id_no),
KEY idx_name (name)
) ENGINE=InnoDB AUTO_INCREMENT=10002 DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;;</code></pre><p>这里有一个user表，5个字段，其中id是主键，id_no是身份证号，加了唯一索引，name是用户姓名，可以重复的，加了普通索引，手机号、年龄、地址都没有索引。</p>
<p><strong>1.普通select</strong></p>
<pre><code>select ***** from user where id =1;
begin;
select ***** from user where id =1;
commit:</code></pre><p>普通的select 语句是不加锁的。select包裹在事务中，同样也是不加锁的。where后面的条件不管多少，普通的select是不加锁的。</p>
<p><strong>2.显式加锁</strong></p>
<pre><code>select ***** from user where id =1 lock in share mode;
select ***** from user where id =1 for update;</code></pre><p>显式指出要加什么样的锁。上面一个加的是共享锁，下面的是互斥锁。<br>这里需要强调的一点，需要明确在事务中是用这些锁，不在事务中是没有意义的。</p>
<p><strong>3.隐式加锁</strong></p>
<pre><code>update user set address &apos;北京&apos; where id=1;
delete from user where id=1;</code></pre><p>update和delete也会对查询出的记录加X锁，隐式加互斥锁。加锁类型和for update 类似<br>后面只按照显式加锁的select for update 举例子，更新和删除的加锁方式是一样的。</p>
<p><strong>4.按索引类型</strong></p>
<pre><code>select ***** from user where id =1 for update;
select ***** from user where id_no =&apos;a22&apos; for update;
select ***** from user where name =&apos;王二&apos; for update;
select ***** from user where address =&apos;杭州&apos; for update;</code></pre><p>四条SQL，区别在于where条件的过滤列，分别是主键、唯一索引、普通索引、无索引。<br><img src="/images/260.png" alt=""> </p>
<p><strong>5.记录不存在的情况</strong></p>
<p>前面几个例子中，都是可以查到结果的。如果对应记录不存在会怎样？答案是锁住间隙，不允许插入。mysql要保证没有其他人可以插入，所以锁住间隙。</p>
<p><strong>6.普通 insert 语句</strong></p>
<p>在插入之前，会先在插入记录所在的间隙加上一个插入意向锁。</p>
<p>insert会对插入成功的行加上排它锁，这个排它锁是个记录锁，而非next-key锁（当然更不是gap锁了），不会阻止其他并发的事务往这条记录之前插入 。</p>
<h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a><strong>死锁的概念</strong></h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>
<p>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</p>
<p>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。<br><strong>产生死锁的四个必要条件：</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><strong>举个例子</strong></p>
<pre><code>mysql&gt; SELECT * FROM test;
+----+------+
| id | name |
+----+------+
|  1 | 1    |
|  5 | 5    |
| 10 | 10   |
| 15 | 15   |
| 20 | 20   |
| 25 | 25   |
+----+------+
6 rows in set (0.00 sec)</code></pre><p>当数据库的隔离级别为Repeatable Read或Serializable时,我们来看这样的两个并发事务（场景一）：<br><img src="/images/261.png" alt=""></p>
<p>上面两个并发事务一定会发生死锁（这里之所以限定RR和Serializable两个隔离级别，是因为只有这两个级别下才会有间隙锁/临键锁，而这是导致死锁的根本原因，后面会详细分析）。</p>
<p>我们再来看另外一个并发场景（场景二）：<br><img src="/images/262.png" alt=""></p>
<p>在这个并发场景下，两个事务均能成功提交，而不会有死锁。</p>
<p>在上面的示例中，我们发现，select … for update虽然可以用于解决数据库的并发操作，但在实际项目中却不建议使用，原因是当查询条件对应的记录不存在时，很容易造成死锁。分析可得是 间隙锁/临键锁。</p>
<h1 id="锁分类详解"><a href="#锁分类详解" class="headerlink" title="锁分类详解"></a><strong>锁分类详解</strong></h1><h2 id="1-锁粒度分类"><a href="#1-锁粒度分类" class="headerlink" title="1.锁粒度分类"></a><strong>1.锁粒度分类</strong></h2><p><strong>行锁</strong></p>
<ul>
<li><p>行锁一定是作用在索引上的。</p>
</li>
<li><p>行级锁定（row-level）：开销大，加锁慢；会出现死锁；</p>
</li>
<li><p>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p>由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p>
</li>
<li><p>行级锁只在存储引擎层实现，而MySQL服务器层没有实现，服务器层完全不了解存储引擎中的锁实现。</p>
</li>
<li><p>缺陷：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p>
</li>
<li><p>总结：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。</p>
</li>
</ul>
<p><strong>页级锁定(page-level)</strong></p>
<ul>
<li><p>(MySQL特有)开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
<li><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。</p>
</li>
<li><p>页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。</p>
</li>
<li><p>缺陷：页级锁定和行级锁定一样，会发生死锁。</p>
</li>
</ul>
<p><strong>表级锁定(table-level)</strong></p>
<ul>
<li><p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
</li>
<li><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。</p>
</li>
<li><p>该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。</p>
</li>
<li><p>所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p>
</li>
<li><p>缺陷：锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。</p>
</li>
</ul>
<h2 id="2-兼容性分类"><a href="#2-兼容性分类" class="headerlink" title="2.兼容性分类"></a><strong>2.兼容性分类</strong></h2><p><strong>共享锁：</strong>（又称读取，S锁）：会阻塞其他事务修改表数据。可以读。<br>若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能X锁，直到T释放A上的锁。这就保证了其他事务可以读A，但在T释放S锁之前不能对A做任何修改。<br>select * from users where id =1 lock in share mode</p>
<p><strong>排他锁：</strong>（又称写锁，X锁）:会阻塞其他事务读和写。<br>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。<br>select * from users where id =1 for update</p>
<h2 id="3-锁模式分类"><a href="#3-锁模式分类" class="headerlink" title="3.锁模式分类"></a><strong>3.锁模式分类</strong></h2><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a><strong>记录锁</strong></h3><p>记录锁存在于包括主键索引在内的唯一索引中，锁定单条索引记录<br>对单条索引记录进行加锁，锁住的是索引记录而非记录本身，即使表中没有任何索引，MySQL会自动创建一个隐式的row_id作为聚集索引来进行加锁。<br>加锁列必须为唯一索引列或主键列，否则上述语句加的锁就会变成临键锁。<br>同时查询语句必须为精准匹配（=），不能为 &gt;、&lt;、like等，否则也会退化成临键锁</p>
<pre><code>-- id 列为主键列或唯一索引列
SELECT * FROM table WHERE id = 1 FOR UPDATE;　
在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：
UPDATE SET age = 50 WHERE id = 1;　
id 为 1 的记录行会被锁住。</code></pre><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a><strong>间隙锁</strong></h3><p>间隙锁基于下面将会提到的Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。<br>间隙锁存在于非唯一索引中，锁定开区间范围内的一段间隔<br>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”，InnoDB<strong>也</strong>会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁锁。<br><strong>间隙锁的产生</strong></p>
<p>上面的文字很抽象，现在举个栗子，介绍间隙锁是怎么产生的：</p>
<p>假设有以下表t_student：（其中id为PK，name为非唯一索引）<br><img src="/images/263.png" alt=""> </p>
<p>这个时候我们发出一条这样的加锁sql语句：</p>
<p>select id,name from t_student where id &gt; 0 and id &lt; 5 for update;</p>
<p>这时候，我们命中的数据为以下着色部分：<br><img src="/images/264.png" alt=""><br>细心的朋友可能就会发现，这里缺少了条id为2的记录，我们的重点就在这里。</p>
<p>select … for update这条语句，是会对数据记录加锁的，这里因为命中了索引，加的是行锁。从数据记录来看，这里排它锁锁住数据是id为1、3和4的这3条数据。</p>
<p>但是，看看前面我们的介绍——对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁。</p>
<p>键值在条件范围但是不存在的记录，就是id为2的记录，这里会对id为2数据加上间隙锁。假设这时候如果有id=2的记录insert进来了，是要等到这个事务结束以后才会执行的</p>
<p>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p>
<pre><code>SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</code></pre><p>即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。<br><strong>间隙锁的作用</strong>：防止幻读和防止数据误删/改</p>
<p><strong>区间的开闭初中数学</strong><br>(0 1) 开区间就是端点不能取 这里就是 0 和 1 不能取<br>[0 1] 闭区间就是端点可以取 这里就是 0 和 1 可以取</p>
<h3 id="临键锁-Next-Key"><a href="#临键锁-Next-Key" class="headerlink" title="临键锁(Next-Key)"></a><strong>临键锁(Next-Key)</strong></h3><p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临键锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。<br>假设有如下表：<br>MySql，InnoDB，Repeatable-Read：table(id PK, age KEY, name)</p>
<pre><code>id    age    name
1     10     Lee
3     24     Soraka
5     32     Zed
7     45     Talon</code></pre><p>该表中 age 列潜在的临键锁有：</p>
<p>(-∞, 10],<br>(10, 24],<br>(24, 32],<br>(32, 45],<br>(45, +∞],</p>
<p>在事务 A 中执行如下命令：</p>
<pre><code>-- 根据非唯一索引列 UPDATE 某条记录
UPDATE table SET name = Vladimir WHERE age = 24;
-- 或根据非唯一索引列 锁住某条记录
SELECT * FROM table WHERE age = 24 FOR UPDATE;</code></pre><p>不管执行了上述 SQL 中的哪一句，之后如果在事务 B 中执行以下命令，则该命令会被阻塞：</p>
<pre><code>INSERT INTO table VALUES(100, 26, &apos;Ezreal&apos;);</code></pre><p>很明显，事务 A 在对 age 为 24 的列进行 UPDATE 操作的同时，也获取了 (24, 32] 这个区间内的临键锁。</p>
<p>不仅如此，在执行以下 SQL 时，也会陷入阻塞等待：</p>
<pre><code>INSERT INTO table VALUES(100, 11, &apos;Ezreal&apos;);</code></pre><p>那最终我们就可以得知，在根据非唯一索引 对记录行进行 UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE 操作时，InnoDB 会获取该记录行的 临键锁 ，并同时获取该记录行下一个区间的间隙锁。</p>
<p>即事务 A在执行了上述的 SQL 后，最终被锁住的记录区间为 (10, 32)。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h3><p>InnoDB为了让表锁和行锁共存而使用了意向锁。</p>
<p>为什么没有意向锁的话，表锁和行锁不能共存？</p>
<p>举个粟子（此时假设行锁和表锁能共存）： 事务A锁住表中的一行（写锁）。事务B锁住整个表（写锁）。</p>
<p>但你就会发现一个很明显的问题，事务A既然锁住了某一行，其他事务就不可能修改这一行。这与”事务B锁住整个表就能修改表中的任意一行“形成了冲突。所以，没有意向锁的时候，行锁与表锁共存就会存在问题！<br>意向锁是如何让表锁和行锁共存的？</p>
<p>有了意向锁之后，前面例子中的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。</p>
<p>所以，意向锁的作用就是：</p>
<p>当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要的是某行（或者某些行）的排他锁定，则申请一个意向排他锁。<br>共享锁/排他锁与意向共享锁/意向排他锁的兼容性关系：<br><img src="/images/259.png" alt=""> </p>
<h2 id="4-加锁机制分类"><a href="#4-加锁机制分类" class="headerlink" title="4.加锁机制分类"></a><strong>4.加锁机制分类</strong></h2><p>乐观锁和悲观锁的思想</p>
<p>在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><p><strong>概念</strong></p>
<ul>
<li>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。</li>
<li>它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作在某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</li>
<li>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</li>
<li>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。</li>
<li>悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</li>
</ul>
<p><strong>在数据库中，悲观锁的流程如下：</strong></p>
<ul>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
</ul>
<p><strong>MySQL InnoDB中使用悲观锁</strong></p>
<p>要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
<pre><code>set autocommit=0;</code></pre><p><strong>悲观锁优点与不足</strong></p>
<ul>
<li>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。- 但是在效率方面，处理加锁的机制会让数据库产生额外的开销</li>
<li>还有增加产生死锁的机会</li>
<li>另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载</li>
<li>还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h3><p><strong>概念</strong></p>
<ul>
<li>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。</li>
<li>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。</li>
<li>在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。</li>
<li>如果其他事务有更新的话，正在提交的事务会进行回滚。</li>
<li>乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</li>
</ul>
<p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p><strong>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</strong></p>
<p>数据版本:为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
<p><strong>乐观锁使用CAS（Compare And Swep）操作保证数据一致性</strong></p>
<p><strong>使用版本号实现乐观锁</strong><br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<p><strong>乐观锁优点与不足</strong></p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何死锁。<br>但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/" data-id="ckb22iufq008yzwu8hq68cybc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/Mysql索引优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2020-04-28T13:20:36.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">Mysql索引优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-关联查询优化"><a href="#1-关联查询优化" class="headerlink" title="1.关联查询优化"></a>1.关联查询优化</h2><p><strong>1.建表语句</strong> </p>
<pre><code>CREATE TABLE IF NOT EXISTS `class` ( 
`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, 
`card` INT(10) UNSIGNED NOT NULL, 
PRIMARY KEY (`id`) 
);
CREATE TABLE IF NOT EXISTS `book` (
`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, 
`card` INT(10) UNSIGNED NOT NULL, 
PRIMARY KEY (`bookid`) 
);
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); 
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20))); </code></pre><h3 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a><strong>2.案例</strong></h3><p><strong>left join</strong> </p>
<pre><code>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;

mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | class | ALL  | NULL          | NULL | NULL    | NULL | 3670 |       |
|  1 | SIMPLE      | book  | ALL  | NULL          | NULL | NULL    | NULL | 1050 |       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+</code></pre><p>如何优化？在哪个表上建立索引？<br>ALTER TABLE <code>book</code> ADD INDEX idx_card( <code>card</code>); </p>
<pre><code>mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;
+----+-------------+-------+------+---------------+-----------+---------+-----------------+------+-------------+
| id | select_type | table | type | possible_keys | key       | key_len | ref             | rows | Extra       |
+----+-------------+-------+------+---------------+-----------+---------+-----------------+------+-------------+
|  1 | SIMPLE      | class | ALL  | NULL          | NULL      | NULL    | NULL            | 3670 |             |
|  1 | SIMPLE      | book  | ref  | idx_bcard     | idx_bcard | 4       | db01.class.card |    5 | Using index |
+----+-------------+-------+------+---------------+-----------+---------+-----------------+------+-------------+</code></pre><p>删除 book 表的索引：drop index idx_card on book;<br>在 class 表上建立索引：alter table class add index idx_card(card); </p>
<pre><code>mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;
+----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key       | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+
|  1 | SIMPLE      | class | index | NULL          | idx_bcard | 4       | NULL | 3670 | Using index |
|  1 | SIMPLE      | book  | ALL   | NULL          | NULL      | NULL    | NULL | 1050 |             |
+----+-------------+-------+-------+---------------+-----------+---------+------+------+-------------+</code></pre><p>结论：通过rows行何以看出</p>
<ul>
<li>在优化关联查询时，只有在被驱动表上建立索引才有效！ </li>
<li>left join 时，左侧的为驱动表，右侧为被驱动表！ </li>
</ul>
<p><strong>inner join</strong><br>EXPLAIN SELECT * FROM book inner join class on class.card=book.card;<br>EXPLAIN SELECT * FROM class inner join book on class.card=book.card;</p>
<ul>
<li>两个查询字段调换顺序，发现结果也是一样的！ </li>
<li>结论：inner join 时，mysql 会自己帮你把小结果集的表选为驱动表。 </li>
<li>straight_join: 效果和 inner join 一样，但是会强制将左侧作为驱动表！</li>
</ul>
<p><strong>四个关联查询案例分析</strong><br><strong>1</strong></p>
<pre><code>EXPLAIN SELECT ed.name &apos;人物&apos;,c.name &apos;掌门&apos; FROM 
(SELECT e.name,d.ceo from t_emp e LEFT JOIN t_dept d on e.deptid=d.id) ed 
LEFT JOIN t_emp c on ed.ceo= c.id;
+----+-------------+------------+--------+---------------+---------+---------+---------------+------+-------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref           | rows | Extra |
+----+-------------+------------+--------+---------------+---------+---------+---------------+------+-------+
|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL          | NULL    | NULL    | NULL          |   10 |       |
|  1 | PRIMARY     | c          | eq_ref | PRIMARY       | PRIMARY | 4       | ed.ceo        |    1 |       |
|  2 | DERIVED     | e          | ALL    | NULL          | NULL    | NULL    | NULL          |   10 |       |
|  2 | DERIVED     | d          | eq_ref | PRIMARY       | PRIMARY | 4       | db01.e.deptId |    1 |       |
+----+-------------+------------+--------+---------------+---------+---------+---------------+------+-------+

EXPLAIN SELECT e.name &apos;人物&apos;,tmp.name &apos;掌门&apos; 
FROM t_emp e LEFT JOIN (SELECT d.id did,e.name FROM t_dept d LEFT JOIN t_emp e ON d.ceo=e.id)tmp 
ON e.deptId=tmp.did; 
+----+-------------+------------+--------+---------------+---------+---------+------------+------+-------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref        | rows | Extra |
+----+-------------+------------+--------+---------------+---------+---------+------------+------+-------+
|  1 | PRIMARY     | e          | ALL    | NULL          | NULL    | NULL    | NULL       |   10 |       |
|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL          | NULL    | NULL    | NULL       |    6 |       |
|  2 | DERIVED     | d          | ALL    | NULL          | NULL    | NULL    | NULL       |    6 |       |
|  2 | DERIVED     | e          | eq_ref | PRIMARY       | PRIMARY | 4       | db01.d.CEO |    1 |       |
+----+-------------+------------+--------+---------------+---------+---------+------------+------+-------+</code></pre><p>上述两个案例，第一个查询效率较高，且有优化的余地。第二个案例中，子查询作为被驱动表，由于子查询是虚表，无法建立索引，因此不能优化。<br>结论：子查询尽量不要放在被驱动表，有可能使用不到索引； left join时，尽量让实体表作为被驱动表。</p>
<p><strong>2</strong></p>
<pre><code>EXPLAIN SELECT e1.name &apos;人物&apos;,e2.name &apos;掌门&apos; 
FROM t_emp e1 
LEFT JOIN t_dept d on e1.deptid = d.id 
LEFT JOIN t_emp e2 on d.ceo = e2.id ; 
+----+-------------+-------+--------+---------------+---------+---------+----------------+------+-------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref            | rows | Extra |
+----+-------------+-------+--------+---------------+---------+---------+----------------+------+-------+
|  1 | SIMPLE      | e1    | ALL    | NULL          | NULL    | NULL    | NULL           |   10 |       |
|  1 | SIMPLE      | d     | eq_ref | PRIMARY       | PRIMARY | 4       | db01.e1.deptId |    1 |       |
|  1 | SIMPLE      | e2    | eq_ref | PRIMARY       | PRIMARY | 4       | db01.d.CEO     |    1 |       |
+----+-------------+-------+--------+---------------+---------+---------+----------------+------+-------+


Explain SELECT e2.name &apos;人物&apos;, 
(SELECT e1.name FROM t_emp e1 where e1.id= d.ceo) &apos;掌门&apos; 
from t_emp e2 LEFT JOIN t_dept d on e2.deptid=d.id; 
+----+--------------------+-------+--------+---------------+---------+---------+----------------+------+-------+
| id | select_type        | table | type   | possible_keys | key     | key_len | ref            | rows | Extra |
+----+--------------------+-------+--------+---------------+---------+---------+----------------+------+-------+
|  1 | PRIMARY            | e2    | ALL    | NULL          | NULL    | NULL    | NULL           |   10 |       |
|  1 | PRIMARY            | d     | eq_ref | PRIMARY       | PRIMARY | 4       | db01.e2.deptId |    1 |       |
|  2 | DEPENDENT SUBQUERY | e1    | eq_ref | PRIMARY       | PRIMARY | 4       | db01.d.CEO     |    1 |       |
+----+--------------------+-------+--------+---------------+---------+---------+----------------+------+-------+</code></pre><p>结论：能够直接多表关联的尽量直接关联，不用子查询！ </p>
<h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a><strong>子查询优化</strong></h2><p><strong>案例</strong><br>取所有不为掌门人的员工，按年龄分组！ </p>
<pre><code>select age as &apos;年龄&apos;, count(*) as &apos;人数&apos; from t_emp where id not in
(select ceo from t_dept where ceo is not null) group by age; 
mysql&gt; explain select age as &apos;年龄&apos;, count(*) as &apos;人数&apos; from t_emp where id not in
-&gt; (select ceo from t_dept where ceo is not null) group by age;
+----+--------------------+--------+------+---------------+------+---------+------+------+----------------------------------------------+
| id | select_type        | table  | type | possible_keys | key  | key_len | ref  | rows | Extra                                        |
+----+--------------------+--------+------+---------------+------+---------+------+------+----------------------------------------------+
|  1 | PRIMARY            | t_emp  | ALL  | NULL          | NULL | NULL    | NULL |   10 | Using where; Using temporary; Using filesort |
|  2 | DEPENDENT SUBQUERY | t_dept | ALL  | NULL          | NULL | NULL    | NULL |    6 | Using where                                  |
+----+--------------------+--------+------+---------------+------+---------+------+------+----------------------------------------------+</code></pre><p><strong>如何优化？</strong><br>1.解决 dept 表的全表扫描，建立 ceo 字段的索引：</p>
<p>2.进一步优化，替换 not in。<br>上述 SQL 可以替换为：</p>
<pre><code>select age as &apos;年龄&apos;,count(*) as &apos;人数&apos; from emp e left join dept d on e.id=d.ceo where d.id is null group by age; </code></pre><p>结论： 在范围判断时，尽量不要使用 not in 和 not exists，使用 left join on xxx is null 代替。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" data-id="ckb22iufr0093zwu8939rfx4i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/WHERE和ON的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-04-28T13:20:36.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">WHERE和ON的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>建立表</strong></p>
<pre><code>CREATE TABLE t_dept ( 
        id INT(11) NOT NULL AUTO_INCREMENT, 
        deptName VARCHAR(30) DEFAULT NULL, 
        address VARCHAR(40) DEFAULT NULL, 
        PRIMARY KEY (id) 
        ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 
        CREATE TABLE t_emp ( 
        id INT(11) NOT NULL AUTO_INCREMENT, 
        name VARCHAR(20) DEFAULT NULL, 
        age INT(3) DEFAULT NULL, 
        deptId INT(11) DEFAULT NULL, 
        empno int not null, 
        PRIMARY KEY (id), 
        KEY idx_dept_id (deptId) 
        #CONSTRAINT fk_dept_id FOREIGN KEY (deptId) REFERENCES t_dept (id) 
        ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 

    INSERT INTO t_dept(deptName,address) VALUES(&apos;华山&apos;,&apos;华山&apos;); 
    INSERT INTO t_dept(deptName,address) VALUES(&apos;丐帮&apos;,&apos;洛阳&apos;); 
    INSERT INTO t_dept(deptName,address) VALUES(&apos;峨眉&apos;,&apos;峨眉山&apos;); 
    INSERT INTO t_dept(deptName,address) VALUES(&apos;武当&apos;,&apos;武当山&apos;); 
    INSERT INTO t_dept(deptName,address) VALUES(&apos;明教&apos;,&apos;光明顶&apos;); 
    INSERT INTO t_dept(deptName,address) VALUES(&apos;少林&apos;,&apos;少林寺&apos;); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;风清扬&apos;,90,1,100001);  
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;岳不群&apos;,50,1,100002); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;令狐冲&apos;,24,1,100003); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;洪七公&apos;,70,2,100004); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;乔峰&apos;,35,2,100005); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;灭绝师太&apos;,70,3,100006); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;周芷若&apos;,20,3,100007); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;张三丰&apos;,100,4,100008); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;张无忌&apos;,25,5,100009); 
    INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&apos;韦小宝&apos;,18,null,100010);</code></pre><p><strong>查询结果</strong></p>
<pre><code>mysql&gt; select * from t_emp;
+----+--------------+------+--------+--------+
| id | name         | age  | deptId | empno  |
+----+--------------+------+--------+--------+
|  1 | 风清扬       |   90 |      1 | 100001 |
|  2 | 岳不群       |   50 |      1 | 100002 |
|  3 | 令狐冲       |   24 |      1 | 100003 |
|  4 | 洪七公       |   70 |      2 | 100004 |
|  5 | 乔峰         |   35 |      2 | 100005 |
|  6 | 灭绝师太     |   70 |      3 | 100006 |
|  7 | 周芷若       |   20 |      3 | 100007 |
|  8 | 张三丰       |  100 |      4 | 100008 |
|  9 | 张无忌       |   25 |      5 | 100009 |
| 10 | 韦小宝       |   18 |   NULL | 100010 |
+----+--------------+------+--------+--------+

mysql&gt; select * from t_dept;
+----+----------+-----------+------+
| id | deptName | address   | CEO  |
+----+----------+-----------+------+
|  1 | 华山     | 华山      |    2 |
|  2 | 丐帮     | 洛阳      |    4 |
|  3 | 峨眉     | 峨眉山    |    6 |
|  4 | 武当     | 武当山    |    8 |
|  5 | 明教     | 光明顶    |    9 |
|  6 | 少林     | 少林寺    | NULL |
+----+----------+-----------+------+</code></pre><p><strong>select * from t_emp t1 left join t_dept t2 on t1.id=t2.ceo ;</strong><br>先建立连接关系</p>
<pre><code>+----+--------------+------+--------+--------+------+----------+-----------+------+
| id | name         | age  | deptId | empno  | id   | deptName | address   | CEO  |
+----+--------------+------+--------+--------+------+----------+-----------+------+
|  1 | 风清扬       |   90 |      1 | 100001 | NULL | NULL     | NULL      | NULL |
|  2 | 岳不群       |   50 |      1 | 100002 |    1 | 华山     | 华山      |    2 |
|  3 | 令狐冲       |   24 |      1 | 100003 | NULL | NULL     | NULL      | NULL |
|  4 | 洪七公       |   70 |      2 | 100004 |    2 | 丐帮     | 洛阳      |    4 |
|  5 | 乔峰         |   35 |      2 | 100005 | NULL | NULL     | NULL      | NULL |
|  6 | 灭绝师太     |   70 |      3 | 100006 |    3 | 峨眉     | 峨眉山    |    6 |
|  7 | 周芷若       |   20 |      3 | 100007 | NULL | NULL     | NULL      | NULL |
|  8 | 张三丰       |  100 |      4 | 100008 |    4 | 武当     | 武当山    |    8 |
|  9 | 张无忌       |   25 |      5 | 100009 |    5 | 明教     | 光明顶    |    9 |
| 10 | 韦小宝       |   18 |   NULL | 100010 | NULL | NULL     | NULL      | NULL |
+----+--------------+------+--------+--------+------+----------+-----------+------+</code></pre><p><strong>select * from t_emp t1 left join t_dept t2 on t1.id=t2.ceo where t2.id=1 ;</strong><br>Where筛选最终结果</p>
<pre><code>+----+-----------+------+--------+--------+----+----------+---------+------+
| id | name      | age  | deptId | empno  | id | deptName | address | CEO  |
+----+-----------+------+--------+--------+----+----------+---------+------+
|  2 | 岳不群    |   50 |      1 | 100002 |  1 | 华山     | 华山    |    2 |
+----+-----------+------+--------+--------+----+----------+---------+------+</code></pre><p><strong>select * from t_emp t1 left join t_dept t2 on t1.id=t2.ceo and t2.id=1;</strong><br>LEFT JOIN按条件关联，不管是否为真，都返回左边表的数据</p>
<pre><code>mysql&gt; select * from t_emp t1 left join t_dept t2 on t1.id=t2.ceo and t2.id=1;
+----+--------------+------+--------+--------+------+----------+---------+------+
| id | name         | age  | deptId | empno  | id   | deptName | address | CEO  |
+----+--------------+------+--------+--------+------+----------+---------+------+
|  1 | 风清扬       |   90 |      1 | 100001 | NULL | NULL     | NULL    | NULL |
|  2 | 岳不群       |   50 |      1 | 100002 |    1 | 华山     | 华山    |    2 |
|  3 | 令狐冲       |   24 |      1 | 100003 | NULL | NULL     | NULL    | NULL |
|  4 | 洪七公       |   70 |      2 | 100004 | NULL | NULL     | NULL    | NULL |
|  5 | 乔峰         |   35 |      2 | 100005 | NULL | NULL     | NULL    | NULL |
|  6 | 灭绝师太     |   70 |      3 | 100006 | NULL | NULL     | NULL    | NULL |
|  7 | 周芷若       |   20 |      3 | 100007 | NULL | NULL     | NULL    | NULL |
|  8 | 张三丰       |  100 |      4 | 100008 | NULL | NULL     | NULL    | NULL |
|  9 | 张无忌       |   25 |      5 | 100009 | NULL | NULL     | NULL    | NULL |
| 10 | 韦小宝       |   18 |   NULL | 100010 | NULL | NULL     | NULL    | NULL |
+----+--------------+------+--------+--------+------+----------+---------+------+</code></pre><p><strong>结论</strong><br>先执行 ON，后执行 WHERE；ON 是建立关联关系，WHERE 是对关联关系的筛选。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="ckb22iuft009azwu8b6jdbjkw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/常见的索引失效" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" class="article-date">
  <time datetime="2020-04-27T06:48:43.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">常见的索引失效</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>创建索引</strong></p>
<pre><code>CREATE INDEX idx_age_deptid_name ON emp(age,deptid,NAME); </code></pre><h2 id="1-全值匹配我最爱"><a href="#1-全值匹配我最爱" class="headerlink" title="1.全值匹配我最爱"></a><strong>1.全值匹配我最爱</strong></h2><p><strong>有以下 SQL 语句</strong> </p>
<pre><code>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4 
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4 AND emp.name = &apos;abcd&apos; </code></pre><p>结论：全职匹配我最爱指的是，查询的字段在索引中都可以匹配到！<br>SQL 中查询字段的顺序，跟使用索引中字段的顺序，没有关系。优化器会在不影响 SQL 执行结果的前提下，给你自动地优化。 </p>
<pre><code>mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4 AND emp.name = &apos;abcd&apos;;
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref               | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 73      | const,const,const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
1 row in set (0.00 sec)

mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE  deptid=4 AND emp.name = &apos;abcd &apos; and  emp.age=30  ;
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref               | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 73      | const,const,const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
1 row in set (0.00 sec)

mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE  deptid=4 AND emp.name = &apos;abcd &apos;   ;
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</code></pre><h2 id="2-最佳左前缀法则"><a href="#2-最佳左前缀法则" class="headerlink" title="2.最佳左前缀法则"></a><strong>2.最佳左前缀法则</strong></h2><p>查询字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效！<br>原因：使用复合索引，需要遵循最佳左前缀法则，即如果索引了多列，要遵守最左前缀法则。指的是查询从索<br>引的最左前列开始并且不跳过索引中的列。<br>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足(where后顺序可以不一样，但是必须有)，一旦跳过某个字段，索引后面的字段都无<br>法被使用。 </p>
<pre><code>mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=4 ;
+----+-------------+-------+------+---------------------+---------------------+---------+-------------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref         | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 10      | const,const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------+------+-------------+

mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and  emp.name = &apos;abcd&apos;;
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 5       | const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
1 row in set (0.00 sec)</code></pre><h2 id="3-不要在索引列上做任何计算"><a href="#3-不要在索引列上做任何计算" class="headerlink" title="3.不要在索引列上做任何计算"></a><strong>3.不要在索引列上做任何计算</strong></h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），会导致索引失效而转向全表扫描。<br><strong>1.在查询列上使用了函数</strong> </p>
<pre><code>EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age=30; 
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE LEFT(age,3)=30; </code></pre><p>结论：等号左边无计算！ </p>
<pre><code>mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age=30;
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 5       | const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
1 row in set (0.13 sec)

mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE LEFT(age,3)=30;
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</code></pre><p><strong>2.在查询列上做了转换</strong> </p>
<pre><code>create index idx_name on emp(name); 
explain select sql_no_cache * from emp where name=&apos;30000&apos;; 
explain select sql_no_cache * from emp where name=30000; </code></pre><p>字符串不加单引号，则会在 name 列上做一次转换！<br>结论：等号右边无转换！ </p>
<pre><code>mysql&gt; explain select sql_no_cache * from emp where name=&apos;30000&apos;;
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_name      | idx_name | 63      | const |    1 | Using where |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
1 row in set (0.00 sec)
mysql&gt; explain select sql_no_cache * from emp where name=30000;
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | ALL  | idx_name      | NULL | NULL    | NULL |    1 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</code></pre><p><strong>4.索引列上不能有范围查询</strong><br>explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=5 AND emp.name = ‘abcd’;<br>explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid&lt;5 AND emp.name = ‘abcd’;<br>建议：将可能做范围查询的字段的索引顺序放在最后 </p>
<pre><code>mysql&gt; explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid=5 AND emp.name = &apos;abcd&apos;;
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref               | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 73      | const,const,const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
1 row in set (0.00 sec)

mysql&gt; explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid&lt;5 AND emp.name = &apos;abcd&apos;;
+----+-------------+-------+-------+---------------------+---------------------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys       | key                 | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------------+---------------------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | range | idx_age_deptid_name | idx_age_deptid_name | 10      | NULL |    8 | Using where |
+----+-------------+-------+-------+---------------------+---------------------+---------+------+------+-------------+</code></pre><p>有趣的事情是如果查找deptid&lt;=5，那么key_len依旧是73，也就是说也用到了dept的索引，去查询等于的情况。</p>
<pre><code>mysql&gt; explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptid&lt;=5 AND emp.name &lt; &apos;abcd&apos;;
+----+-------------+-------+-------+---------------------+---------------------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys       | key                 | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------------+---------------------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | range | idx_age_deptid_name | idx_age_deptid_name | 73      | NULL |    8 | Using where |
+----+-------------+-------+-------+---------------------+---------------------+---------+------+------+-------------+</code></pre><p><strong>5.尽量使用覆盖索引</strong><br>即查询列和索引列一致，不要写 select * ! ，Extra的Using index表示用了覆盖索引。SQL只需要通过辅助索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据。</p>
<pre><code>explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptId=4 and name=&apos;XamgXt&apos;; 
explain SELECT SQL_NO_CACHE age,deptId,name FROM emp WHERE emp.age=30 and deptId=4 and name=&apos;XamgXt&apos;; 

mysql&gt; explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30 and deptId=4 and name=&apos;XamgXt&apos;;
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref               | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 73      | const,const,const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+-------------+
1 row in set (0.00 sec)

mysql&gt; explain SELECT SQL_NO_CACHE age,deptId,name FROM emp WHERE emp.age=30 and deptId=4 and name=&apos;XamgXt&apos;;
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+--------------------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref               | rows | Extra                    |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+--------------------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 73      | const,const,const |    1 | Using where; Using index |
+----+-------------+-------+------+---------------------+---------------------+---------+-------------------+------+--------------------------+</code></pre><p><strong>6.使用不等于(!= 或者&lt;&gt;)的时候</strong><br>mysql 在使用不等于(!= 或者&lt;&gt;)时，有时会无法使用索引会导致全表扫描。 </p>
<pre><code>mysql&gt; explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=30;
+----+-------------+-------+------+---------------------+---------------------+---------+-------+-------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref   | rows  | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+-------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 5       | const | 44552 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+-------+-------------+
1 row in set (0.00 sec)

mysql&gt; explain SELECT SQL_NO_CACHE * FROM emp WHERE emp.age!=30;
+----+-------------+-------+------+---------------------+------+---------+------+--------+-------------+
| id | select_type | table | type | possible_keys       | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-------+------+---------------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | emp   | ALL  | idx_age_deptid_name | NULL | NULL    | NULL | 500493 | Using where |
+----+-------------+-------+------+---------------------+------+---------+------+--------+-------------+</code></pre><p><strong>7.字段的 is not null 和 is null</strong><br>当字段允许为 Null 的条件下：<br>is not null 用不到索引，is null 可以用到索引。 </p>
<pre><code>mysql&gt; explain SELECT * FROM emp WHERE age IS NULL;
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys       | key                 | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | idx_age_deptid_name | idx_age_deptid_name | 5       | const |    1 | Using where |
+----+-------------+-------+------+---------------------+---------------------+---------+-------+------+-------------+
1 row in set (0.00 sec)

mysql&gt; explain SELECT * FROM emp WHERE age IS NOT NULL;
+----+-------------+-------+------+---------------------+------+---------+------+--------+-------------+
| id | select_type | table | type | possible_keys       | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-------+------+---------------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | emp   | ALL  | idx_age_deptid_name | NULL | NULL    | NULL | 500493 | Using where |
+----+-------------+-------+------+---------------------+------+---------+------+--------+-------------+</code></pre><p><strong>8.like 的前后模糊匹配</strong><br>前缀不能出现模糊匹配！<br>如 %a和%a%是不能使用索引的，只有a%才可以使用到索引。</p>
<pre><code>mysql&gt; explain SELECT * FROM emp WHERE name LIKE &apos;%a&apos;;
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL | 500493 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.34 sec)

mysql&gt; explain SELECT * FROM emp WHERE name LIKE &apos;%a%&apos;;
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL | 500493 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.00 sec)

mysql&gt; explain SELECT * FROM emp WHERE name LIKE &apos;a%&apos;;
+----+-------------+-------+-------+---------------+----------+---------+------+-------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows  | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+-------+-------------+
|  1 | SIMPLE      | emp   | range | idx_name      | idx_name | 63      | NULL | 37846 | Using where |
+----+-------------+-------+-------+---------------+----------+---------+------+-------+-------------+</code></pre><p><strong>9.减少使用 or</strong><br>使用 union all 或者 union 来替代：<br>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；<br>Union All：对两个结果集进行并集操作，包括重复行，不进行排序<br>不过实测用or的时候索引依然有效。</p>
<p><strong>10.练习</strong><br>假设 index(a,b,c)； </p>
<table>
<thead>
<tr>
<th>Where 语句</th>
<th>索引是否被使用</th>
</tr>
</thead>
<tbody><tr>
<td>where a = 3</td>
<td>Y,使用到 a</td>
</tr>
<tr>
<td>where a = 3</td>
<td>and b = 5 Y,使用到 a，b</td>
</tr>
<tr>
<td>where a = 3</td>
<td>and b = 5 and c = 4 Y,使用到 a,b,c</td>
</tr>
<tr>
<td>where b = 3</td>
<td>或者 where b = 3 and c = 4 或者</td>
</tr>
<tr>
<td>where c = 4</td>
<td>N</td>
</tr>
<tr>
<td>where a = 3 and c = 5</td>
<td>使用到 a， 但是 c 不可以，b 中间断了</td>
</tr>
<tr>
<td>where a = 3 and b &gt; 4 and c = 5</td>
<td>使用到 a 和 b， c 不能用在范围之后，b 断了</td>
</tr>
<tr>
<td>where a is null and b is not null</td>
<td>is null 支持索引 但是 is not null 不支持,所 以 a 可以使用索引,但是 b 不可以使用</td>
</tr>
<tr>
<td>where a &lt;&gt; 3</td>
<td>N，不能使用索引</td>
</tr>
<tr>
<td>where abs(a) =3</td>
<td>不能使用 索引</td>
</tr>
<tr>
<td>where a = 3 and b like ‘kk%’ and c = 4</td>
<td>Y,使用到 a,b,c</td>
</tr>
<tr>
<td>where a = 3 and b like ‘%kk’ and c = 4</td>
<td>Y,只用到 a</td>
</tr>
<tr>
<td>where a = 3 and b like ‘%kk%’ and c = 4</td>
<td>Y,只用到 a</td>
</tr>
<tr>
<td>where a = 3 and b like ‘k%kk%’ and c = 4</td>
<td>Y,使用到 a,b,c</td>
</tr>
</tbody></table>
<p><strong>11.口诀</strong><br>全职匹配我最爱，最左前缀要遵守；<br>带头大哥不能死，中间兄弟不能断；<br>索引列上少计算，范围之后全失效；<br>LIKE百分写最右，覆盖索引不写* ；<br>不等空值还有OR，索引影响要注意；<br>VARC引号不可丢，SQL优化有诀窍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" data-id="ckb22iufx009mzwu822zwax6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/Explain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Explain/" class="article-date">
  <time datetime="2020-04-27T01:06:36.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Explain/">Explain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="所使用的数据库"><a href="#所使用的数据库" class="headerlink" title="所使用的数据库"></a><strong>所使用的数据库</strong></h2><pre><code>CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
INSERT INTO t1(content) VALUES(CONCAT(&apos;t1_&apos;,FLOOR(1+RAND() * 1000))); 
INSERT INTO t2(content) VALUES(CONCAT(&apos;t2_&apos;,FLOOR(1+RAND() * 1000))); 
INSERT INTO t3(content) VALUES(CONCAT(&apos;t3_&apos;,FLOOR(1+RAND() * 1000))); 
INSERT INTO t4(content) VALUES(CONCAT(&apos;t4_&apos;,FLOOR(1+RAND() * 1000)));</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分 析你的查询语句或是表结构的性能瓶颈。<br>通过 explain 我们可以知道以下信息：表的读取顺序，数据读取操作的类型，哪些索引可以使用，哪些索引实际使用了，表之间的引用，每张表有多少行被优化器查询等信息。<br>用法： Explain+SQL 语句。<br>Explain 执行后返回的信息：</p>
<pre><code>mysql&gt; explain select * from t1;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+</code></pre><p><strong>explain 有两个变种：</strong></p>
<p>1）explain extended：会在 explain  的基础上额外提供一些查询优化的信息。<br>紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<pre><code>mysql&gt; explain extended select * from t1,t2,t3;
+----+-------------+-------+------+---------------+------+---------+------+------+----------+-------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra             |
+----+-------------+-------+------+---------------+------+---------+------+------+----------+-------------------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 |                   |
|  1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using join buffer |
|  1 | SIMPLE      | t3    | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using join buffer |
+----+-------------+-------+------+---------------+------+---------+------+------+----------+-------------------+
3 rows in set, 1 warning (0.00 sec)
mysql&gt; show warnings
    -&gt; ;
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                                                                                                                                                                       |
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Note  | 1003 | select `db01`.`t1`.`id` AS `id`,`db01`.`t1`.`content` AS `content`,`db01`.`t2`.`id` AS `id`,`db01`.`t2`.`content` AS `content`,`db01`.`t3`.`id` AS `id`,`db01`.`t3`.`content` AS `content` from `db01`.`t1` join `db01`.`t2` join `db01`.`t3` |
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</code></pre><p>2）explain partitions：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h1 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a><strong>explain中的列</strong></h1><h2 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a><strong>1.id</strong></h2><p>select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序。</p>
<p>1.id 相同，执行顺序由上至下 </p>
<pre><code>mysql&gt; explain select * from t1,t2,t3 where t1.id=t2.id and t2.id=t3.id;
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
|  1 | SIMPLE      | t1    | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    1 |       |
|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | db01.t1.id |    1 |       |
|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | db01.t1.id |    1 |       |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
3 rows in set (0.10 sec)</code></pre><p>2.id 不同，id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行 </p>
<pre><code>mysql&gt; EXPLAIN SELECT t1.id FROM t1 WHERE t1.id IN
    -&gt;          (SELECT t2.id FROM t2 WHERE t2.id IN
    -&gt;                  (SELECT t3.id From t3 where t3.content = &apos;&apos;)
    -&gt; );
+----+--------------------+-------+-----------------+---------------+---------+---------+------+------+--------------------------+
| id | select_type        | table | type            | possible_keys | key     | key_len | ref  | rows | Extra                    |
+----+--------------------+-------+-----------------+---------------+---------+---------+------+------+--------------------------+
|  1 | PRIMARY            | t1    | index           | NULL          | PRIMARY | 4       | NULL |    1 | Using where; Using index |
|  2 | DEPENDENT SUBQUERY | t2    | unique_subquery | PRIMARY       | PRIMARY | 4       | func |    1 | Using index; Using where |
|  3 | DEPENDENT SUBQUERY | t3    | unique_subquery | PRIMARY       | PRIMARY | 4       | func |    1 | Using where              |
+----+--------------------+-------+-----------------+---------------+---------+---------+------+------+--------------------------+</code></pre><p>3.有相同也有不同<br>id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行衍生 = DERIVED<br>关注点：id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。</p>
<h2 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2.select_type"></a><strong>2.select_type</strong></h2><p>select_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。 </p>
<table>
<thead>
<tr>
<th>select_type 属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 select 查询,查询中不包含子查询或者 UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里。</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td>DEPEDENT SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询,子查询基于外层</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>无法使用缓存的子查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<p>1) simple：简单查询。查询不包含子查询和union</p>
<pre><code>mysql&gt; explain select * from film where id = 2;
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | film  | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</code></pre><p>2）primary：复杂查询中最外层的 select</p>
<p>3）subquery：包含在 select 中的子查询（不在 from 子句中）</p>
<p>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p>
<p>用这个例子来了解 primary、subquery 和 derived 类型</p>
<pre><code>mysql&gt; explain select (select 1 from t1 where id=1) from (select * from t2 where id=1 ) der;
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+
|  1 | PRIMARY     | &lt;derived3&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 |             |
|  3 | DERIVED     | t2         | const  | PRIMARY       | PRIMARY | 4       |       |    1 |             |
|  2 | SUBQUERY    | t1         | const  | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</code></pre><p>5）union：在 union 中的第二个和随后的 select</p>
<p>6）union result：从 union 临时表检索结果的 select</p>
<h2 id="3-table列"><a href="#3-table列" class="headerlink" title="3.table列"></a><strong>3.table列</strong></h2><p>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 &lt; derivenN&gt; 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为 &lt; union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<h2 id="type列"><a href="#type列" class="headerlink" title="type列"></a><strong>type列</strong></h2><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。</p>
<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL<br><strong>使用的数据库</strong></p>
<pre><code>CREATE TABLE actor (
  id int(11) NOT NULL,
  name varchar(45) DEFAULT NULL,
  update_time datetime DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO actor (id, name, update_time) VALUES (1,&apos;a&apos;,&apos;2017-12-22 15:27:18&apos;), (2,&apos;b&apos;,&apos;2017-12-22 15:27:18&apos;), (3,&apos;c&apos;,&apos;2017-12-22 15:27:18&apos;);

CREATE TABLE film (
  id int(11) NOT NULL AUTO_INCREMENT,
  name varchar(10) DEFAULT NULL,
  PRIMARY KEY (id),
  KEY idx_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO film (id, name) VALUES (3,&apos;film0&apos;),(1,&apos;film1&apos;),(2,&apos;film2&apos;);

CREATE TABLE film_actor (
  id int(11) NOT NULL,
  film_id int(11) NOT NULL,
  actor_id int(11) NOT NULL,
  PRIMARY KEY (id),
  KEY idx_film_actor_id (film_id,actor_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO film_actor (id, film_id, actor_id) VALUES (1,1,1),(2,1,2),(3,2,1);</code></pre><p><strong>NULL：</strong>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p>
<pre><code>mysql&gt; explain select min(id) from film;
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                        |
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Select tables optimized away |
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</code></pre><p><strong>const, system：</strong>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。<br>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p>
<pre><code>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;
+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 |   100.00 | NULL  |
|  2 | DERIVED     | film       | const  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
mysql&gt; show warnings;
+-------+------+---------------------------------------------------------------+
| Level | Code | Message                                                       |
+-------+------+---------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select &apos;1&apos; AS `id`,&apos;film1&apos; AS `name` from dual |
+-------+------+---------------------------------------------------------------+</code></pre><p><strong>eq_ref：</strong>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。<br>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<pre><code>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+
| id | select_type | table      | type   | possible_keys | key               | key_len | ref                     | rows | Extra       |
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+
|  1 | SIMPLE      | film_actor | index  | NULL          | idx_film_actor_id | 8       | NULL                    |    3 | Using index |
|  1 | SIMPLE      | film       | eq_ref | PRIMARY       | PRIMARY           | 4       | test.film_actor.film_id |    1 | NULL        |
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</code></pre><p><strong>ref：</strong>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<p>1.简单 select 查询，name是普通索引（非唯一索引）</p>
<pre><code>mysql&gt; explain select * from film where name = &quot;film1&quot;;
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | film  | ref  | idx_name      | idx_name | 33      | const |    1 | Using where; Using index |
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</code></pre><p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。<br>mysql&gt; explain select * from film left join film_actor on film.id = film_actor.film_id;</p>
<pre><code>+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+
| id | select_type | table      | type  | possible_keys     | key               | key_len | ref          | rows | Extra       |
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+
|  1 | SIMPLE      | film       | index | NULL              | idx_name          | 33      | NULL         |    3 | Using index |
|  1 | SIMPLE      | film_actor | ref   | idx_film_actor_id | idx_film_actor_id | 4       | test.film.id |    1 | Using index |
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</code></pre><p><strong>ref_or_null：</strong>类似ref，但是可以搜索值为NULL的行。</p>
<pre><code>mysql&gt; explain select * from film where name = &quot;film1&quot; or name is null;
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table | type        | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | film  | ref_or_null | idx_name      | idx_name | 33      | const |    2 | Using where; Using index |
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</code></pre><p><strong>index_merge：</strong>表示使用了索引合并的优化方法。 </p>
<p><strong>range：</strong>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<pre><code>mysql&gt; explain select * from actor where id &gt; 1;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | actor | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</code></pre><p><strong>index：</strong>和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。</p>
<pre><code>mysql&gt; explain select count(*) from film;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre><p><strong>ALL：</strong>即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p>
<pre><code>mysql&gt; explain select * from actor;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+</code></pre><h2 id="5-possible-keys列"><a href="#5-possible-keys列" class="headerlink" title="5.possible_keys列"></a><strong>5.possible_keys列</strong></h2><p>这一列显示查询可能使用哪些索引来查找。 </p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </p>
<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
<h2 id="6-key列"><a href="#6-key列" class="headerlink" title="6.key列"></a><strong>6.key列</strong></h2><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。</p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
<h2 id="7-key-len列"><a href="#7-key-len列" class="headerlink" title="7.key_len列"></a><strong>7.key_len列</strong></h2><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>
<p>mysql&gt; explain select * from film_actor where film_id = 2;<br>+—-+————-+————+——+——————-+——————-+———+——-+——+————-+<br>| id | select_type | table      | type | possible_keys     | key               | key_len | ref   | rows | Extra       |<br>+—-+————-+————+——+——————-+——————-+———+——-+——+————-+<br>|  1 | SIMPLE      | film_actor | ref  | idx_film_actor_id | idx_film_actor_id | 4       | const |    1 | Using index |<br>+—-+————-+————+——+——————-+——————-+———+——-+——+————-+</p>
<p>key_len计算规则如下：</p>
<pre><code>字符串
    char(n)：n字节长度
    varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2
数值类型
    tinyint：1字节
    smallint：2字节
    int：4字节
    bigint：8字节　　
时间类型　
    date：3字节
    timestamp：4字节
    datetime：8字节
如果字段允许为 NULL，需要1字节记录是否为 NULL</code></pre><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<h2 id="8-ref列"><a href="#8-ref列" class="headerlink" title="8.ref列"></a><strong>8.ref列</strong></h2><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>
<h2 id="9-rows列"><a href="#9-rows列" class="headerlink" title="9.rows列"></a><strong>9.rows列</strong></h2><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。越少越好！</p>
<h2 id="10-Extra列"><a href="#10-Extra列" class="headerlink" title="10.Extra列"></a><strong>10.Extra列</strong></h2><p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>distinct: 一旦mysql找到了与行相联合匹配的行，就不再搜索了</p>
<p>Using index：代表表示相应的 select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！ 如果同时出现 using where，表明索引被用来执行索引键值的查找;如果没有同时出现 using where，表明索引只是 用来读取数据而非利用索引执行查找。 利用索引进行了排序或分组。是性能高的表现。</p>
<p>Using where：表明使用了 where 过滤</p>
<p>Using temporary：使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<p>1.actor.name没有索引，此时创建了张临时表来distinct</p>
<pre><code>mysql&gt; explain select distinct name from actor;
+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra           |
+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using temporary |
+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</code></pre><p>2.film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</p>
<pre><code>mysql&gt; explain select distinct name from film;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | idx_name      | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre><p>Using filesort：mysql 会对结果使用一个外部索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<p>1.actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</p>
<pre><code>mysql&gt; explain select * from actor order by name;
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using filesort |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</code></pre><p>2.film.name建立了idx_name索引,此时查询时extra是using index</p>
<pre><code>mysql&gt; explain select * from film order by name;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Explain/" data-id="ckb22iufn008mzwu800ygac9m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/Mysql索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2020-04-24T13:20:36.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95/">Mysql索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a><strong>索引的概念</strong></h2><p><strong>索引是什么</strong><br>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。可以简单理解为排好序的快速查找数据结构。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：<br><img src="/images/248.png" alt=""><br>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。<br>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。   </p>
<p><strong>优缺点</strong><br>优势：</p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本。 </li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。<br>劣势：</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为 更新所带来的键值变化后的索引信息。 </li>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。 </li>
</ul>
<h2 id="Mysql-的索引-实现方式"><a href="#Mysql-的索引-实现方式" class="headerlink" title="Mysql 的索引(实现方式)"></a><strong>Mysql 的索引(实现方式)</strong></h2><h3 id="1-B-tree-索引"><a href="#1-B-tree-索引" class="headerlink" title="1.B-tree 索引"></a><strong>1.B-tree 索引</strong></h3><p>B-树指的就是B树<br><img src="/images/249.png" alt=""><br><strong>【初始化介绍】</strong><br>一颗 b-树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）<br>如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3，<br>P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。<br>真实的数据存在于任何节点<br>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败<br>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质</p>
<h3 id="2-B-tree-索引"><a href="#2-B-tree-索引" class="headerlink" title="2.B+tree 索引"></a><strong>2.B+tree 索引</strong></h3><p>Mysql就是使用的B+tree<br><strong>B+Tree 与 B-Tree 的区别</strong><br>1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。<br>2）在 B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。<br>从这个角度看 B- 树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比 B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br><img src="/images/250.png" alt=""><br><img src="/images/253.png" alt=""><br><strong>B+树的查找原则：</strong><br>1、从节点最左边的搜索码值开始，向右遍历<br>2、如果搜索码值大于被查找值，则跳到搜索码值左边指针指向的节点<br>3、如果等于，则跳到右边指针指向的节点<br>4、如果小于，则遍历下一个搜索码值<br>5、如果遍历完了整个节点，还是没发现有大于等于被查找值的搜索码，则跳到该节点最后一个非空指针指向的节点<br>6、不断循环，直到找到被查找值，或者发现被查找值不存在</p>
<p><strong>思考：</strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p>
<p>1) B+树的磁盘读写代价更低<br>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B-树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。<br>2) B+树的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 </p>
<p>虽然都是B+树索引，但是存储引擎使用它们的方式不同，以我们最常用的俩个引擎为例，在MyISAM中以前缀压缩技术使得索引占用更小并通过数据的物理位置引用被索引的行，而在InnoDB中则按原格式存储并根据主键引用被索引的行</p>
<h3 id="HASH索引"><a href="#HASH索引" class="headerlink" title="HASH索引"></a><strong>HASH索引</strong></h3><p>哈希索引基于hash表实现，类似于Java中的HashMap，通过计算key的hash值映射对应的value，在不发生hash冲突的情况下时间复杂度为常数级别，MySQL的hash索引会对所有的索引列计算一个hash码，由于hash的索引的特点，它的缺点也显而易见，只有精确匹配索引所有列的查询才有效，hash索引数据也并不是按照索引值顺序存储的，所以也无无法用于排序，只支持等值查询，不支持范围查询。他是Memory引擎的默认索引类型，也是Memory引擎速度快的原因之一。</p>
<p>在InnoDB有一个特殊的功能叫做自适应哈希索引，当它发现某些索引值被使用的非常频繁时，它会在内存中基于B+树索引之上再创建一个hash索引，加快数据的查找速度。<br>1、哈希索引：<br>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p>
<h3 id="全文索引："><a href="#全文索引：" class="headerlink" title="全文索引："></a><strong>全文索引：</strong></h3><p>FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。<br>FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：</p>
<pre><code>//创建表的时候添加FULLTEXT索引
CTREATE TABLE my_table(
    id INT(10) PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    my_text TEXT,
    FULLTEXT(my_text)
)ENGINE=MyISAM DEFAULT CHARSET=utf8;
//创建表以后，在需要的时候添加FULLTEXT索引
ALTER TABLE my_table ADD FULLTEXT INDEX ft_index(column_name);</code></pre><p>全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法</p>
<p>SELECT * FROM table_name MATCH(ft_index) AGAINST(‘查询字符串’);</p>
<p><strong>注意：</strong></p>
<p>对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。<br>5.6版本前的MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。5.6版本之后InnoDB存储引擎开始支持全文索引<br>在MySQL中，全文索引仅对英文有用，目前对中文还不支持。5.7版本之后通过使用ngram插件开始支持中文。<br>在MySQL中，如果检索的字符串太短则无法检索得到预期的结果，检索的字符串长度至少为4字节，此外，如果检索的字符包括停止词，那么停止词会被忽略。</p>
<h2 id="Mysql索引的几个知识点"><a href="#Mysql索引的几个知识点" class="headerlink" title="Mysql索引的几个知识点"></a><strong>Mysql索引的几个知识点</strong></h2><p><strong>复合索引</strong></p>
<p>上面讲的只是单索引，那么如果是复合索引呢？<br>create index id_name_subject on teacher(name, subject);<br>两个或更多个列上的索引被称作复合索引。<br>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。<br>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。<br>所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p>
<p><strong>最左前缀匹配</strong><br>弄懂了单索引和复合索引的原理，再来理解Mysql中经常被提及的——最左前缀匹配（leftmost prefix），就轻松的多了。<br>什么是最左前缀匹配？简单说，就是你给一个表的a，b，c三个字段建了索引：<br>create index id_a_b_c on foo(a, b, c);<br>那么当你where条件是a或者a、b或者a、b、c时，都可以命中索引，除此之外，都不能命中索引，比如a、c，或者b、c等。<br>为什么？看看上面的单索引和复合索引就知道了。<br>有一个例外，当你select的字段里有复合索引里的字段，那么where语句不需要满足最左前缀匹配，Mysql也会走索引。<br>比如：<br>select a from foo where b = “xxx”;<br>不过这时走索引不是为了加速查询（这时候索引对查询效率提升效果几乎没有），而是为了利用下面要讲的，覆盖索引，来减少对数据的检索。</p>
<p><strong>覆盖索引</strong><br>覆盖索引：SQL只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据</p>
<p>覆盖索引（covering index）的原理很简单，就像你拿到了一本书的目录，里头有标题和对应的页码，当你想知道第267页的标题是什么的时候，完全没有必要翻到267页去看，而是直接看目录。<br>同理，当你要select的字段，已经在索引树里面存储，那就不需要再去检索数据库，直接拿来用就行了。</p>
<p>还是上面的例子，你给a、b、c三个字段建了复合索引，那么对于下面这条sql，就可以走覆盖索引:<br>select b,c from foo where a = “xxx”;<br>再来看看什么是覆盖索引，有下面三种理解：</p>
<ul>
<li>就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li>
<li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。</li>
<li>是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。</li>
</ul>
<p>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引</p>
<p>当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在EXPLAIN的Extra列可以看到“Using index”的信息。</p>
<p>不同的存储引擎实现覆盖索引都是不同的，并不是所有的存储引擎都支持覆盖索引。</p>
<p>如果要使用覆盖索引，一定要注意SELECT列表值取出需要的列，不可以SELECT * ，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降</p>
<p>现在问一个问题，下面这条sql，会走覆盖索引吗？还是需要去磁盘再一次检索？<br>select id,b,c from foo where a = “xxx”;<br>和上一条sql对比，这一次我们在select里头，加了一个字段，主键id。</p>
<p>有同学说，id不在复合索引里，B+树没有id的信息，只能再查一次数据库了。<br>非也，在上面介绍B+ tree时有提到过，叶子节点不会直接存储数据的位置，而是存储了聚簇索引（clustered index）的值，再通过聚簇索引，找到数据对应的位置。</p>
<p><strong>聚簇索引（主键索引）</strong><br>Every InnoDB table has a special index called the clustered index where the data for the rows is stored.</p>
<p>简单说，聚簇索引就是用来存储行数据的位置的。</p>
<p>什么样的字段才可以作为聚簇索引？<br>那当然是要具有唯一性的字段，比如：主键、唯一索引（unique index）所在字段</p>
<p>这两个都没有？没关系，mysql会给你建一个rowid字段，用它作为聚簇索引：<br>If the table has no PRIMARY KEY or suitable UNIQUE index, InnoDB internally generates a hidden clustered index named GEN_CLUST_INDEX on a synthetic column containing row ID values.</p>
<p><strong>二级索引(辅助索引)</strong><br>除了聚簇索引，mysql中的其他索引，都叫二级索引（secondary index），有时也翻译为“辅助索引”。<br>All indexes other than the clustered index are known as secondary indexes.</p>
<p>回到本小节开头的问题，虽然id不在复合索引里头，但是mysql里所有的二级索引的叶子节点，都会存储聚簇索引的信息，而id是主键，所以所有的叶子节点，都会有id的信息，因此还是可以走覆盖索引。</p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a><strong>聚簇索引和非聚簇索引</strong></h2><p>聚簇索引和非聚簇索引<br>分析了MySQL的索引结构的实现原理，然后我们来看看具体的存储引擎怎么实现索引结构的，MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。</p>
<p><strong>聚簇索引的解释是:</strong>聚簇索引的顺序就是数据的物理存储顺序<br><strong>非聚簇索引的解释是:</strong>索引顺序与数据物理排列顺序无关<br>（这样说起来并不好理解，让人摸不着头脑，清继续看下文，并在插图下方对上述两句话有解释）<br>首先要介绍几个概念，在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。</p>
<p><strong>MyISAM——非聚簇索引</strong></p>
<p>MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。<br>非聚簇索引的数据表和索引表是分开存储的。<br>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</p>
<p><strong>InnoDB——聚簇索引</strong><br>InnoDB中主键就是聚簇索引，谁是主键谁就是聚簇索引。没有主键给你隐式地定义一个主键。</p>
<p>聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。<br>聚簇索引的数据和主键索引存储在一起。<br>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。<br>在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</p>
<p>使用主索引的时候，更适合使用聚簇索引，因为聚簇索引只需要查找一次，而非聚簇索引在查到数据的地址后，还要进行一次I/O查找数据。<br>因为聚簇辅助索引存储的是主键的键值，因此可以在数据行移动或者页分裂的时候降低成本，因为这时不用维护辅助索引。但是由于主索引存储的是数据本身，因此聚簇索引会占用更多的空间。<br>聚簇索引在插入新数据的时候比非聚簇索引慢很多，因为插入新数据时需要检测主键是否重复，这需要遍历主索引的所有叶节点，而非聚簇索引的叶节点保存的是数据地址，占用空间少，因此分布集中，查询的时候I/O更少，但聚簇索引的主索引中存储的是数据本身，数据占用空间大，分布范围更大，可能占用好多的扇区，因此需要更多次I/O才能遍历完毕。</p>
<ul>
<li>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。</li>
<li>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</li>
</ul>
<p>下图可以形象的说明聚簇索引和非聚簇索引的区别<br><img src="/images/254.png" alt=""><br><img src="/images/255.png" alt=""></p>
<p>从上图中可以看到聚簇索引的辅助索引的叶子节点的data存储的是主键的值，主索引的叶子节点的data存储的是数据本身，也就是说数据和索引存储在一起，并且索引查询到的地方就是数据（data）本身，那么索引的顺序和数据本身的顺序就是相同的；</p>
<p>而非聚簇索引的主索引和辅助索引的叶子节点的data都是存储的数据的物理地址，也就是说索引和数据并不是存储在一起的，数据的顺序和索引的顺序并没有任何关系，也就是索引顺序与数据物理排列顺序无关。</p>
<h2 id="Mysql-索引分类"><a href="#Mysql-索引分类" class="headerlink" title="Mysql 索引分类"></a><strong>Mysql 索引分类</strong></h2><p><strong>1.单值索引</strong><br>概念：即一个索引只包含单个列，一个表可以有多个单列索引<br>语法：<br>所表一起创建： </p>
<pre><code>CREATE TABLE customer (
id INT(10) UNSIGNED AUTO_INCREMENT ,
customer_no VARCHAR(200),
customer_name VARCHAR(200), 
PRIMARY KEY(id), 
KEY (customer_name) 
);</code></pre><p>单独建单值索引：<br>CREATE INDEX idx_customer_name ON customer(customer_name); </p>
<p><strong>2.唯一索引</strong><br>概念：索引列的值必须唯一，但允许有空值<br>随表一起创建： </p>
<pre><code>CREATE TABLE customer (id INT(10) UNSIGNED 
AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name 
VARCHAR(200), 
PRIMARY KEY(id), 
KEY (customer_name), 
UNIQUE (customer_no) 
);</code></pre><p>单独建唯一索引：<br>CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no); </p>
<p><strong>主键索引</strong><br>概念：设定为主键后数据库会自动建立索引，innodb为聚簇索引<br>随表一起建索引  </p>
<pre><code>CREATE TABLE customer (id INT(10) UNSIGNED 
AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name 
VARCHAR(200), 
PRIMARY KEY(id) 
);</code></pre><p>单独建主键索引：<br>ALTER TABLE customer add PRIMARY KEY index_cn(customer_no);<br>删除建主键索引：<br>ALTER TABLE customer drop PRIMARY KEY ;<br>修改建主键索引：<br>必须先删除掉(drop)原索引，再新建(add)索引 </p>
<p><strong>复合索引</strong><br>概念：即一个索引包含多个列<br>随表一起建索引： </p>
<pre><code>CREATE TABLE customer (id INT(10) UNSIGNED 
AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name 
VARCHAR(200), 
PRIMARY KEY(id), 
KEY (customer_name), 
UNIQUE (customer_name), 
KEY (customer_no,customer_name) 
);</code></pre><p>单独建索引：<br>CREATE INDEX idx_no_name ON customer(customer_no,customer_name); </p>
<p><strong>基本语法</strong><br><img src="/images/252.png" alt=""></p>
<h2 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a><strong>索引的删除</strong></h2><p><strong>1.使用  ALTER  TABLE  语句删除索引</strong><br>    语法格式：</p>
<pre><code>ALTER  TABLE  table_name   DROP  INDEX  index_name;</code></pre><p><strong>2.使用  DROP  INDEX  语句删除索引</strong><br>    语法格式：</p>
<pre><code>DROP   INDEX   index_name  ON  table_name;</code></pre><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a><strong>查看索引</strong></h2><pre><code>SHOW INDEX FROM &lt;表名&gt; [ FROM &lt;数据库名&gt;]</code></pre><h2 id="索引的创建时机"><a href="#索引的创建时机" class="headerlink" title="索引的创建时机"></a><strong>索引的创建时机</strong></h2><p><strong>什么时候要使用索引？</strong></p>
<ul>
<li>主键自动建立唯一索引；</li>
<li>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；</li>
<li>作为排序的列要建立索引；</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>高并发条件下倾向组合索引；</li>
<li>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</li>
</ul>
<p><strong>什么时候不要使用索引？</strong></p>
<ul>
<li>经常增删改的列不要建立索引；</li>
<li>有大量重复的列不建立索引；</li>
<li>表记录太少不要建立索引。只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快–不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95/" data-id="ckb22iufs0095zwu82cd35f00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux/linux入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/Linux/linux%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-04-21T13:53:15.000Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/Linux/linux%E5%85%A5%E9%97%A8/">linux入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Linux的目录结构："><a href="#Linux的目录结构：" class="headerlink" title="Linux的目录结构："></a><strong>Linux的目录结构：</strong></h2><p><img src="/images/238.png" alt="">   </p>
<ul>
<li>root管理员的home目录root</li>
<li>其他用户的home目录home目录中</li>
</ul>
<h2 id="Linux的常用命令"><a href="#Linux的常用命令" class="headerlink" title="Linux的常用命令"></a><strong>Linux的常用命令</strong></h2><p><strong>1.切换目录命令cd：</strong></p>
<ul>
<li>cd app    切换到app目录</li>
<li>cd ..    切换到上一层目录</li>
<li>cd /    切换到系统根目录</li>
<li>cd ~    切换到用户主目录</li>
<li>cd -    切换到上一个所在目录</li>
</ul>
<p>使用tab键来补全文件路径</p>
<p><strong>2.列出文件列表：ls ll</strong><br>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。<br>格式：ls[参数] [路径或文件名]<br>常用：在linux中以 . 开头的文件都是隐藏的文件</p>
<ul>
<li>ls</li>
<li>ls -a  显示所有文件或目录（包含隐藏的文件）</li>
<li>ls -l  缩写成ll，显示详细信息</li>
</ul>
<p><strong>3.创建目录和移除目录：mkdir rmdir</strong></p>
<ul>
<li>mkdir app ：在当前目录下创建app目录</li>
<li>mkdir –p app2/test ：级联创建aap2以及test目</li>
<li>rmdir app ： 删除app目录，只能删除空的目录</li>
</ul>
<p><strong>4.浏览文件</strong><br>【cat、more、less、tail】<br>cat用于显示文件的内容。格式：cat[参数]&lt;文件名&gt;</p>
<ul>
<li>cat yum.conf</li>
</ul>
<p>more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。<br>回车显示下一行内容。按 q 键退出查看。</p>
<ul>
<li>more yum.conf   ：空格显示下一页数据  回车显示下一行的数据</li>
</ul>
<p>less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。</p>
<ul>
<li>less yum.conf  :PgUp 和 PgDn 进行上下翻页.</li>
</ul>
<p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。<br>用法:</p>
<ul>
<li>tail -10 /etc/passwd  :查看后10行数据</li>
<li>tail -f catalina.log  :动态查看日志(*****)</li>
</ul>
<p>ctrl+c 结束查看</p>
<h2 id="5-文件操作："><a href="#5-文件操作：" class="headerlink" title="5.文件操作："></a><strong>5.文件操作：</strong></h2><p><strong>【rm】</strong><br>rm  删除文件</p>
<ul>
<li>rm a.txt  :删除a.txt文件,删除需要用户确认，y/n</li>
<li>rm -f a.txt  :不询问，直接删除</li>
<li>rm -r a  :删除目录，递归删除</li>
<li>rm -rf  a  :不询问递归删除</li>
<li>rm -rf *   : 删除所有文件</li>
<li>rm -rf /*   : 自杀</li>
</ul>
<p><strong>【cp、mv】</strong><br>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<ul>
<li>cp a.txt b.txt  :将a.txt复制为b.txt文件,也就是拷贝加重命名</li>
<li>cp a.txt ../  :将a.txt文件复制到上一层目录中</li>
</ul>
<p>mv 移动或者重命名</p>
<ul>
<li>mv a.txt ../  :将a.txt文件移动到上一层目录中</li>
<li>mv a.txt b.txt  :将a.txt文件重命名为b.txt</li>
</ul>
<p><strong>【tar】命令:(打包或解压)</strong><br>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：<br>-c：创建一个新tar文件<br>-v：显示运行过程的信息<br>-f：指定文件名<br>-z：调用gzip压缩命令进行压缩<br>-t：查看压缩文件的内容<br>-x：解开tar文件</p>
<ul>
<li><p>打包：tar –cvf xxx.tar ./*</p>
</li>
<li><p>打包并且压缩：tar –zcvf xxx.tar.gz ./* </p>
</li>
<li><p>解压：tar –xvf xxx.tar</p>
</li>
<li><p>解压压缩文件：tar -zxvf xxx.tar.gz -C /usr/aaa  并且将解压的结果放到/usr/aaa目录下</p>
</li>
</ul>
<p><strong>【find】命令</strong><br>find指令用于查找符合条件的文件<br>示例：</p>
<ul>
<li>find / -name “ins* ” 查找文件名称是以ins开头的文件，* 为通配符</li>
<li>find / -name “ins* ” –ls </li>
<li>find / –user itcast –ls 查找用户itcast的文件</li>
<li>find / –user itcast –type d –ls 查找用户itcast的目录</li>
<li>find /-perm -777 –type d-ls 查找权限是777的文件</li>
</ul>
<p><strong>【grep】命令</strong><br>查找文件里符合条件的字符串。<br>grep lang anaconda-ks.cfg  在文件中查找lang<br>grep lang anaconda-ks.cfg –color 高亮显示</p>
<p><strong>6.其他常用命令</strong><br>【pwd】<br>显示当前所在目录</p>
<p>【touch】<br>创建一个空文件</p>
<ul>
<li>touch a.txt</li>
</ul>
<p>【clear/ crtl + L】<br>清屏</p>
<h2 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a><strong>Vi和Vim编辑器</strong></h2><p><strong>1.Vim编辑器：</strong><br>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。</p>
<p>切换到命令行模式：按Esc键；<br>切换到插入模式：按 i 、o、a键；</p>
<ul>
<li>i 在当前位置前插入</li>
<li>I 在当前行首插入</li>
<li>a 在当前位置后插入</li>
<li>A 在当前行尾插入</li>
<li>o 在当前行之后插入一行</li>
<li>O 在当前行之前插入一行</li>
</ul>
<p>切换到底行模式：按 :（冒号）</p>
<ul>
<li>打开文件：vim file</li>
<li>退出：esc  :q</li>
<li>修改文件：输入i进入插入模式</li>
<li>保存并退出：esc:wq</li>
<li>不保存退出：esc:q!</li>
</ul>
<p>快捷键：</p>
<ul>
<li>dd – 快速删除一行</li>
<li>yy - 复制当前行</li>
<li>nyy - 从当前行向后复制几行</li>
<li>p - 粘贴</li>
<li>R – 替换</li>
</ul>
<p><strong>2.重定向输出&gt;和&gt;&gt;</strong><br>    &gt; 重定向输出，覆盖原有内容；<br>    &gt;&gt; 重定向输出，又追加功能；<br>示例：</p>
<ul>
<li>cat /etc/passwd &gt; a.txt  将输出定向到a.txt中</li>
<li>cat /etc/passwd &gt;&gt; a.txt  输出并且追加</li>
<li>ifconfig &gt; ifconfig.txt</li>
</ul>
<p><strong>3.系统管理命令</strong></p>
<ul>
<li>ps 正在运行的某个进程的状态</li>
<li>ps –ef  查看所有进程</li>
<li>ps –ef | grep java 查找某一进程</li>
<li>kill 2868  杀掉2868编号的进程</li>
<li>kill -9 2868  强制杀死进程</li>
</ul>
<p><strong>4.管道 |</strong><br>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例</p>
<ul>
<li>ls –help | more  分页查询帮助信息</li>
<li>ps –ef | grep java  查询名称中包含java的进程</li>
<li>ifconfig | more</li>
<li>cat index.html | more</li>
<li>ps –ef | grep aio</li>
</ul>
<h2 id="Linux的权限命令"><a href="#Linux的权限命令" class="headerlink" title="Linux的权限命令"></a><strong>Linux的权限命令</strong></h2><p><strong>1.文件权限</strong><br><img src="/images/239.png" alt=""><br><img src="/images/240.png" alt="">  </p>
<ul>
<li>r:read对文件是指可读取内容 对目录是可以ls</li>
<li>w:write对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</li>
<li>x:excute对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</li>
</ul>
<p><strong>2.Linux三种文件类型：</strong><br>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。<br>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。<br>设备文件： Linux系统把每一个设备都看成是一个文件<br><strong>3.文件类型标识</strong><br>普通文件（-）<br>目录（d）<br>符号链接（l）进入etc可以查看，相当于快捷方式<br>字符设备文件（c）<br>块设备文件（s）<br>套接字（s）<br>命名管道（p）</p>
<p><strong>4.文件权限管理：</strong></p>
<ul>
<li>chmod 变更文件或目录的权限。</li>
<li>chmod u=rwx,g=rx,o=rx a.txt</li>
<li>chmod 755 a.txt  解释：r=4,w=2,x=1</li>
</ul>
<h2 id="Linux上常用网络操作"><a href="#Linux上常用网络操作" class="headerlink" title="Linux上常用网络操作"></a><strong>Linux上常用网络操作</strong></h2><p><strong>1.主机名配置</strong><br>hostname 查看主机名<br>hostname xxx 修改主机名 重启后无效<br>如果想要永久生效，可以修改/etc/sysconfig/network文件</p>
<p><strong>2.IP地址配置</strong><br>ifconfig 查看(修改)ip地址(重启后无效)<br>ifconfig eth0 192.168.12.22 修改ip地址<br>如果想要永久生效<br>修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件<br>DEVICE=eth0 #网卡名称<br>BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none)<br>HWADDR=00:0C:29:B5:B2:69 #MAC地址<br>IPADDR=12.168.177.129 #IP地址<br>NETMASK=255.255.255.0 #子网掩码<br>NETWORK=192.168.177.0 #网络地址<br>BROADCAST=192.168.0.255 #广播地址<br>NBOOT=yes #  系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。</p>
<p><strong>3.域名映射</strong><br>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用<br>相当于windows系统的C:\Windows\System32\drivers\etc\hosts文件的功能</p>
<p><strong>4.网络服务管理</strong></p>
<ul>
<li>service network status 查看指定服务的状态</li>
<li>service network stop 停止指定服务</li>
<li>service network start 启动指定服务</li>
<li>service network restart 重启指定服务</li>
<li>service –status–all 查看系统中所有后台服务</li>
<li>netstat –nltp 查看系统中网络进程的端口监听情况</li>
</ul>
<p>防火墙设置<br>防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。</p>
<ul>
<li>service iptables status 查看防火墙状态</li>
<li>service iptables stop 关闭防火墙</li>
<li>service iptables start 启动防火墙</li>
<li>chkconfig  iptables off 禁止防火墙自启</li>
</ul>
<h2 id="Linux上软件安装"><a href="#Linux上软件安装" class="headerlink" title="Linux上软件安装"></a><strong>Linux上软件安装</strong></h2><p><strong>Linux上的软件安装有以下几种常见方式介绍</strong><br>1.二进制发布包<br>软件已经针对具体平台编译打包发布，只要解压，修改配置即可<br>2.RPM包<br>软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装<br>3.Yum在线安装<br>软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题<br>4.源码编译安装<br>软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。<br>上传与下载工具介绍<br>1.FileZilla<br><img src="/images/241.png" alt="">  </p>
<p>2.lrzsz<br>我们可以使用yum安装方式安装 yum install lrzsz<br>注意：必须有网络<br>可以在crt中设置上传与下载目录<br><img src="/images/242.png" alt=""> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/21/Linux/linux%E5%85%A5%E9%97%A8/" data-id="ckb22iue0002pzwu84thr48x6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>