<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://tukuai.github.io/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Tukuai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-LeetCode/剑指-青蛙跳台" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0/" class="article-date">
  <time datetime="2020-03-31T15:10:16.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0/">剑指-青蛙跳台</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：2<br>示例 2：</p>
<p>输入：n = 7<br>输出：21</p>
<p>提示：<br>0 &lt;= n &lt;= 100</p>
<p><strong>解法1：递归</strong></p>
<pre><code>class Solution {
    int sum=0;
    public int numWays(int n) {
        jump(n);
        return sum;
    }
    public void jump(int n)
    {
        if(n&lt;0)
        return;
        if(n==0)
        {
            sum++;

        }
        jump(n-1);
        jump(n-2);
    }
}</code></pre><p>算到n=41用时3003毫秒</p>
<p><strong>解法二：斐波那契数列</strong></p>
<pre><code>class Solution {
    public int numWays(int n) {
       if(n==0)
       return 1;
       if(n==1)
       return 1;
        int fn1=1;
        int fn2=1;
        int fn=0;
        for(int i=2;i&lt;=n;i++)
        {
            fn=fn1+fn2;
            fn1=fn2;
            fn2=fn&gt;1000000007?fn-1000000007:fn;
        }
        return fn2;
    }
}</code></pre><p>算到n=41用时0毫秒</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0/" data-id="ckb22iue7003fzwu8dl22g6s8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-Java虚拟机/垃圾回收" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time datetime="2020-03-31T13:48:09.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="垃圾回收Garbage-Collection"><a href="#垃圾回收Garbage-Collection" class="headerlink" title="垃圾回收Garbage Collection"></a><strong>垃圾回收Garbage Collection</strong></h1><ol>
<li>如何判断对象可以回收</li>
<li>垃圾回收算法</li>
<li>分代垃圾回收</li>
<li>垃圾回收器</li>
<li>垃圾回收调优</li>
</ol>
<h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a><strong>如何判断对象可以回收</strong></h2><p><strong>1.引用计数法</strong><br>多出一个对象引用，则引用计数加一，少一个就减一，当其引用计数变为零的时候，就可以被当为垃圾回收了。<br>存在重要的弊端：循环引用问题。<br><img src="/images/171.png" alt=""><br>当A对象引用B对象，而B对象引用A对象，但是没有别的对象再去引用他们两，本身他们俩都不会被使用了，但是不能被垃圾回收了。<br>Python使用的就是该机制，而java使用的是可达性分析算法。</p>
<p><strong>2.可达性分析算法</strong></p>
<ul>
<li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能够沿着 GC Root(根对象：可以理解为肯定不能被当成垃圾的对象)对象为起点的引用链找到该对象，找不到，表示可以回收，也就是说该对象是否被根对象直接或者间接的引用。不是的话就可以被回收了。</li>
<li>GC Root:GC Roots基本思路就是通过一系列的称为“GC Roots”的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为引用链（Reference    Chain），当一个对象到 GC Roots 没有任何引用链相连（ 用图论的话来 说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</li>
<li>哪些对象可以作为 GC Root ?<ul>
<li>使用eclipse提供的Memory Analyzer(MAT)工具</li>
<li>需要与jmap结合使用，先用terminal指令：jmap -dump:format=b,live,file=文件名  进程id</li>
<li>format=b代表二进制,live代表截取存活对象会主动使用一次垃圾回收。文件名会自动生成文件后缀为bin，如1.bin</li>
<li>再在MAT里打开bin文件，可以查看到根对象<br><img src="/images/172.png" alt=""></li>
</ul>
<ol>
<li>System Class  </li>
<li>Native Stack，操作系统方法在调用时所引用的java对象</li>
<li>Thread，而且活动线程中局部变量所引用的对象如：New ArrayList().。注意这里指的是堆内存中的对象，而不是栈帧中的引用，如List<Integer> list1=new Arraylist().其中list1为引用，而New ArrayList()为对象</li>
<li>Busy Monitor，如线程锁对象，也是不能被回收的</li>
</ol>
</li>
</ul>
<hr>
<p><strong>四种引用</strong><br><img src="/images/173.png" alt=""><br>实线代表：强引用<br>虚线代表：其他四类引用</p>
<ol>
<li>强引用<br>我们平时所用的所有引用都几乎是强引用，能根据GCROOT通过强引用找到该对象的话，该对象都是不能被回收的。<br>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
<li>软引用（SoftReference）<br>仅由软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象，即使该对象被Root对象<strong>间接</strong>引用。<br> <strong>可以配合</strong>引用队列来释放软引用自身，软引用和弱引用都可以放到引用队列中，在垃圾释放的时候较为容易找到并释放。</li>
<li>弱引用（WeakReference）<br>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象，即使该对象被Root对象<strong>间接</strong>引用。<br> <strong>可以配合</strong>引用队列来释放弱引用自身</li>
<li>虚引用（PhantomReference）<br> <strong>必须配合</strong>引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法(Unsafe freeMemory)释放<strong>直接内存</strong>。</li>
<li>终结器引用（FinalReference）<br> <strong>必须配合</strong>引用队列使用</li>
</ol>
<ul>
<li>Object父类里都有一个叫做finallize()方法，终结方法，当对象重写这个方法，并且没有强引用引用时就可以被当作垃圾回收。</li>
<li>重写终结方法的目的就是该对象在垃圾回收时被调用。靠的就是终结器引用达到这个目的</li>
<li>当没有Root对象引用该对象时，JVM就会分配终结器引用引用该对象，当垃圾回收时可以调用终结方法。</li>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的 finalize方法，<strong>第二次 GC 时才能回收被引用对象</strong></li>
<li>所以第一次GC不会回收该对象，必须等到第二次GC</li>
<li>Finalizer线程的优先级非常低，所以可能导致终结方法迟迟不能被调用，所以这个对象占用的内存也有可能迟迟不能得到释放。</li>
<li><strong>所以不推荐使用该方法</strong></li>
</ul>
<p><strong>软(弱)引用应用</strong><br>比如我们在读取图片到list集合，但是图片资源不属于核心业务资源，若使用强引用引用该图片资源，导致内存不足，这时候可以考虑软引用或者弱引用<br>区别在于：List&lt; byte[]&gt; list = new ArrayList&lt;&gt;();和List&lt;SoftReference&lt; byte[]&gt;&gt; list = new ArrayList&lt;&gt;();<br>也就是说list先引用软引用对象，软引用对象再引用该对象</p>
<p><strong>软引用实例：：</strong></p>
<pre><code>    public class Demo2_4 {
private static final int _4MB = 4 * 1024 * 1024;
public static void main(String[] args) {
    List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
    // 引用队列
     ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
    for (int i = 0; i &lt; 5; i++) {
        // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
        SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
        System.out.println(ref.get());
        list.add(ref);
        System.out.println(list.size());
    }
    // 从队列中获取无用的 软引用对象，并移除
    Reference&lt;? extends byte[]&gt; poll = queue.poll();
    while( poll != null) {
        list.remove(poll);
        poll = queue.poll();
    }
    System.out.println(&quot;===========================&quot;);
    for (SoftReference&lt;byte[]&gt; reference : list) {
        System.out.println(reference.get());
    }
}</code></pre><p><strong>弱引用实例：：</strong></p>
<pre><code>/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+&quot; &quot;);
            }
            System.out.println();
        }
        System.out.println(&quot;循环结束：&quot; + list.size());
    }
}</code></pre><hr>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a><strong>标记清除</strong></h3><p>定义： Mark Sweep<br><img src="/images/183.png" alt=""><br>清除内存的原理：找到没root引用的内存地址，将地址放入地址列表中，下次需要使用内存空间时候，可以直接将该地址当做空闲地址，覆盖掉。<br><strong>特点</strong></p>
<ul>
<li>速度较快</li>
<li>会造成内存碎片，因为将内存分为许多段，造成空间不连续，需要较大空间时，无法正常分配。</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a><strong>标记整理</strong></h3><p>定义：Mark Compact<br><img src="/images/184.png" alt=""><br>将引用的的内存进行移动，使他们排列在一起。<br>特点：</p>
<ul>
<li>速度慢，因为移动地址后，引用该对象的地址都需要加以改变。</li>
<li>没有内存碎片</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a><strong>复制</strong></h3><p>定义：Copy<br>将内存划分为两个区域，一个from，一个to，to区域先不存放数据。<br>先将from区域的被引用对象标记，再紧列复制到to区域，在复制的过程中就完成了内存的整理。然后将from全部清空。然后调换from和to<br><strong>特点</strong></p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用双倍内存空间</li>
</ul>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a><strong>分代垃圾回收</strong></h3><p><strong>虚拟机不会单独采用一种算法，而是将三种算法协同使用。</strong><br><img src="/images/185.jpg" alt=""></p>
<ul>
<li>经常使用的对象存放在老年代中，而朝生夕死的对象放在新生代之中，有利于对内存更好地管理。</li>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间不足时，触发 minor gc(新生代垃圾回收)，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1，并且交换 from to的位置， minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit），因为寿命是存在对象的寿命头中，而对象头只有4个bit。</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，因为老年代用的不是复制算法，而是标志+清除或者标志+整理。如果说老年代垃圾回收之后内存还是不够用，就会out of memory error</li>
<li>当大对象需要放入新生代，但新生代空间肯定不够的时候，会直接放入空间足够的老年代而不会触发GC，若老年代也不放不下就会先新生代垃圾回收，再FullGC，若是还不够，就会out of memory</li>
<li>次线程的out of memory不会导致主线程的终止。</li>
</ul>
<h2 id="相关-VM-参数"><a href="#相关-VM-参数" class="headerlink" title="相关 VM 参数"></a><strong>相关 VM 参数</strong></h2><pre><code>含义                     参数
堆初始大小                 -Xms
堆最大大小                 -Xmx 或 -XX:MaxHeapSize=size
新生代大小                 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )
幸存区比例（动态）         -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy
幸存区比例               -XX:SurvivorRatio=ratio
晋升阈值                 -XX:MaxTenuringThreshold=threshold
晋升详情                 -XX:+PrintTenuringDistribution
GC详情                     -XX:+PrintGCDetails -verbose:gc
FullGC 前 MinorGC         -XX:+ScavengeBeforeFullGC</code></pre><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a><strong>垃圾回收器</strong></h2><h3 id="1-串行Serial"><a href="#1-串行Serial" class="headerlink" title="1.串行Serial"></a><strong>1.串行Serial</strong></h3><p>单线程<br>堆内存较小，适合个人电脑<br><img src="/images/186.jpg" alt=""></p>
<h3 id="2-吞吐量优先Parallel：并行"><a href="#2-吞吐量优先Parallel：并行" class="headerlink" title="2.吞吐量优先Parallel：并行"></a><strong>2.吞吐量优先Parallel：并行</strong></h3><p>多线程<br>堆内存较大，多核 cpu<br>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高<br><img src="/images/187.jpg" alt=""></p>
<h3 id="3-响应时间优先concurrent：并发"><a href="#3-响应时间优先concurrent：并发" class="headerlink" title="3.响应时间优先concurrent：并发"></a><strong>3.响应时间优先concurrent：并发</strong></h3><p>多线程<br>堆内存较大，多核 cpu<br>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5<br><img src="/images/188.jpg" alt=""></p>
<h3 id="垃圾回收器参数"><a href="#垃圾回收器参数" class="headerlink" title="垃圾回收器参数"></a><strong>垃圾回收器参数</strong></h3><ol>
<li>串行<br> -XX:+UseSerialGC = Serial(复制算法) + SerialOld(标记+整理算法)。</li>
<li>吞吐量优先<br> -XX:+UseParallelGC ~ -XX:+UseParallelOldGC<br> -XX:+UseAdaptiveSizePolicy<br> -XX:GCTimeRatio=ratio<br> -XX:MaxGCPauseMillis=ms<br> -XX:ParallelGCThreads=n</li>
<li>响应时间优先CMS<br> -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld ，若老年代的并发失败，则会退化为SerialOld，进行内存碎片的整理，但这样会导致响应时间会过长。<br> -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads<br> -XX:CMSInitiatingOccupancyFraction=percent<br> -XX:+CMSScavengeBeforeRemark标记之前先进行一次新生代垃圾回收。</li>
</ol>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a><strong>G1</strong></h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><p><strong>Garbage First</strong><br>2004 论文发布<br>2009 JDK 6u14 体验<br>2012 JDK 7u4 官方支持<br>2017 JDK 9 默认</p>
<h3 id="详情参考"><a href="#详情参考" class="headerlink" title="详情参考"></a><strong>详情参考</strong></h3><p><a href="https://www.cnblogs.com/chenpt/p/9803298.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenpt/p/9803298.html</a></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的 Region</li>
<li>整体上是 标记+整理算法，两个区域之间是复制算法</li>
</ul>
<h3 id="相关JVM-参数"><a href="#相关JVM-参数" class="headerlink" title="相关JVM 参数"></a><strong>相关JVM 参数</strong></h3><p>-XX:+UseG1GC<br>-XX:G1HeapRegionSize=size<br>-XX:MaxGCPauseMillis=time</p>
<h2 id="G1的回收阶段"><a href="#G1的回收阶段" class="headerlink" title="G1的回收阶段"></a><strong>G1的回收阶段</strong></h2><ol>
<li><strong>G1垃圾回收阶段</strong><br><img src="/images/189.jpg" alt=""></li>
<li><strong>Young Collection：会STW</strong><br>E：Eden，S：Survival，O：Old<br><img src="/images/190.jpg" alt=""><br><img src="/images/191.jpg" alt=""></li>
<li><strong>Young Collection + CM(Concurrent marking)并发标记</strong></li>
</ol>
<ul>
<li>在 Young GC 时会进行 GC Root 的初始标记</li>
<li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定：-XX:InitiatingHeapOccupancyPercent=percent （默认45%）</li>
</ul>
<ol start="4">
<li><strong>Mixed Collection</strong><br>会对 E、S、O 进行全面垃圾回收，根据最大暂停时间，会有选择性的对O(垃圾最多的区)进行垃圾回收。如果暂停时间设置的较大，则会对所有O进行垃圾回收。</li>
</ol>
<ul>
<li>最终标记（Remark）会 STW，并发标记的过程中可能漏掉的垃圾。</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<p>-XX:MaxGCPauseMillis=ms<br><img src="/images/192.jpg" alt=""><br>5. <strong>Full GC</strong><br><strong>SerialGC</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足发生的垃圾收集 - full gc<br><strong>ParallelGC</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足发生的垃圾收集 - full gc<br><strong>CMS</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足，并发失败以后，这时就会退化为串行收集，这时就被称为Full GC<br><strong>G1</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足，并发标记+混合收集阶段，这两个阶段工作的过程中如果回收速度高于新的用户线程产生垃圾的速度时，还不能被称为Full GC，这时还处于并发垃圾收集的阶段。<br>    * 当垃圾回收速度跟不上垃圾产生的速度的时候，并发收集就失败了，这时就会退化为串行收集，但也是多线程，这是就被称为Full GC<br>6. Young Collection 跨代引用<br>新生代回收的跨代引用（老年代引用新生代）问题，在对新生代进行垃圾回收的过程中，需要寻找跟对象，跟对象有一部分是来自于老年代。老年代通常的存活对象非常多，如果遍历整个老年代去找跟对象，耗费的时间会非常多，所以就使用了卡(card)表的技术,将老年代的区域再进行细分，分成一个个card，每个card大约是512K，如果老年代其中有一个对象引用了新生代的对象，那么就把这个card标记为脏卡，将来不用去找整个老年代，而是只需要去关注脏卡的区域。减少搜索范围。<br><img src="/images/193.png" alt=""></p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue </li>
<li>concurrent refinement threads 更新 Remembered Set<br><img src="/images/194.png" alt=""></li>
</ul>
<ol start="7">
<li>Remark(重标记阶段)</li>
</ol>
<ul>
<li>因为并发标记过程中，也可能用户线程对处理中的对象进行修改，若第一次该对象被判为垃圾，但之后该对象又被其他对象所引用，则就不能被认为是垃圾被回收，需要进行remark。</li>
<li>当对象的引用发生改变的时候就对该对象进行写屏障pre-write barrier，将该对象加入到一个队列satb_mark_queue之中，当并发标记结束之后，重新标记的线程就会对该队列进行重新检查。<br>pre-write barrier + satb_mark_queue</li>
</ul>
<ol start="8">
<li>JDK 8u20 字符串去重</li>
</ol>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li>
</ul>
<p>-XX:+UseStringDeduplication</p>
<ul>
<li>1.8的String底层是char[]</li>
<li>将所有新分配的字符串放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有字符串重复</li>
<li>如果它们值一样，让它们引用同一个 char[]</li>
<li>注意，与 String.intern() 不一样<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>而字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<ol start="9">
<li>JDK 8u40 并发标记类卸载<br>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有<br>卸载类的条件：<ul>
<li>类的实例都被回收掉</li>
<li>类中的类加载器都不再被使用</li>
</ul>
</li>
</ol>
<p>-XX:+ClassUnloadingWithConcurrentMark 默认启用<br>String s1 = new String(“hello”); // char[]{‘h’,’e’,’l’,’l’,’o’} String s2 = new String(“hello”); // char[]{‘h’,’e’,’l’,’l’,’o’}<br>10. JDK 8u60 回收巨型对象<br><img src="/images/195.png" alt=""></p>
<ul>
<li>一个对象大于 region 的一半时，称之为巨型对象</li>
<li>G1 不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<ol start="11">
<li>JDK 9 并发标记起始时间的调整<br>并发标记必须在堆空间占满前完成，否则退化为 FullGC<br>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent<br>JDK 9 可以动态调整</li>
</ol>
<p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值<br>进行数据采样并动态调整<br>总会添加一个安全的空档空间<br>12. JDK 9 更高效的回收<br>250+增强<br>180+bug修复<br><a href="https://docs.oracle.com/en/java/javase/12/gctuning" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/gctuning</a></p>
<h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a><strong>垃圾回收调优</strong></h2><p>-XX:+PrintFlagsFinal,可以查看虚拟机参数<br>-XX:+PrintFlagsFinal -version | findstr “GC”,查看跟GC相关的参数<br><strong>预备知识</strong></p>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<h3 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a><strong>调优领域</strong></h3><ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a><strong>确定目标</strong></h3><p>【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<ul>
<li>低延迟:CMS，G1，ZGC(JDK12)</li>
<li>高吞吐量:ParallelGC</li>
<li>Zing:对外宣称零停顿</li>
</ul>
<h3 id="最快的-GC答案是不发生-GC"><a href="#最快的-GC答案是不发生-GC" class="headerlink" title="最快的 GC答案是不发生 GC"></a><strong>最快的 GC答案是不发生 GC</strong></h3><p>查看 FullGC 前后的内存占用，考虑下面几个问题</p>
<ul>
<li>数据是不是太多？<br>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li>
<li>数据表示是否太臃肿？<br>对象图<br>对象大小，Integer 24 int 4</li>
<li>是否存在内存泄漏？</li>
<li><em>解决方法*</em><ul>
<li>static Map map =</li>
<li>软弱引用</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
<h3 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a><strong>新生代调优</strong></h3><p><strong>新生代的特点</strong></p>
<ul>
<li>所有的 new 操作的内存分配非常廉价</li>
<li>每个线程都会在伊甸园中分配私有的区域：TLAB thread-local allocation buffer</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
<li><em>新生代的调优方式*</em></li>
</ul>
<ol>
<li>加大新生代的内存</li>
</ol>
<p><strong>越大越好吗？</strong><br>不是，因为新生代的空间大了，则老年代的空间就会变小，则容易触发Full GC<br>-Xmn 设置新生代的初始和最大值</p>
<ul>
<li>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).GC is performed in this region more often than in other regions. </li>
<li><strong>If the size for the young generation is too small, then a lot of minor garbage collections are performed.</strong> </li>
<li><strong>If the size is too large, then only full garbage collections are performed, which can take a long time to complete.</strong></li>
<li>Oracle recommends that you keep the size for the young generation <strong>greater than  25% and less than 50%</strong> of the overall heap size.</li>
</ul>
<p><strong>多大算合适?</strong></p>
<ul>
<li>新生代能容纳所有【并发量 * (请求-响应)】的数据</li>
<li>幸存区大到能保留【当前活跃对象+需要晋升对象】，如果幸存区较小，则可能因空间不足而把短时间存活的对象放入老年代。</li>
<li>晋升阈值配置得当，让长时间存活对象尽快晋升<ul>
<li>-XX:MaxTenuringThreshold=threshold ，调整最大晋升阈值</li>
<li>-XX:+PrintTenuringDistribution ，打印晋升的详细细节。<pre><code> Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total ...</code></pre></li>
</ul>
</li>
</ul>
<h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a><strong>老年代调优</strong></h3><p>以 CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>在CMS执行的过程中，用户线程也能够并发的执行，如果用户线程产生的新的垃圾(浮动垃圾)，而再次导致内存不足，那么就会并发失败，退化为SerialOld，使用Full GC</li>
<li>先尝试不做调优，如果没有 Full GC 那么说明老年代很充裕，否则先尝试调优新生代。一般不管有没有Full GC都应该先调优新生代。<br>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<p>-XX:CMSInitiatingOccupancyFraction=percent，控制老年代的空间占用百分之多少的时候，就进行CMS的垃圾回收，值越低触发时间就越早。一般设置为75% - 80%，<br>预留一部分空间给浮动垃圾。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h2><p><strong>案例1 Full GC 和 Minor GC频繁</strong><br>新生代空间较小<br>GC频繁说明空间紧张，当业务高峰期来了大量的对象被创建，很快就将新生代空间塞满，幸存区空间紧张，对象的晋升阈值就会变小，导致生存周期较短的对象，大量晋升到老年代，进一步触发Full GC。</p>
<p><strong>案例2 请求高峰期发生 Full GC，单次暂停时间特别长(CMS)</strong><br><img src="/images/196.png" alt=""><br>CMS耗费时间较长的阶段为重新标记。重新标记：扫描整个堆内存。若业务高峰的时候，新生代对象个数比较多，那么标记时间就会比较多，因为需要找其引用<br>解决方法：在重新标记之前，先进行一次垃圾回收<br>-XX:+CMSScavengeBeforeRemark标记之前先进行一次新生代垃圾回收。</p>
<p><strong>案例3 老年代充裕情况下，发生 Full GC(CMS jdk1.7)</strong><br>1.7采用的是永久代作为方法区的实现，而1.8采用的是元空间为方法区的实现<br>1.7及以前由于永久代的内存不足，也会触发Full GC</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="ckb22iudq001vzwu8bu26ea1z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web/Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/Web/Redis/" class="article-date">
  <time datetime="2020-03-31T05:55:57.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/Web/Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p>redis是一款高性能的NOSQL系列的非关系型数据库</p>
<h3 id="1-什么是NOSQL"><a href="#1-什么是NOSQL" class="headerlink" title="1.什么是NOSQL"></a><strong>1.什么是NOSQL</strong></h3><p>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。<br>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。<br><strong>NOSQL和关系型数据库比较</strong><br><img src="/images/166.png" alt=""><br>    优点：<br>        1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。<br>        2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。<br>        3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。<br>        4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。<br>    缺点：<br>        1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。<br>        2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。<br>        3）不提供关系型数据库对事务的处理。</p>
<p><strong>1.2.非关系型数据库的优势：</strong><br>    1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。<br>    2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<p><strong>1.3.关系型数据库的优势：</strong><br>    1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。<br>    2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<p><strong>1.4.总结</strong><br>    关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，<br>    让NoSQL数据库对关系型数据库的不足进行弥补。<br>    一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p>
<h2 id="2-主流的NOSQL产品"><a href="#2-主流的NOSQL产品" class="headerlink" title="2.主流的NOSQL产品"></a><strong>2.主流的NOSQL产品</strong></h2><ul>
<li><strong>键值(Key-Value)存储数据库</strong><pre><code>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 
数据模型： 一系列键值对
优势： 快速查询
劣势： 存储的数据缺少结构化</code></pre></li>
<li><strong>列存储数据库</strong><pre><code>相关产品：Cassandra, HBase, Riak
典型应用：分布式的文件系统
数据模型：以列簇式存储，将同一列数据存在一起
优势：查找速度快，可扩展性强，更容易进行分布式扩展
劣势：功能相对局限</code></pre></li>
<li><strong>文档型数据库</strong><pre><code>相关产品：CouchDB、MongoDB
典型应用：Web应用（与Key-Value类似，Value是结构化的）
数据模型： 一系列键值对
优势：数据结构要求不严格
劣势： 查询性能不高，而且缺乏统一的查询语法</code></pre></li>
<li><strong>图形(Graph)数据库</strong><pre><code>相关数据库：Neo4J、InfoGrid、Infinite Graph
典型应用：社交网络
数据模型：图结构
优势：利用图结构相关算法。
劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</code></pre></li>
</ul>
<h2 id="3-什么是Redis"><a href="#3-什么是Redis" class="headerlink" title="3.什么是Redis"></a><strong>3.什么是Redis</strong></h2><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>
<ul>
<li>字符串类型 string</li>
<li>哈希类型 hash</li>
<li>列表类型 list</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ul>
<p><strong>redis的应用场景</strong></p>
<ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li>
<li>聊天室的在线好友列表</li>
<li>任务队列。（秒杀、抢购、12306等等）</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒</li>
<li>分布式集群架构中的session分离</li>
</ul>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a><strong>下载安装</strong></h2><ol>
<li>官网：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li>
<li>中文网：<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">http://www.redis.net.cn/</a></li>
<li>解压直接可以使用：<ul>
<li>redis.windows.conf：配置文件</li>
<li>redis-cli.exe：redis的客户端</li>
<li>redis-server.exe：redis服务器端</li>
</ul>
</li>
</ol>
<h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a><strong>命令操作</strong></h2><ol>
<li><p>redis的数据结构：</p>
<ul>
<li>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构<ul>
<li>value的数据结构：<br>  1) 字符串类型 string<br>  2) 哈希类型 hash ： map格式<br>  3) 列表类型 list ： linkedlist格式。支持重复元素<br>  4) 集合类型 set  ： 不允许重复元素<br>  5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序<br><img src="/images/167.png" alt=""> </li>
</ul>
</li>
</ul>
</li>
<li><p>字符串类型 string</p>
<ol>
<li>存储： set key value<br> 127.0.0.1:6379&gt; set username zhangsan<br> OK</li>
<li>获取： get key<br> 127.0.0.1:6379&gt; get username<br> “zhangsan”</li>
<li>删除： del key<br> 127.0.0.1:6379&gt; del age<br> (integer) 1</li>
</ol>
</li>
<li><p>哈希类型 hash，这里的key代表的是map对象的名称，而field和value是一一对应的。</p>
<ol>
<li><p>存储： hset key field value<br> 127.0.0.1:6379&gt; hset myhash username lisi<br> (integer) 1<br> 127.0.0.1:6379&gt; hset myhash password 123<br> (integer) 1</p>
</li>
<li><p>获取： </p>
<ul>
<li>hget key field: 获取指定的field对应的值<br>  127.0.0.1:6379&gt; hget myhash username<br>  “lisi”</li>
<li>hgetall key：获取所有的field和value<br>  127.0.0.1:6379&gt; hgetall myhash<br>  1) “username”<br>  2) “lisi”<br>  3) “password”<br>  4) “123”</li>
</ul>
</li>
<li><p>删除： hdel key field<br> 127.0.0.1:6379&gt; hdel myhash username<br> (integer) 1</p>
</li>
</ol>
</li>
<li><p>列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<ol>
<li>添加：<ol>
<li>lpush key value: 将元素加入列表左表            </li>
<li>rpush key value：将元素加入列表右边<br> 127.0.0.1:6379&gt; lpush myList a<br> (integer) 1<br> 127.0.0.1:6379&gt; lpush myList b<br> (integer) 2<br> 127.0.0.1:6379&gt; rpush myList c<br> (integer) 3</li>
</ol>
</li>
<li>获取：<ul>
<li>lrange key start end ：范围获取，end为-1的话为获取所有<br>  127.0.0.1:6379&gt; lrange myList 0 -1<br>  1) “b”<br>  2) “a”<br>  3) “c”</li>
</ul>
</li>
<li>删除：<ul>
<li>lpop key： 删除列表最左边的元素，并将元素返回</li>
<li>rpop key： 删除列表最右边的元素，并将元素返回</li>
</ul>
</li>
</ol>
</li>
<li><p>集合类型 set ： 不允许重复元素</p>
<ol>
<li>存储：sadd key value<br> 127.0.0.1:6379&gt; sadd myset a<br> (integer) 1<br> 127.0.0.1:6379&gt; sadd myset a<br> (integer) 0</li>
<li>获取：smembers key:获取set集合中所有元素<br> 127.0.0.1:6379&gt; smembers myset<br> 1) “a”</li>
<li>删除：srem key value:删除set集合中的某个元素<br> 127.0.0.1:6379&gt; srem myset a<br> (integer) 1</li>
</ol>
</li>
<li><p>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<ol>
<li>存储：zadd key score value<br> 127.0.0.1:6379&gt; zadd mysort 60 zhangsan<br> (integer) 1<br> 127.0.0.1:6379&gt; zadd mysort 50 lisi<br> (integer) 1<br> 127.0.0.1:6379&gt; zadd mysort 80 wangwu<br> (integer) 1</li>
<li>获取：zrange key start end [withscores]<br> 127.0.0.1:6379&gt; zrange mysort 0 -1<br> 1) “lisi”<br> 2) “zhangsan”<br> 3) “wangwu”<br> 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores<br> 1) “zhangsan”<br> 2) “60”<br> 3) “wangwu”<br> 4) “80”<br> 5) “lisi”<br> 6) “500”</li>
<li>删除：zrem key value<br> 127.0.0.1:6379&gt; zrem mysort lisi<br> (integer) 1</li>
</ol>
</li>
<li><p>通用命令</p>
<ol>
<li>keys * : 查询所有的键</li>
<li>type key ： 获取键对应的value的类型</li>
<li>del key：删除指定的key value</li>
</ol>
</li>
</ol>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h2><ol>
<li>redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</li>
<li>redis持久化机制：<ol>
<li>RDB：默认方式，不需要进行配置，默认就使用这种机制<ul>
<li>在一定的间隔时间中，检测key的变化情况，然后持久化数据</li>
</ul>
<ol>
<li>编辑redis.windwos.conf文件<br> 井   after 900 sec (15 min) if at least 1 key changed<br> save 900 1<br> 井   after 300 sec (5 min) if at least 10 keys changed<br> save 300 10<br> 井   after 60 sec if at least 10000 keys changed<br> save 60 10000            </li>
<li>重新启动redis服务器，并指定配置文件名称(需要用命令行打开：在此处打开命令行)<br> 输入：redis-server.exe redis.windows.conf            </li>
</ol>
</li>
<li>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据<ol>
<li>编辑redis.windwos.conf文件<br> appendonly no（关闭aof） –&gt; appendonly yes （开启aof）<br> 井 appendfsync always ： 每一次操作都进行持久化<br> appendfsync everysec ： 每隔一秒进行一次持久化<br> 井 appendfsync no     ： 不进行持久化</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Java客户端-Jedis"><a href="#Java客户端-Jedis" class="headerlink" title="Java客户端 Jedis"></a><strong>Java客户端 Jedis</strong></h2><ul>
<li>Jedis: 一款java操作redis数据库的工具.</li>
<li>使用步骤：<ol>
<li>下载jedis的jar包</li>
<li>使用<br> //1. 获取连接<br> Jedis jedis = new Jedis(“localhost”,6379);<pre><code>//2. 操作
jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);</code></pre> //3. 关闭连接<br> jedis.close();</li>
</ol>
</li>
</ul>
<h3 id="Jedis操作各种redis中的数据结构"><a href="#Jedis操作各种redis中的数据结构" class="headerlink" title="Jedis操作各种redis中的数据结构"></a><strong>Jedis操作各种redis中的数据结构</strong></h3><p><strong>1) 字符串类型 string</strong><br>    set<br>    get</p>
<pre><code> //1. 获取连接
Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口
//2. 操作
//存储
jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);
//获取
String username = jedis.get(&quot;username&quot;);
System.out.println(username);
//可以使用setex()方法存储可以指定过期时间的 key value
jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对
//3. 关闭连接
jedis.close();</code></pre><p><strong>2) 哈希类型 hash ： map格式</strong><br>    hset<br>    hget<br>    hgetAll</p>
<pre><code>//1. 获取连接
Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口
//2. 操作
// 存储hash
jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);
jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);
jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);
// 获取hash
String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);
System.out.println(name);
// 获取hash的所有map中的数据
Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);
// keyset
Set&lt;String&gt; keySet = user.keySet();
for (String key : keySet) {
    //获取value
    String value = user.get(key);
    System.out.println(key + &quot;:&quot; + value);
}
//3. 关闭连接
jedis.close();</code></pre><p>3<strong>) 列表类型 list ： linkedlist格式。支持重复元素</strong><br>    lpush / rpush<br>    lpop / rpop<br>    lrange start end : 范围获取</p>
<pre><code> //1. 获取连接
Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口
//2. 操作
// list 存储
jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存
jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存
// list 范围获取
List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);
System.out.println(mylist);  
// list 弹出
String element1 = jedis.lpop(&quot;mylist&quot;);//c
System.out.println(element1);
String element2 = jedis.rpop(&quot;mylist&quot;);//c
System.out.println(element2);
// list 范围获取
List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);
System.out.println(mylist2);
//3. 关闭连接
jedis.close();</code></pre><p><strong>4) 集合类型 set  ： 不允许重复元素</strong><br>    sadd<br>    smembers:获取所有元素</p>
<pre><code>//1. 获取连接
Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口
//2. 操作
// set 存储
jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);
// set 获取
Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);
System.out.println(myset);
//3. 关闭连接
jedis.close();</code></pre><p><strong>5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</strong><br>    zadd<br>    zrange</p>
<pre><code>//1. 获取连接
Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口
//2. 操作
// sortedset 存储
jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);
jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);
jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);
// sortedset 获取
Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);
System.out.println(mysortedset);
//3. 关闭连接
jedis.close();</code></pre><h3 id="jedis连接池：-JedisPool"><a href="#jedis连接池：-JedisPool" class="headerlink" title="jedis连接池： JedisPool"></a><strong>jedis连接池： JedisPool</strong></h3><ul>
<li><p>使用：</p>
<ol>
<li><p>创建JedisPool连接池对象</p>
</li>
<li><p>调用方法 getResource()方法获取Jedis连接</p>
<p> //0.创建一个配置对象<br> JedisPoolConfig config = new JedisPoolConfig();<br> config.setMaxTotal(50);<br> config.setMaxIdle(10);<br> //1.创建Jedis连接池对象<br> JedisPool jedisPool = new JedisPool(config,”localhost”,6379);<br> //2.获取连接<br> Jedis jedis = jedisPool.getResource();<br> //3. 使用<br> jedis.set(“hehe”,”heihei”);<br> //4. 关闭 归还到连接池中<br> jedis.close();</p>
</li>
</ol>
</li>
<li><p>连接池工具类</p>
<pre><code>public class JedisPoolUtils {
private static JedisPool jedisPool;    
static{
    //读取配置文件
    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);
    //创建Properties对象
    Properties pro = new Properties();
    //关联文件
    try {
        pro.load(is);
    } catch (IOException e) {
        e.printStackTrace();
    }
    //获取数据，设置到JedisPoolConfig中
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));
    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));    
    //初始化JedisPool
    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));    
}
/**             * 获取连接方法             * /
    public static Jedis getJedis(){
        return jedisPool.getResource();
    }
}</code></pre></li>
</ul>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p><img src="/images/168.png" alt=""><br>案例需求：<br>    1. 提供index.html页面，页面中有一个省份 下拉列表<br>    2. 当 页面加载完成后 发送ajax请求，加载所有省份</p>
<ul>
<li>注意：使用redis缓存一些不经常发生变化的数据。<ul>
<li>数据库的数据一旦发生改变，则需要更新缓存。<ul>
<li>数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</li>
<li>在service对应的增删改方法中，将redis数据删除。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/Web/Redis/" data-id="ckb22iuf10066zwu89a5o8r02" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode/剑指-数组中重复的数字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" class="article-date">
  <time datetime="2020-03-31T05:27:16.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">剑指-数组中重复的数字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>题目描述</strong><br>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br>示例 1：<br>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3<br>限制：<br>2 &lt;= n &lt;= 100000</p>
<p><strong>解题方法1</strong><br>hashmap存值判断。</p>
<pre><code>class Solution {
    public int findRepeatNumber(int[] nums) {
        HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();
        for(int num:nums)
        {
            if(map.get(num)!=null)
            return num;
            map.put(num,1);
        }
        return 0;
    }
}</code></pre><p>执行用时 :15 ms, 在所有 Java 提交中击败了11.76%的用户<br>内存消耗 :48.8 MB, 在所有 Java 提交中击败了100.00%的用户</p>
<p><strong>解题方法2</strong><br>由于题目给出<strong>长度为 n 数组 nums 里的所有数字都在 0～n-1</strong><br>所以可以</p>
<pre><code>class Solution {
    public int findRepeatNumber(int[] nums) {
        int[] f=new int[nums.length];
        for(int num:nums)
        {
            if(f[num]++&gt;=1)
            return num;
        }
        return 0;
    }
}</code></pre><p>执行用时 :1 ms, 在所有 Java 提交中击败了92.62%的用户。<br>内存消耗 :47.5 MB, 在所有 Java 提交中击败了100.00%的用户。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" data-id="ckb22iue30031zwu84hkf88fy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode/剑指-重建二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time datetime="2020-03-31T05:27:16.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">剑指-重建二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
<p><strong>代码</strong><br>思路：递归，先序遍历的第一个肯定是父结点，然后在中序遍历里面找到该节点，该节点左边为该结点的左子树，该节点的右边为该节点的右子树。</p>
<pre><code>class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
            TreeNode root=new TreeNode();
            if(preorder!=null&amp;&amp;preorder.length&gt;0)
            add(root,preorder,inorder);
            else
            return null;
            return root;
    }
    public void add(TreeNode root,int[] preorder, int[] inorder)
    {       
            root.val=preorder[0];
            int i;
            for(i=0;i&lt;inorder.length;i++)
            {
                if(inorder[i]==root.val)
                break;
            }
            int lsize=i;
            int rsize=inorder.length-1-i;
            if(lsize&gt;0)
            {
                int[] a=new int[lsize];
                System.arraycopy(preorder,1,a,0,lsize);
                int[] b=new int[lsize];
                System.arraycopy(inorder,0,b,0,lsize); 
                root.left=new TreeNode();         
                add(root.left,a,b);
            }
            if(rsize&gt;0)
            {
                int a[]=new int[rsize];
                System.arraycopy(preorder,1+lsize,a,0,rsize);
                int b[]=new int[rsize];
                System.arraycopy(inorder,1+lsize,b,0,rsize);
                root.right=new TreeNode();
                add(root.right,a,b);
            }
    }
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ckb22iue50039zwu80sut869v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/鸽巢原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/%E7%AE%97%E6%B3%95/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-03-31T04:12:15.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/31/%E7%AE%97%E6%B3%95/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/">鸽巢原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a><strong>抽屉原理</strong></h2><p>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。抽屉原理的一般含义为:“如果 每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。”抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理</p>
<p><strong>第一抽屉原理</strong><br>原理1:把多于n+1个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。好<br>原理2 :把多于mn(m乘n)+1 (n不为0)个的物体放到n个抽屉里，则至少有一个抽屉里有不少于(m+1) 的物体。<br>原理3 :把无穷多件物体放入n个抽屉，则至少有一-个抽屉里有无穷个物体。<br><strong>第二抽屉原理</strong><br>把(mn-1)个物体放入n个抽屉中，其中必有一个抽屉中至多有(m-1)个物体(例如，将3X 5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。</p>
<p><strong>最差原则:</strong><br>最差原则，即考虑所有可能情况中，最不利于某件事情发生的情况。<br>例如，有300人到招聘会求职，其中软件设计有100人，市场营销有80人，财务管理有70人，人力资源管理有50人。<br>那么至少有多少人找到工作才能保证一定有70人找的工作专业相同呢?<br>此时我们考虑的最差情况为:软件设计、市场营销和财务管理各录取69人，人力<br>资源管理的50人全部录取，则此时再录取1人就能保证有70人找到的工作专业相同。<br>因此至少需要69* 3+50+1=258人。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>死神来了<br>时间限制：1000 ms | 内存限制：65535 KB<br>难度：3<br><strong>描述</strong><br>有一天，王小子在遨游世界时，遇到了一场自然灾害。一个人孤独的在一个岛上，没有吃的没有喝的。在他饥寒交迫将要死亡时，死神来了。由于这个死神在成神之前是一个数学家，所以他有一个习惯，会和即死之人玩一个数学游戏，来决定是否将其灵魂带走。游戏规则是死神给王小子两个整数n（100&lt;=n&lt;=1000000）,m(2&lt;=m&lt;=n)，在1~ n个数中，随机取m个数,问在这m个数中是否一定存在一个数是另一个数的倍数，是则回答“YES”,否则”NO”。如果王小子回答正确，将有再活下去的机会。但是他很后悔以前没有好好学习数学，王小子知道你数学学得不错，请你救他一命。</p>
<p><strong>输入</strong><br>有多组测试数据，不多于10000;<br>每组有两个数n,m;<br>以文件结束符EOF为结束标志。<br><strong>输出</strong><br>输出”YES”或”NO”。<br><strong>样例输入</strong><br>100 80<br>100 20<br><strong>样例输出</strong><br>YES<br>NO</p>
<p><strong>典型的鸽巢定理，给定 1∼n 个数，如果取超过一半的数，则一定存在一个数是另一个数的倍数。这里具体需要注意的是，n 如果是奇数时，这里的一半应该是向上取整的。大致就这样，代码很简单。</strong></p>
<p>以下内容摘自CSDN，作者：xuexiacm<br>链接：<a href="https://blog.csdn.net/xuexiacm/article/details/8123681?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/xuexiacm/article/details/8123681?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
<h2 id="应用抽屉原理解题"><a href="#应用抽屉原理解题" class="headerlink" title="应用抽屉原理解题"></a><strong>应用抽屉原理解题</strong></h2><p>抽屉原理的内容简明朴素，易于接受，它在数学问题中有重要的作用。许多有关存在性的证明都可用它来解决。<br><strong>例1：</strong><br>同年出生的400人中至少有2个人的生日相同。<br>解：将一年中的365天视为365个抽屉，400个人看作400个物体，由抽屉原理1可以得知：至少有2人的生日相同. 400/365=1…35,1+1=2　又如：我们从街上随便找来13人，就可断定他们中至少有两个人属相相同。</p>
<p><strong>例2：</strong><br>幼儿园买来了不少白兔、熊猫、长颈鹿塑料玩具，每个小朋友任意选择两件，那么不管怎样挑选，在任意七个小朋友中总有两个彼此选的玩具都相同，试说明道理.<br>解 ：从三种玩具中挑选两件，搭配方式只能是下面六种：（兔、兔），（兔、熊猫），（兔、长颈鹿），（熊猫、熊猫），（熊猫、长颈鹿），（长颈鹿、长颈鹿）。把每种搭配方式看作一个抽屉，把7个小朋友看作物体，那么根据原理1，至少有两个物体要放进同一个抽屉里，也就是说，至少两人挑选玩具采用同一搭配方式，选的玩具相同.</p>
<p><strong>上面数例论证的似乎都是“存在”、“总有”、“至少有”的问题，不错，这正是抽屉原则的主要作用.（需要说明的是，运用抽屉原则只是肯定了“存在”、“总有”、“至少有”，却不能确切地指出哪个抽屉里存在多少.</strong></p>
<h2 id="制造抽屉是运用原则的一大关键"><a href="#制造抽屉是运用原则的一大关键" class="headerlink" title="制造抽屉是运用原则的一大关键"></a><strong>制造抽屉是运用原则的一大关键</strong></h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a><strong>例1</strong></h3><p>从2、4、6、…、30这15个偶数中，任取9个数，证明其中一定有两个数之和是34。<br><strong>分析与解答：</strong>我们用题目中的15个偶数制造8个抽屉：因为共有7对数之和为34.<br>制造的此抽屉特点：每个抽屉放数的个数为1或者2，凡是抽屉中有两个数的，这两个数的和是34。<br>现在从这8个抽屉中取9个数，可得必有两个数取自同一个抽屉，所以得出结论。</p>
<h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a><strong>例2：</strong></h3><p>从1、2、3、4、…、19、20这20个自然数中，至少任选几个数，就可以保证其中一定包括两个数，它们的差是12。<br><strong>分析与解答：</strong>在这20个自然数中，差是12的有以下8对：{20，8}，{19，7}，{18，6}，{17，5}，{16，4}，{15，3}，{14，2}，{13，1}。<br>另外还有4个不能配对的数{9}，{10}，{11}，{12}，共制成12个抽屉（每个括号看成一个抽屉）.只要有两个数取自同一个抽屉，那么它们的差就等于12，根据抽屉原理至少任选13个数，即可办到（取12个数：从12个抽屉中各取一个数（例如取1，2，3，…，12），那么这12个数中任意两个数的差必不等于12）。</p>
<h3 id="例3："><a href="#例3：" class="headerlink" title="例3："></a><strong>例3：</strong></h3><p>从1到20这20个数中，任取11个数，必有两个数，其中一个数是另一个数的倍数。<br><strong>分析与解答</strong><br>根据题目所要求证的问题，应考虑按照同一抽屉中，任意两数都具有倍数关系的原则制造抽屉.把这20个数按奇数及其倍数分成以下十组，看成10个抽屉（显然，它们具有上述性质）：<br>　　{1，2，4，8，16}，{3，6，12}，{5，10，20}，{7，14}，{9，18}，{11}，{13}，{15}，{17}，{19}。<br>　　从这10个数组的20个数中任取11个数，根据抽屉原理，至少有两个数取自同一个抽屉.由于凡在同一抽屉中的两个数都具有倍数关系，所以这两个数中，其中一个数一定是另一个数的倍数。
　　</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/%E7%AE%97%E6%B3%95/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/" data-id="ckb22iugl00c8zwu8dgwdh5hk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/容斥原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-03-30T15:04:28.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/">容斥原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是:先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去,使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</strong><br><img src="/images/165.png" alt=""><br>奇数个相交的相加，偶数个相交的就相减。</p>
<h3 id="题目：电灯泡"><a href="#题目：电灯泡" class="headerlink" title="题目：电灯泡"></a><strong>题目：</strong>电灯泡</h3><p><strong>Problem Description</strong><br>V_Dragon有n栈电灯泡，编号为1-n，每个灯泡都有一个开关。那么问题来了<br>所有灯泡初始时为不亮的<br>V_Dragon分别进行三次操作<br>每次操作他都选一个质数x，将编号为x和x的整数倍的灯泡的开关都拨动一下（如果灯为亮，那么拨动以后灯为不亮,如果灯不亮，拨动以后变为亮）<br>求最后亮着的灯的数量</p>
<p><strong>Input</strong><br>输入T表示T组测试数据（1&lt;=T&lt;=100）<br>接下来T组测试数据<br>每组第一行一个n表示灯泡个数（1&lt;=n&lt;=10^9）<br>第二行三个数a,b,c表示V_Dragon每次选择的数（1&lt;=a,b,c&lt;=10^6）（a,b,c全为质数且a,b,c两两互不相等）<br>不懂格式的同学可以参考以下格式：</p>
<p><strong>Output</strong><br>数组最后亮着的灯的个数</p>
<p><strong>SampleInput</strong><br>1<br>30<br>2 3 5<br><strong>SampleOutput</strong><br>15</p>
<p><strong>思路</strong>：根据相容定律变化而得。按奇数(灯亮)次的加，按偶数(灯灭)次的减。<br>public static void main(String[] args) {<br>        Scanner in=new Scanner(System.in);<br>        int Arrays=in.nextInt();<br>        int[] nums=new int[Arrays];<br>        for (int i = 0; i &lt;Arrays ; i++) {<br>            nums[i]=in.nextInt();<br>        }<br>        int num=0;<br>        while(Arrays–&gt;0)<br>        {<br>            int a=in.nextInt();<br>            int b=in.nextInt();<br>            int c=in.nextInt();<br>            int n=nums[Arrays];<br>            num=n/a+n/b+n/c-2<em>(n/a/b+n/a/c+n/b/c)+4</em>(n/a/b/c);<br>        }<br>        System.out.println(num);<br>    }</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/30/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" data-id="ckb22iugg00bpzwu8fofj0ogf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web/JSON" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/Web/JSON/" class="article-date">
  <time datetime="2020-03-30T06:55:36.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/Web/JSON/">JSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p><strong>JavaScript Object Notation        JavaScript对象表示法</strong></p>
<ul>
<li>Person p = new Person();<br>  p.setName(“张三”);<br>  p.setAge(23);<br>  p.setGender(“男”);</li>
<li>var p = {“name”:”张三”,”age”:23,”gender”:”男”};</li>
</ul>
<p><strong>json的作用</strong></p>
<ul>
<li>json现在多用于存储和交换文本信息的语法</li>
<li>进行数据的传输</li>
<li>JSON 比 XML 更小、更快，更易解析。</li>
</ul>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h2><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1.基本规则"></a><strong>1.基本规则</strong></h3><ul>
<li>数据在名称/值对中：json数据是由键值对构成的<ul>
<li>键用引号(单双都行)引起来，也可以不使用引号</li>
<li>值的取值类型：<ol>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）    {“persons”:[{},{}]}</li>
<li>对象（在花括号中） {“address”:{“province”：”陕西”….}}</li>
<li>null</li>
</ol>
</li>
</ul>
</li>
<li>数据由逗号分隔：多个键值对由逗号分隔</li>
<li>花括号保存对象：使用{}定义json 格式，大括号里面包含的都是Json对象</li>
<li>方括号保存数组：[]</li>
</ul>
<h3 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据:"></a><strong>2.获取数据:</strong></h3><ol>
<li>json对象.键名</li>
<li>json对象[“键名”]</li>
<li>数组对象[索引]</li>
<li>遍历<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义基本格式</span></span><br><span class="line">  <span class="keyword">var</span> person = &#123;<span class="string">"name"</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="string">'gender'</span>: <span class="literal">true</span>&#125;;														</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ps = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>, <span class="string">"age"</span>: <span class="number">23</span>, <span class="string">"gender"</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>, <span class="string">"age"</span>: <span class="number">24</span>, <span class="string">"gender"</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"name"</span>: <span class="string">"王五"</span>, <span class="string">"age"</span>: <span class="number">25</span>, <span class="string">"gender"</span>: <span class="literal">false</span>&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取person对象中所有的键和值</span></span><br><span class="line">  <span class="comment">//for in 循环,注意：这里的key默认是字符串形式。</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> person)&#123;</span><br><span class="line">      <span class="comment">//这样的方式获取不行。因为相当于  person."name"</span></span><br><span class="line">      <span class="comment">//alert(key + ":" + person.key);</span></span><br><span class="line">      alert(key+<span class="string">":"</span>+person[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取ps中的所有值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ps.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> p = ps[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> p)&#123;</span><br><span class="line">          alert(key+<span class="string">":"</span>+p[key]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="JSON数据和Java对象的相互转换"><a href="#JSON数据和Java对象的相互转换" class="headerlink" title="JSON数据和Java对象的相互转换"></a><strong>JSON数据和Java对象的相互转换</strong></h2><ul>
<li>JSON解析器：<ul>
<li>常见的解析器：Jsonlib(官方),Gson(谷歌),fastjson(阿里),jackson(SpringMVC内置)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-JSON转为Java对象"><a href="#1-JSON转为Java对象" class="headerlink" title="1.JSON转为Java对象"></a><strong>1.JSON转为Java对象</strong></h3><ol>
<li>导入jackson的相关jar包</li>
<li>创建Jackson核心对象 ObjectMapper</li>
<li>调用ObjectMapper的相关方法进行转换<ol>
<li>readValue(json字符串数据,Class)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示 JSON字符串转为Java对象</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//1.初始化JSON字符串</span></span><br><span class="line">       String json = <span class="string">"&#123;\"gender\":\"男\",\"name\":\"张三\",\"age\":23&#125;"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.创建ObjectMapper对象</span></span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//3.转换为Java对象 Person对象</span></span><br><span class="line">       Person person = mapper.readValue(json, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(person);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="2-Java对象转换JSON"><a href="#2-Java对象转换JSON" class="headerlink" title="2.Java对象转换JSON"></a><strong>2.Java对象转换JSON</strong></h3><ol>
<li>导入jackson的相关jar包</li>
<li>创建Jackson核心对象 ObjectMapper</li>
<li>调用ObjectMapper的相关方法进行转换<ol>
<li>转换方法：<ul>
<li>writeValue(参数1，obj):<br>  参数1：<pre><code>File：将obj对象转换为JSON字符串，并保存到指定的文件中
Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中
OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</code></pre></li>
<li>writeValueAsString(obj):将对象转为json字符串</li>
</ul>
</li>
<li>注解：<ol>
<li>@JsonIgnore：排除属性。避免对象间相互嵌套而导致栈溢出。</li>
<li>@JsonFormat：属性值得格式化<ul>
<li>@JsonFormat(pattern = “yyyy-MM-dd”)</li>
</ul>
</li>
</ol>
</li>
<li>复杂java对象转换<ol>
<li>List：数组</li>
<li>Map：与对象格式一致，键值对格式。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java对象转为JSON字符串</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Person对象</span></span><br><span class="line">        Person p  = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        p.setAge(<span class="number">23</span>);</span><br><span class="line">        p.setGender(<span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Jackson的核心对象  ObjectMapper</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//3.转换</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            转换方法：</span></span><br><span class="line"><span class="comment">                writeValue(参数1，obj):</span></span><br><span class="line"><span class="comment">                    参数1：</span></span><br><span class="line"><span class="comment">                        File：将obj对象转换为JSON字符串，并保存到指定的文件中</span></span><br><span class="line"><span class="comment">                        Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</span></span><br><span class="line"><span class="comment">                        OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</span></span><br><span class="line"><span class="comment">                writeValueAsString(obj):将对象转为json字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        <span class="comment">//&#123;"name":"张三","age":23,"gender":"男"&#125;</span></span><br><span class="line">        <span class="comment">//System.out.println(json);//&#123;"name":"张三","age":23,"gender":"男"&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeValue，将数据写到d://a.txt文件中</span></span><br><span class="line">        <span class="comment">//mapper.writeValue(new File("d://a.txt"),p);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeValue.将数据关联到Writer中</span></span><br><span class="line">        mapper.writeValue(<span class="keyword">new</span> FileWriter(<span class="string">"d://b.txt"</span>),p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>* 校验用户名是否存在
    1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：
        1. $.get(type):将最后一个参数type指定为&quot;json&quot;
        2. 在服务器端设置MIME类型application/json.
            response.setContentType(&quot;application/json;charset=utf-8&quot;);</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/30/Web/JSON/" data-id="ckb22iuez005wzwu8c3dbh0n9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web/AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/Web/AJAX/" class="article-date">
  <time datetime="2020-03-30T01:23:24.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/Web/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><ul>
<li>ASynchronous JavaScript And XML    异步的JavaScript 和 XML</li>
<li>异步和同步：客户端和服务器端相互通信的基础上<ul>
<li>客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</li>
<li>客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</li>
</ul>
</li>
<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li>
<li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>
<li>提升用户的体验</li>
</ul>
<h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a><strong>实现方式：</strong></h2><h3 id="1-原生的JS实现方式（了解）"><a href="#1-原生的JS实现方式（了解）" class="headerlink" title="1.原生的JS实现方式（了解）"></a><strong>1.原生的JS实现方式（了解）</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建核心对象</span></span><br><span class="line">        <span class="keyword">var</span> xmlhttp;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">        &#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">            xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">            xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);												</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 建立连接</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数：</span></span><br><span class="line"><span class="comment">                1. 请求方式：GET、POST</span></span><br><span class="line"><span class="comment">                    * get方式，请求参数在URL后边拼接。send方法为空参</span></span><br><span class="line"><span class="comment">                    * post方式，请求参数在send方法中定义</span></span><br><span class="line"><span class="comment">                2. 请求的URL：</span></span><br><span class="line"><span class="comment">                3. 同步或异步请求：true（异步）或 false（同步）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajaxServlet?username=tom"</span>,<span class="literal">true</span>);	</span><br><span class="line">        <span class="comment">//3.发送请求</span></span><br><span class="line">        xmlhttp.send();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接受并处理来自服务器的响应结果</span></span><br><span class="line">        <span class="comment">//获取方式 ：xmlhttp.responseText</span></span><br><span class="line">        <span class="comment">//什么时候获取？当服务器响应成功后再获取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span></span><br><span class="line">        xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//判断readyState就绪状态是否为4，判断status响应状态码是否为200</span></span><br><span class="line">            <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//获取服务器的响应结果</span></span><br><span class="line">                <span class="keyword">var</span> responseText = xmlhttp.responseText;</span><br><span class="line">                alert(responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-JQeury实现方式"><a href="#2-JQeury实现方式" class="headerlink" title="2.JQeury实现方式"></a><strong>2.JQeury实现方式</strong></h3><ol>
<li>$.ajax()<ul>
<li>语法：$.ajax({键值对});<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="comment">//使用$.ajax()发送异步请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">"ajaxServlet1111"</span> , <span class="comment">// 请求路径</span></span><br><span class="line">            type:<span class="string">"POST"</span> , <span class="comment">//请求方式</span></span><br><span class="line">            <span class="comment">//data: "username=jack&amp;age=23",//请求参数														</span></span><br><span class="line">            data:&#123;<span class="string">"username"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;,</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                alert(data);</span><br><span class="line">            &#125;,<span class="comment">//响应成功后的回调函数</span></span><br><span class="line">            error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">"出错啦..."</span>)</span><br><span class="line">            &#125;,<span class="comment">//表示如果请求响应出现错误，会执行的回调函数</span></span><br><span class="line"></span><br><span class="line">            dataType:<span class="string">"text"</span><span class="comment">//设置接受到的响应数据的格式</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>$.get()：发送get请求<ul>
<li>语法：$.get(url, [data], [callback], [type])<ul>
<li>参数：<ul>
<li>url：请求路径</li>
<li>data：请求参数</li>
<li>callback：回调函数</li>
<li>type：响应结果的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义方法</span></span><br><span class="line">        <span class="function">function  <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            $.get(<span class="string">"ajaxServlet"</span>,&#123;username:<span class="string">"rose"</span>&#125;,function (data) &#123;</span><br><span class="line">                alert(data);</span><br><span class="line">            &#125;,<span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"发送异步请求"</span> onclick=<span class="string">"fun();"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>$.post()：发送post请求<ul>
<li>语法：$.post(url, [data], [callback], [type])<ul>
<li>参数：<ul>
<li>url：请求路径</li>
<li>data：请求参数</li>
<li>callback：回调函数</li>
<li>type：响应结果的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/30/Web/AJAX/" data-id="ckb22iuev005hzwu8grz3a5pk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web/JQuery高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/29/Web/JQuery%E9%AB%98%E7%BA%A7/" class="article-date">
  <time datetime="2020-03-29T05:19:35.000Z" itemprop="datePublished">2020-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/29/Web/JQuery%E9%AB%98%E7%BA%A7/">JQuery高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h1><h2 id="一、动画：三种方式显示和隐藏元素"><a href="#一、动画：三种方式显示和隐藏元素" class="headerlink" title="一、动画：三种方式显示和隐藏元素"></a><strong>一、动画：三种方式显示和隐藏元素</strong></h2><p><strong>参数：</strong></p>
<ul>
<li>speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</li>
<li>easing：用来指定切换效果，默认是”swing”，可用参数”linear”<ul>
<li>swing：动画执行时效果是 先慢，中间快，最后又慢</li>
<li>linear：动画执行时速度是匀速的</li>
</ul>
</li>
<li>fn：在动画完成时执行的函数，每个元素执行一次。传入function对象。</li>
</ul>
<ol>
<li>默认显示和隐藏方式<ol>
<li>show([speed,[easing],[fn]])        </li>
<li>hide([speed,[easing],[fn]])</li>
<li>toggle([speed],[easing],[fn])</li>
</ol>
</li>
<li>滑动显示和隐藏方式<ol>
<li>slideDown([speed],[easing],[fn])</li>
<li>slideUp([speed,[easing],[fn]])</li>
<li>slideToggle([speed],[easing],[fn])</li>
</ol>
</li>
<li>淡入淡出显示和隐藏方式<ol>
<li>fadeIn([speed],[easing],[fn])</li>
<li>fadeOut([speed],[easing],[fn])</li>
<li>fadeToggle([speed,[easing],[fn]])</li>
</ol>
</li>
</ol>
<h2 id="二、遍历"><a href="#二、遍历" class="headerlink" title="二、遍历"></a><strong>二、遍历</strong></h2><ol>
<li>js的遍历方式<ul>
<li>for(初始化值;循环结束条件;步长){}</li>
</ul>
</li>
<li>jq的遍历方式<ol>
<li>jq对象.each(callback)；  callback：回调函数<ol>
<li>语法：<br> jquery对象.each(function(index,element){<br> 循环体内容<br> });<pre><code>* index:就是元素在集合中的索引
* element：就是集合中的每一个元素对象
* this：集合中的每一个元素对象</code></pre></li>
<li>回调函数返回值：<ul>
<li>true:如果当前function返回为false，则结束循环(break)。</li>
<li>false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</li>
</ul>
</li>
</ol>
</li>
<li>$.each(object, [callback])；</li>
<li>for..of: jquery 3.0 版本之后提供的方式<br> for(元素对象 of 容器对象)</li>
</ol>
</li>
</ol>
<h2 id="三、事件绑定"><a href="#三、事件绑定" class="headerlink" title="三、事件绑定"></a><strong>三、事件绑定</strong></h2><ol>
<li>jquery标准的绑定方式<ul>
<li>jq对象.事件方法(回调函数)；</li>
<li>注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。<ul>
<li>表单对象.submit();//让表单提交</li>
</ul>
</li>
</ul>
</li>
<li>on绑定事件/off解除绑定<ul>
<li>jq对象.on(“事件名称”,回调函数)</li>
<li>jq对象.off(“事件名称”)<ul>
<li>如果off方法不传递任何参数，则将组件上的所有事件全部解绑</li>
</ul>
</li>
</ul>
</li>
<li>事件切换：toggle<ul>
<li>jq对象.toggle(fn1,fn2…)<ul>
<li>当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..        </li>
</ul>
</li>
<li>注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。   <script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"></script>

</li>
</ul>
</li>
</ol>
<h2 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a><strong>四、案例</strong></h2><p><strong>1.广告显示和隐藏</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">	&lt;!DOCTYPE html&gt;</span><br><span class="line">	&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">	    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">	    &lt;title&gt;广告的自动显示与隐藏&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">	    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">	        #content&#123;width:100%;height:500px;background:#999&#125;</span></span><br><span class="line"><span class="regexp">	    &lt;/</span>style&gt;</span><br><span class="line">	</span><br><span class="line">	    &lt;!--引入jquery--&gt;</span><br><span class="line">	    &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../js/jquery-3.3.1.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">	    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">	        /</span>*</span><br><span class="line">	            需求：</span><br><span class="line">	                <span class="number">1.</span> 当页面加载完，<span class="number">3</span> 秒后。自动显示广告</span><br><span class="line">	                <span class="number">2.</span> 广告显示<span class="number">5</span>秒后，自动消失。</span><br><span class="line">	</span><br><span class="line">	            分析：</span><br><span class="line">	                <span class="number">1.</span> 使用定时器来完成。setTimeout (执行一次定时器)</span><br><span class="line">	                <span class="number">2.</span> 分析发现JQuery的显示和隐藏动画效果其实就是控制display</span><br><span class="line">	                <span class="number">3.</span> 使用  show/hide方法来完成广告的显示</span><br><span class="line">	         * <span class="regexp">/</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">	        /</span><span class="regexp">/入口函数，在页面加载完成之后，定义定时器，调用这两个方法</span></span><br><span class="line"><span class="regexp">	        $(function () &#123;</span></span><br><span class="line"><span class="regexp">	           /</span><span class="regexp">/定义定时器，调用adShow方法 3秒后执行一次</span></span><br><span class="line"><span class="regexp">	           setTimeout(adShow,3000);</span></span><br><span class="line"><span class="regexp">	           /</span><span class="regexp">/定义定时器，调用adHide方法，8秒后执行一次</span></span><br><span class="line"><span class="regexp">	            setTimeout(adHide,8000);</span></span><br><span class="line"><span class="regexp">	        &#125;);</span></span><br><span class="line"><span class="regexp">	        /</span><span class="regexp">/显示广告</span></span><br><span class="line"><span class="regexp">	        function adShow() &#123;</span></span><br><span class="line"><span class="regexp">	            /</span><span class="regexp">/获取广告div，调用显示方法</span></span><br><span class="line"><span class="regexp">	            $("#ad").show("slow");</span></span><br><span class="line"><span class="regexp">	        &#125;</span></span><br><span class="line"><span class="regexp">	        /</span><span class="regexp">/隐藏广告</span></span><br><span class="line"><span class="regexp">	        function adHide() &#123;</span></span><br><span class="line"><span class="regexp">	            /</span><span class="regexp">/获取广告div，调用隐藏方法</span></span><br><span class="line"><span class="regexp">	            $("#ad").hide("slow");</span></span><br><span class="line"><span class="regexp">	        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">​			</span></span><br><span class="line"><span class="regexp">	    &lt;/</span>script&gt;</span><br><span class="line">	&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">	&lt;body&gt;</span></span><br><span class="line"><span class="regexp">	&lt;!-- 整体的DIV --&gt;</span></span><br><span class="line"><span class="regexp">	&lt;div&gt;</span></span><br><span class="line"><span class="regexp">	    &lt;!-- 广告DIV --&gt;</span></span><br><span class="line"><span class="regexp">	    &lt;div id="ad" style="display: none;"&gt;</span></span><br><span class="line"><span class="regexp">	        &lt;img style="width:100%" src="../img</span><span class="regexp">/adv.jpg" /</span>&gt;</span><br><span class="line">	    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">	    &lt;!-- 下方正文部分 --&gt;</span></span><br><span class="line"><span class="regexp">	    &lt;div id="content"&gt;</span></span><br><span class="line"><span class="regexp">	        正文部分</span></span><br><span class="line"><span class="regexp">	    &lt;/</span>div&gt;</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>body&gt;</span><br><span class="line">	&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">	2. 抽奖</span><br><span class="line">		&lt;!DOCTYPE html&gt;</span><br><span class="line">		&lt;html&gt;</span><br><span class="line">		&lt;head&gt;</span><br><span class="line">		    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">		    &lt;title&gt;jquery案例之抽奖&lt;&#x2F;title&gt;</span><br><span class="line">		    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">		</span><br><span class="line">		    &lt;script language&#x3D;&#39;javascript&#39; type&#x3D;&#39;text&#x2F;javascript&#39;&gt;</span><br><span class="line">		</span><br><span class="line">		        &#x2F;*</span><br><span class="line">		            分析：</span><br><span class="line">		                1. 给开始按钮绑定单击事件</span><br><span class="line">		                    1.1 定义循环定时器</span><br><span class="line">		                    1.2 切换小相框的src属性</span><br><span class="line">		                        * 定义数组，存放图片资源路径</span><br><span class="line">		                        * 生成随机数。数组索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		                2. 给结束按钮绑定单击事件</span><br><span class="line">		                    1.1 停止定时器</span><br><span class="line">		                    1.2 给大相框设置src属性</span><br><span class="line">		</span><br><span class="line">		         *&#x2F;</span><br><span class="line">		        var imgs &#x3D; [&quot;..&#x2F;img&#x2F;man00.jpg&quot;,</span><br><span class="line">		                    &quot;..&#x2F;img&#x2F;man01.jpg&quot;,</span><br><span class="line">		                    &quot;..&#x2F;img&#x2F;man02.jpg&quot;,</span><br><span class="line">		                    &quot;..&#x2F;img&#x2F;man03.jpg&quot;,</span><br><span class="line">		                    &quot;..&#x2F;img&#x2F;man04.jpg&quot;,</span><br><span class="line">		                    &quot;..&#x2F;img&#x2F;man05.jpg&quot;,</span><br><span class="line">		                    &quot;..&#x2F;img&#x2F;man06.jpg&quot;,</span><br><span class="line">		                    ];</span><br><span class="line">		        var startId;&#x2F;&#x2F;开始定时器的id</span><br><span class="line">		        var index;&#x2F;&#x2F;随机角标</span><br><span class="line">		        $(function () &#123;</span><br><span class="line">		            &#x2F;&#x2F;处理按钮是否可以使用的效果</span><br><span class="line">		            $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);</span><br><span class="line">		            $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		           &#x2F;&#x2F;1. 给开始按钮绑定单击事件</span><br><span class="line">		            $(&quot;#startID&quot;).click(function () &#123;</span><br><span class="line">		                &#x2F;&#x2F; 1.1 定义循环定时器 20毫秒执行一次</span><br><span class="line">		                startId &#x3D; setInterval(function () &#123;</span><br><span class="line">		                    &#x2F;&#x2F;处理按钮是否可以使用的效果</span><br><span class="line">		                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);</span><br><span class="line">		                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		                    &#x2F;&#x2F;1.2生成随机角标 0-6</span><br><span class="line">		                    index &#x3D; Math.floor(Math.random() * 7);&#x2F;&#x2F;0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999</span><br><span class="line">		                    &#x2F;&#x2F;1.3设置小相框的src属性</span><br><span class="line">		                    $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);</span><br><span class="line">		</span><br><span class="line">		                &#125;,20);</span><br><span class="line">		            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		            &#x2F;&#x2F;2. 给结束按钮绑定单击事件</span><br><span class="line">		            $(&quot;#stopID&quot;).click(function () &#123;</span><br><span class="line">		                &#x2F;&#x2F;处理按钮是否可以使用的效果</span><br><span class="line">		                $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);</span><br><span class="line">		                $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		               &#x2F;&#x2F; 1.1 停止定时器</span><br><span class="line">		                clearInterval(startId);</span><br><span class="line">		               &#x2F;&#x2F; 1.2 给大相框设置src属性</span><br><span class="line">		                $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();</span><br><span class="line">		                &#x2F;&#x2F;显示1秒之后</span><br><span class="line">		                $(&quot;#img2ID&quot;).show(1000);</span><br><span class="line">		            &#125;);</span><br><span class="line">		        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​			</span><br><span class="line">​			</span><br><span class="line">		    &lt;&#x2F;script&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;&#x2F;head&gt;</span><br><span class="line">		&lt;body&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 小像框 --&gt;</span><br><span class="line">		&lt;div style&#x3D;&quot;border-style:dotted;width:160px;height:100px&quot;&gt;</span><br><span class="line">		    &lt;img id&#x3D;&quot;img1ID&quot; src&#x3D;&quot;..&#x2F;img&#x2F;man00.jpg&quot; style&#x3D;&quot;width:160px;height:100px&quot;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 大像框 --&gt;</span><br><span class="line">		&lt;div</span><br><span class="line">		        style&#x3D;&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;</span><br><span class="line">		    &lt;img id&#x3D;&quot;img2ID&quot; src&#x3D;&quot;..&#x2F;img&#x2F;man00.jpg&quot; width&#x3D;&quot;800px&quot; height&#x3D;&quot;500px&quot;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 开始按钮 --&gt;</span><br><span class="line">		&lt;input</span><br><span class="line">		        id&#x3D;&quot;startID&quot;</span><br><span class="line">		        type&#x3D;&quot;button&quot;</span><br><span class="line">		        value&#x3D;&quot;点击开始&quot;</span><br><span class="line">		        style&#x3D;&quot;width:150px;height:150px;font-size:22px&quot;&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!-- 停止按钮 --&gt;</span><br><span class="line">		&lt;input</span><br><span class="line">		        id&#x3D;&quot;stopID&quot;</span><br><span class="line">		        type&#x3D;&quot;button&quot;</span><br><span class="line">		        value&#x3D;&quot;点击停止&quot;</span><br><span class="line">		        style&#x3D;&quot;width:150px;height:150px;font-size:22px&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&lt;&#x2F;body&gt;</span><br><span class="line">		&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="五、插件：增强JQuery的功能"><a href="#五、插件：增强JQuery的功能" class="headerlink" title="五、插件：增强JQuery的功能"></a><strong>五、插件：</strong>增强JQuery的功能</h2><ol>
<li>实现方式：<ol>
<li>$.fn.extend(object) ，对象级别的插件<ul>
<li>增强通过Jquery获取的对象的功能  $(“#id”)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> $.fn.extend(&#123;</span><br><span class="line">        <span class="comment">//定义了一个check()方法。所有的jq对象都可以调用该方法</span></span><br><span class="line">        check:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//让复选框选中</span></span><br><span class="line">            <span class="comment">//this:调用该方法的jq对象</span></span><br><span class="line">            <span class="keyword">this</span>.prop(<span class="string">"checked"</span>,<span class="literal">true</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        uncheck:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//让复选框不选中</span></span><br><span class="line">            <span class="keyword">this</span>.prop(<span class="string">"checked"</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">// 获取按钮</span></span><br><span class="line">            <span class="comment">//$("#btn-check").check();</span></span><br><span class="line">            <span class="comment">//复选框对象.check();</span></span><br><span class="line"></span><br><span class="line">            $(<span class="string">"#btn-check"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//获取复选框对象</span></span><br><span class="line">                $(<span class="string">"input[type='checkbox']"</span>).check();</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            $(<span class="string">"#btn-uncheck"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//获取复选框对象</span></span><br><span class="line">                $(<span class="string">"input[type='checkbox']"</span>).uncheck();</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>$.extend(object)，全局的插件<ul>
<li>增强JQeury对象自身的功能  $/jQuery<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对全局方法扩展2个方法，扩展min方法：求2个值的最小值；扩展max方法：求2个值最大值        </span></span><br><span class="line">$.extend(&#123;</span><br><span class="line">    max:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回两数中的较大值</span></span><br><span class="line">        <span class="keyword">return</span> a &gt;= b ? a:b;</span><br><span class="line">    &#125;,</span><br><span class="line">    min:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回两数中的较小值</span></span><br><span class="line">        <span class="keyword">return</span> a &lt;= b ? a:b;</span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用全局方法</span></span><br><span class="line">        <span class="keyword">var</span> max = $.max(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//alert(max);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> min = $.min(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        alert(min);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/29/Web/JQuery%E9%AB%98%E7%BA%A7/" data-id="ckb22iuf10062zwu85psu9uwc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>