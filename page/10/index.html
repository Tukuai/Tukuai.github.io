<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://tukuai.github.io/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Tukuai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-算法/克鲁斯卡尔(Kruska)算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94(Kruska)%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-10T04:24:15.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94(Kruska)%E7%AE%97%E6%B3%95/">克鲁斯卡尔(Kruska)算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法七：克鲁斯卡尔-Kruska-算法"><a href="#算法七：克鲁斯卡尔-Kruska-算法" class="headerlink" title="算法七：克鲁斯卡尔(Kruska)算法"></a><strong>算法七：克鲁斯卡尔(Kruska)算法</strong></h2><p><strong>应用场景-公交站问题</strong><br>看一个应用场景和问题：<br><img src="/images/92.png" alt=""><br>某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通<br>各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里<br>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? </p>
<h3 id="克鲁斯卡尔算法介绍"><a href="#克鲁斯卡尔算法介绍" class="headerlink" title="克鲁斯卡尔算法介绍"></a><strong>克鲁斯卡尔算法介绍</strong></h3><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。<br>基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路<br>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止<br><strong>克鲁斯卡尔算法图解说明</strong><br>克鲁斯卡尔算法图解说明<br><img src="/images/93.png" alt=""><br>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br>问题一 对图的所有边按照权值大小进行排序。<br>问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。<br>问题一很好解决，采用排序算法进行排序即可。<br>问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">package 算法;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KrusakalCase &#123;</span><br><span class="line">    private int edgeNum;  &#x2F;&#x2F;边的个数</span><br><span class="line">    private char[] vertexs; &#x2F;&#x2F;顶点数组</span><br><span class="line">    private int[][] matrix;  &#x2F;&#x2F;邻接矩阵</span><br><span class="line">    &#x2F;&#x2F;表示两个顶点不能连通</span><br><span class="line">    private static final int INF&#x3D;Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char vertexs[] &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;</span><br><span class="line">        &#x2F;&#x2F;克鲁斯卡尔算法的邻接矩阵</span><br><span class="line">        int matrix[][] &#x3D; &#123;</span><br><span class="line">        &#x2F;*A*&#x2F;   &#x2F;*B*&#x2F;   &#x2F;*C*&#x2F;   &#x2F;*D*&#x2F;   &#x2F;*E*&#x2F;   &#x2F;*F*&#x2F;   &#x2F;*G*&#x2F;</span><br><span class="line">&#x2F;*A*&#x2F;&#123;  0,     12,      INF,    INF,    INF,    16,     14&#125;,</span><br><span class="line">&#x2F;*B*&#x2F;&#123;  12,     0,      10,     INF,    INF,    7,      INF&#125;,</span><br><span class="line">&#x2F;*C*&#x2F;&#123;  INF,    10,     0,      3,      5,      6,      INF&#125;,</span><br><span class="line">&#x2F;*D*&#x2F;&#123;  INF,    INF,    3,      0,      4,      INF,    INF&#125;,</span><br><span class="line">&#x2F;*E*&#x2F;&#123;  INF,    INF,    5,      4,      0,      2,      8&#125;,</span><br><span class="line">&#x2F;*F*&#x2F;&#123;  16,     7,      6,      INF,    2,      0,      8&#125;,</span><br><span class="line">&#x2F;*G*&#x2F;&#123;  14,     INF,    INF,    INF,    8,      9,      0&#125;&#125;;</span><br><span class="line">        KrusakalCase k&#x3D;new KrusakalCase(vertexs,matrix);</span><br><span class="line">        k.print();</span><br><span class="line">        Edata[] edges &#x3D; k.getEdges();</span><br><span class="line">        k.sortEdges(edges);</span><br><span class="line">        for (Edata edge :edges) &#123;</span><br><span class="line">            System.out.println(edge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;******************&quot;);</span><br><span class="line">        k.Kruskal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KrusakalCase(char[] vertexs, int[][] matrix)</span><br><span class="line">    &#123;</span><br><span class="line">        this.vertexs &#x3D; vertexs;</span><br><span class="line">        this.matrix &#x3D; matrix;</span><br><span class="line">        for (int[] ints : matrix)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i : ints)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i!&#x3D;INF)</span><br><span class="line">                    this.edgeNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edgeNum&#x3D;(edgeNum-vertexs.length)&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int[] ints : matrix)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i : ints)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i&#x3D;&#x3D;INF)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(-1+&quot;   &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                  else</span><br><span class="line">                System.out.print(i+&quot;   &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对边进行排序处理，冒泡</span><br><span class="line">    private void sortEdges(Edata [] edges)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;edges.length-1 ; i++) &#123;</span><br><span class="line">            for (int j &#x3D;0; j &lt;edges.length-i-1 ; j++) &#123;</span><br><span class="line">                if(edges[j].weight&gt;edges[j+1].weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    Edata e&#x3D;edges[j];</span><br><span class="line">                    edges[j]&#x3D;edges[j+1];</span><br><span class="line">                    edges[j+1]&#x3D;e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回顶点对应的下标</span><br><span class="line">    private int getPosition(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            if(vertexs[i]&#x3D;&#x3D;ch)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取图中的边，放到Edata的数组中</span><br><span class="line">    private Edata[] getEdges()</span><br><span class="line">    &#123;   int index&#x3D;0;</span><br><span class="line">        Edata[] edges&#x3D;new Edata[edgeNum];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i+1; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                if(matrix[i][j]!&#x3D;INF)</span><br><span class="line">                &#123;</span><br><span class="line">                    edges[index++]&#x3D;new Edata(vertexs[i],vertexs[j],matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edges;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取下标为i的顶点的终点，用于判断两个顶点的终点是否相同（用来判断两个顶点相连是否形成回路）</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param ends  在遍历过程中动态形成的，已经形成的边的顶点的终点下标集合</span><br><span class="line">     * @param i   表示传入的顶点对应的下标</span><br><span class="line">     * @return    返回下标下表为i的顶点对应的终点的下标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int getEnd(int[] ends,int i)</span><br><span class="line">    &#123;</span><br><span class="line">         &#x2F;&#x2F;因为终点的顶点默认设置为-1</span><br><span class="line">        while(ends[i]!&#x3D;-1)</span><br><span class="line">        &#123;</span><br><span class="line">            i&#x3D;ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Kruskal()</span><br><span class="line">    &#123;</span><br><span class="line">        int index&#x3D;0;&#x2F;&#x2F;表示最后结果数组的索引</span><br><span class="line">        int[] ends&#x3D;new int[vertexs.length];&#x2F;&#x2F;用于保存已有的生成树中的每个顶点的</span><br><span class="line">        for (int i &#x3D; 0; i &lt; ends.length; i++) &#123;</span><br><span class="line">            ends[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建结果数组，保存最小生成树</span><br><span class="line">        Edata[] rets&#x3D;new Edata[edgeNum];</span><br><span class="line">        &#x2F;&#x2F;获取图中所有边的集合</span><br><span class="line">        Edata[] edges&#x3D;getEdges();</span><br><span class="line">        sortEdges(edges);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;遍历edges,盘对是否形成回路</span><br><span class="line">        for (int i &#x3D; 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            int v1&#x3D;getPosition(edges[i].v1);</span><br><span class="line">            int v2&#x3D;getPosition(edges[i].v2);</span><br><span class="line">            &#x2F;&#x2F;获取v1,v2的终点</span><br><span class="line">            int m&#x3D;getEnd(ends,v1);</span><br><span class="line">            int n&#x3D;getEnd(ends,v2);</span><br><span class="line">            &#x2F;&#x2F;&#x2F;是否构成回路</span><br><span class="line">            if(m!&#x3D;n)&#x2F;&#x2F;没有构成回路</span><br><span class="line">            &#123;</span><br><span class="line">                ends[m]&#x3D;n;</span><br><span class="line">                rets[index++]&#x3D;edges[i];&#x2F;&#x2F;有一条边加入</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;统计并打印最小生成树</span><br><span class="line">        for (Edata ret : rets) &#123;</span><br><span class="line">            System.out.println(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建一个类Edata，它的实例表示一个边</span><br><span class="line">class Edata&#123;</span><br><span class="line">    char v1;&#x2F;&#x2F;边的一个点</span><br><span class="line">    char v2;&#x2F;&#x2F;边的另一个点</span><br><span class="line">    int weight;&#x2F;&#x2F;边的权值</span><br><span class="line"></span><br><span class="line">    public Edata(char v1, char v2, int weight) &#123;</span><br><span class="line">        this.v1 &#x3D; v1;</span><br><span class="line">        this.v2 &#x3D; v2;</span><br><span class="line">        this.weight &#x3D; weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Edata&#123;&quot; +</span><br><span class="line">                &quot;v1&#x3D;&quot; + v1 +</span><br><span class="line">                &quot;, v2&#x3D;&quot; + v2 +</span><br><span class="line">                &quot;, weight&#x3D;&quot; + weight +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal的灵魂代码"><a href="#Kruskal的灵魂代码" class="headerlink" title="Kruskal的灵魂代码"></a><strong>Kruskal的灵魂代码</strong></h3><p>一：获取顶点的终点，用来判断是否否形成回路，其中ends是动态变化的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int getEnd(int[] ends,int i)</span><br><span class="line">   &#123;</span><br><span class="line">       &#x2F;&#x2F;因为终点的顶点默认设置为-1</span><br><span class="line">       while(ends[i]!&#x3D;-1)</span><br><span class="line">       &#123;</span><br><span class="line">           i&#x3D;ends[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>二：遍历已经排好序的边的集合，并按次序加入结果rets集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; edges.length; i++) &#123;</span><br><span class="line">            int v1&#x3D;getPosition(edges[i].v1);</span><br><span class="line">            int v2&#x3D;getPosition(edges[i].v2);</span><br><span class="line">            &#x2F;&#x2F;获取v1,v2的终点</span><br><span class="line">            int m&#x3D;getEnd(ends,v1);</span><br><span class="line">            int n&#x3D;getEnd(ends,v2);</span><br><span class="line">            &#x2F;&#x2F;&#x2F;是否构成回路</span><br><span class="line">            if(m!&#x3D;n)&#x2F;&#x2F;没有构成回路</span><br><span class="line">            &#123;</span><br><span class="line">                ends[m]&#x3D;n;</span><br><span class="line">                rets[index++]&#x3D;edges[i];&#x2F;&#x2F;有一条边加入</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/10/%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94(Kruska)%E7%AE%97%E6%B3%95/" data-id="ckb22iugd00bdzwu85v387l34" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构/图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/" class="article-date">
  <time datetime="2020-03-09T07:10:05.000Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/">图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h2><p><strong>为什么要有图</strong></p>
<ol>
<li>前面我们学了线性表和树</li>
<li>线性表局限于一个直接前驱和一个直接后继的关系</li>
<li>树也只能有一个直接前驱也就是父节点</li>
<li>当我们需要表示多对多的关系时， 这里我们就用到了图</li>
</ol>
<p><strong>图的举例说明</strong><br>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。如图：<br><img src="/images/68.png" alt=""></p>
<p><strong>图的常用概念</strong></p>
<ol>
<li>顶点(vertex)</li>
<li>边(edge)</li>
<li>路径</li>
<li>无向图(下图)<br><img src="/images/69.png" alt=""></li>
<li>有向图</li>
<li>带权图<br><img src="/images/70.png" alt=""></li>
</ol>
<p><strong>图的表示方式</strong><br>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<ol>
<li>邻接矩阵<br>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。<br><img src="/images/71.png" alt=""></li>
<li>邻接表<br>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.<br>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成<br><img src="/images/72.png" alt=""></li>
</ol>
<p><strong>图遍历介绍</strong><br>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历</p>
<p><strong>深度优先遍历基本思想</strong><br>图的深度优先搜索(Depth First Search) 。</p>
<ol>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li>
<li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>显然，深度优先搜索是一个递归的过程</li>
</ol>
<p><strong>深度优先遍历算法步骤</strong></p>
<ol>
<li>访问初始结点v，并标记结点v为已访问。</li>
<li>查找结点v的第一个邻接结点w。</li>
<li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li>
<li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li>
<li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<p><strong>广度优先遍历基本思想</strong><br>图的广度优先搜索(Broad First Search) 。<br>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点<br><strong>广度优先遍历算法步骤</strong></p>
<ol>
<li>访问初始结点v并标记结点v为已访问。</li>
<li>结点v入队列</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得队头结点u。</li>
<li>查找结点u的第一个邻接结点w。</li>
<li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</li>
<li>1 若结点w尚未被访问，则访问结点w并标记为已访问。 </li>
<li>2 结点w入队列 </li>
<li>3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">package 图;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class GraphDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;String VertexValue[]&#x3D;&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;;</span><br><span class="line">        String VertexValue[]&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;&#125;;</span><br><span class="line">        Graph graph&#x3D;new Graph(VertexValue.length);</span><br><span class="line">        for (String s : VertexValue) &#123;</span><br><span class="line">            graph.add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line">        graph.insertEdge(3, 7, 1);</span><br><span class="line">        graph.insertEdge(4, 7, 1);</span><br><span class="line">        graph.insertEdge(2, 5, 1);</span><br><span class="line">        graph.insertEdge(2, 6, 1);</span><br><span class="line">        graph.insertEdge(5, 6, 1);</span><br><span class="line"></span><br><span class="line">        graph.print();</span><br><span class="line">        graph.DFS(0);</span><br><span class="line">        System.out.println();</span><br><span class="line">        graph.reset();</span><br><span class="line">        graph.BFS(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Graph</span><br><span class="line">&#123;</span><br><span class="line">    private ArrayList&lt;String&gt; vertexList;&#x2F;&#x2F;存储顶点集合</span><br><span class="line">    private int[][] edges;&#x2F;&#x2F;存储图对应的邻接矩阵</span><br><span class="line">    private int numOfEdges;&#x2F;&#x2F;存储边的数目</span><br><span class="line">    private int[] isVisited;</span><br><span class="line">    public void add(String s)</span><br><span class="line">    &#123;</span><br><span class="line">        vertexList.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    public Graph(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        edges&#x3D;new int[n][n];</span><br><span class="line">        vertexList&#x3D;new ArrayList&lt;&gt;(n);</span><br><span class="line">        numOfEdges&#x3D;0;</span><br><span class="line">        isVisited&#x3D;new int[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void reset()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; isVisited.length; i++) &#123;</span><br><span class="line">            isVisited[i]&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;插入结点</span><br><span class="line">    public  void insertVertex(String vertex)</span><br><span class="line">    &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加边</span><br><span class="line">    public void insertEdge(int v1,int v2,int weight)</span><br><span class="line">    &#123;</span><br><span class="line">        edges[v1][v2]&#x3D;weight;</span><br><span class="line">        edges[v2][v1]&#x3D;weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回节点的个数</span><br><span class="line">    public int getNumofVertex()</span><br><span class="line">    &#123;</span><br><span class="line">    return vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回边的数目</span><br><span class="line">    public int getNumOfEdges() &#123;</span><br><span class="line">        return numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回节点下标i对性的数据</span><br><span class="line">    public String getValueByIndex(int i)</span><br><span class="line">    &#123;</span><br><span class="line">    return vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回v1和v2的权值</span><br><span class="line">    public int getWeight(int v1,int v2)</span><br><span class="line">    &#123;</span><br><span class="line">        return edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;深度优先搜索</span><br><span class="line"></span><br><span class="line">    public void DFS(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(vertexList.get(i)+&quot;--&gt;&quot;);</span><br><span class="line">        isVisited[i]&#x3D;1;</span><br><span class="line">        int firstNB&#x3D;0;</span><br><span class="line">        while((firstNB&#x3D;getFirstNB(i))!&#x3D;-1)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(firstNB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int getFirstNB(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i1 &#x3D; 0; i1 &lt; edges[i].length; i1++) &#123;</span><br><span class="line">            if(edges[i][i1]&#x3D;&#x3D;1&amp;&amp;isVisited[i1]&#x3D;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                return i1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;广度优先搜索,非递归版本</span><br><span class="line">    public void BFS(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; is &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        is.add(i);</span><br><span class="line">        System.out.print(vertexList.get(i)+&quot;--&gt;&quot;);</span><br><span class="line">        isVisited[i]&#x3D;1;</span><br><span class="line">        while(is.size()!&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            int firstNB;</span><br><span class="line">            while((firstNB &#x3D; getFirstNB(is.get(0)))!&#x3D;-1)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(vertexList.get(firstNB)+&quot;--&gt;&quot;);</span><br><span class="line">                isVisited[firstNB]&#x3D;1;</span><br><span class="line">                is.add(firstNB);</span><br><span class="line">            &#125;</span><br><span class="line">            is.remove(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;显示图对应的矩阵</span><br><span class="line">    public void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int[] ints : edges) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/" data-id="ckb22iug300abzwu82vfk4q5b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/KMP算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/06/%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-06T09:32:37.000Z" itemprop="datePublished">2020-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95/">KMP算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法四：KMP算法"><a href="#算法四：KMP算法" class="headerlink" title="算法四：KMP算法"></a><strong>算法四：KMP算法</strong></h2><p>字符串匹配问题：：<br>有一个字符串 str1= “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=”尚硅谷你尚硅你”<br>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</p>
<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a><strong>暴力匹配算法</strong></h3><p>如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:<br>如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符<br>如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。<br>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)<br>暴力匹配算法实现.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void baoli(String s1,String s2)</span><br><span class="line">    &#123;</span><br><span class="line">        int i&#x3D;0,j&#x3D;0;</span><br><span class="line">        char[] chars1 &#x3D; s1.toCharArray();</span><br><span class="line">        char[] chars2 &#x3D; s2.toCharArray();</span><br><span class="line">        while(i&lt;chars1.length&amp;&amp;j&lt;chars2.length)</span><br><span class="line">        &#123;</span><br><span class="line">            if(chars1[i]&#x3D;&#x3D;chars2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                i&#x3D;i-j+1;</span><br><span class="line">                j&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j&#x3D;&#x3D;chars2.length)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;str1中包含str2，在第&quot;+(i-j)+&quot;个字符开始&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;str1中不存在str2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><strong>KMP算法</strong></h3><p><strong>KMP算法介绍</strong></p>
<ol>
<li>KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li>
<li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.</li>
<li>KMP方法算法就利用之前判断过信息，通过一个<strong>next数组</strong>，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li>
<li>参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a><br>举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ </li>
</ol>
<blockquote>
<p>1.首先，用Str1的第一个字符和Str2的第一个字符去比较，不符合，关键词向后移动一位<br><img src="/images/75.png" alt=""><br>2.重复第一步，还是不符合，再后移<br><img src="/images/76.png" alt=""><br>3.一直重复，直到Str1有一个字符与Str2的第一个字符符合为止<br><img src="/images/77.png" alt=""><br>4.接着比较字符串和搜索词的下一个字符，还是符合。<br><img src="/images/78.png" alt=""><br>5.遇到Str1有一个字符与Str2对应的字符不符合。<br><img src="/images/79.png" alt=""><br>6.这时候，想到的是继续遍历Str1的下一个字符，重复第1步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。)<br><img src="/images/80.png" alt=""><br>7.怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》，这张表的产生在后面介绍<br><img src="/images/81.png" alt=""><br>8.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：<br>移动位数 = 已匹配的字符数 - 对应的部分匹配值<br>因为 6 - 2 等于4，所以将搜索词向后移动 4 位。<br>9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。<br><img src="/images/82.png" alt=""><br>10.因为空格与A不匹配，继续后移一位。<br><img src="/images/83.png" alt=""><br>11.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。<br><img src="/images/84.png" alt=""></p>
</blockquote>
<p>12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。<br><img src="/images/85.png" alt=""><br>13.介绍《部分匹配表》怎么产生的<br>先介绍前缀，后缀是什么<br><img src="/images/86.png" alt=""><br>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，<br>－”A”的前缀和后缀都为空集，共有元素的长度为0；<br>－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；<br>－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；<br>－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；<br>－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；<br>－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；<br>－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。<br>14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。<br> <img src="/images/87.png" alt=""><br>到此KMP算法思想分析完毕!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void kmp(String s1,String s2)</span><br><span class="line">    &#123;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        int bufen&#x3D;0;</span><br><span class="line">        char[] chars1 &#x3D; s1.toCharArray();</span><br><span class="line">        char[] chars2 &#x3D; s2.toCharArray();</span><br><span class="line">        while(i&lt;chars1.length&amp;&amp;j&lt;chars2.length)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                if(chars1[i]&#x3D;&#x3D;chars2[bufen])</span><br><span class="line">                &#123;</span><br><span class="line">                    bufen++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    bufen&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(chars1[i]&#x3D;&#x3D;chars2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                i&#x3D;i-bufen+1;</span><br><span class="line">                j&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(j&#x3D;&#x3D;chars2.length)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;str1中包含str2，在第&quot;+(i-j)+&quot;个字符开始&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;str1中不存在str2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a><strong>核心代码：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(j&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                if(chars1[i]&#x3D;&#x3D;chars2[bufen])</span><br><span class="line">                &#123;</span><br><span class="line">                    bufen++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    bufen&#x3D;0;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/06/%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95/" data-id="ckb22iugb00b6zwu805w75c2f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/动态规划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time datetime="2020-03-04T07:50:20.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法三：动态规划"><a href="#算法三：动态规划" class="headerlink" title="算法三：动态规划"></a><strong>算法三：动态规划</strong></h2><h3 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a><strong>动态规划算法介绍</strong></h3><ol>
<li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li>
</ol>
<h3 id="应用场景-背包问题"><a href="#应用场景-背包问题" class="headerlink" title="应用场景-背包问题"></a><strong>应用场景-背包问题</strong></h3><p>背包问题：有一个背包，容量为4磅 ， 现有如下物品</p>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li>
<li>要求装入的物品不能重复</li>
<li>思路分析和图解<br>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)<br>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。</li>
</ol>
<p><strong>01背包的常用解决方法为</strong>：选和不选（求出选这件物品和不选这件物品的最大值）<br>思路：</p>
<pre><code>//先假定优先级，吉他为最小0，音响1，电脑2，
int[] pre=new int[3];// pre[i]为买物品i，而能买的优先级比自己小的第一件东西
int[] opt=new int[3];//opt为买或不买第i件物品的最大值,optimal。
int[] weight=new int[3];
int[] price=new int[3];
//若买i物品的话，opt[i]为price[i]+opt[pre[i]]
//若不买第i件物品的话，opt[i]为opt[i-1]</code></pre><p><img src="/images/73.png" alt=""><br><img src="/images/74.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">class BeiBao</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*  物品   重量  价格</span><br><span class="line">        吉他(G)	1	1500</span><br><span class="line">        音响(S)	4	3000</span><br><span class="line">        电脑(L)	3	2000*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;背包大小为4</span><br><span class="line">    &#x2F;&#x2F;先假定优先级，吉他为最小0，音响1，电脑2，</span><br><span class="line">    int[] pre&#x3D;new int[3];&#x2F;&#x2F; pre[i]为买物品i，而能买的优先级比自己小的第一件东西</span><br><span class="line">    int[] opt&#x3D;new int[3];&#x2F;&#x2F;opt为买或不买第i件物品的最大值。</span><br><span class="line">    String[] S&#x3D;new String[3];&#x2F;&#x2F;优先级和物品名称对应关系</span><br><span class="line">    int[] chooses&#x3D;new int[3];&#x2F;&#x2F;opt i最大时买不买物品i,0为不买，1为买</span><br><span class="line">    int[] weight&#x3D;new int[3];</span><br><span class="line">    int[] price&#x3D;new int[3];</span><br><span class="line">    &#x2F;&#x2F;若买i物品的话，opt[i]为price[i]+opt[pre[i]]</span><br><span class="line">    &#x2F;&#x2F;若不买第i件物品的话，opt[i]为opt[i-1]</span><br><span class="line">    BeiBao()</span><br><span class="line">    &#123;</span><br><span class="line">        price[0]&#x3D;1500;</span><br><span class="line">        price[1]&#x3D;3000;</span><br><span class="line">        price[2]&#x3D;2000;</span><br><span class="line">        weight[0]&#x3D;1;</span><br><span class="line">        weight[1]&#x3D;4;</span><br><span class="line">        weight[2]&#x3D;3;</span><br><span class="line">        S[0]&#x3D;&quot;吉他&quot;;</span><br><span class="line">        S[1]&#x3D;&quot;音响&quot;;</span><br><span class="line">        S[2]&#x3D;&quot;电脑&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;3 ; i++) &#123;</span><br><span class="line">            pre[i]&#x3D;-1;</span><br><span class="line">            int j&#x3D;i-1;</span><br><span class="line">            while(j&gt;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                if((weight[i]+weight[j])&lt;&#x3D;4)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre[i]&#x3D;j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void beiBao()</span><br><span class="line">    &#123;</span><br><span class="line">        opt[0]&#x3D;price[0];</span><br><span class="line">        chooses[0]&#x3D;1;</span><br><span class="line">        System.out.println(&quot;opt &quot;+0+&quot; &#x3D;物品&quot;+S[0]+&quot;自身的价格&quot;+price[0]);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;3 ; i++) &#123;</span><br><span class="line">            if(pre[i]!&#x3D;-1)</span><br><span class="line">            &#123;</span><br><span class="line">                if(opt[i-1]&gt;(price[i]+opt[pre[i]]))</span><br><span class="line">                &#123;</span><br><span class="line">                    opt[i]&#x3D;opt[i-1];</span><br><span class="line">                    chooses[i]&#x3D;0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    opt[i]&#x3D;price[i]+opt[pre[i]];</span><br><span class="line">                    chooses[i]&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(opt[i-1]&gt;price[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    opt[i]&#x3D;opt[i-1];</span><br><span class="line">                    chooses[i]&#x3D;0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    opt[i]&#x3D;price[i];</span><br><span class="line">                    chooses[i]&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;最佳购买方法&quot;);</span><br><span class="line">        int k&#x3D;2;</span><br><span class="line">        while(k&gt;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">             if(chooses[k]&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(S[k]+&quot; &quot;);</span><br><span class="line">                k&#x3D;pre[k];</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">                k&#x3D;k-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契，记忆化搜索"><a href="#斐波那契，记忆化搜索" class="headerlink" title="斐波那契，记忆化搜索"></a><strong>斐波那契，记忆化搜索</strong></h3><p>由于使用只使用递归的时候会出现很多相同的子问题，并且递归的时候会重复计算，浪费掉大量的时间复杂度<br>递归斐波那契时间复杂度为O(n^ 2)<br>而若是使用数组记住已算过的斐波那契数，时间复杂度则会为O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Fibonacci_sequence</span><br><span class="line">&#123;</span><br><span class="line">     long[] fib;&#x2F;&#x2F;记录fib i</span><br><span class="line">    &#x2F;&#x2F;斐波那契，不递归方法,数组缓存</span><br><span class="line">   public   void Fibonacci_sequence_Array(int num)</span><br><span class="line">    &#123;   fib&#x3D;new long[num];</span><br><span class="line">        fib[0]&#x3D;1;</span><br><span class="line">        fib[1]&#x3D;1;</span><br><span class="line">        fibnacci_Array(num);</span><br><span class="line">    &#125;</span><br><span class="line">   private void fibnacci_Array(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;num ; i++) &#123;</span><br><span class="line">            fib[i]&#x3D;fib[i-1]+fib[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;fib &quot;+num+&quot;&#x3D;&quot;+fib[num-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;斐波那契，递归优化，记忆化搜索</span><br><span class="line">    public void Fibonacci_sequence_Memory(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        fib&#x3D;new long[num];</span><br><span class="line">        fib[0]&#x3D;1;</span><br><span class="line">        fib[1]&#x3D;1;</span><br><span class="line">        long l &#x3D; fibnacci_Mem(num-1);</span><br><span class="line">        System.out.println(&quot;fib &quot;+num+&quot;&#x3D;&quot;+l);</span><br><span class="line">    &#125;</span><br><span class="line">    private long fibnacci_Mem(int num) &#123;</span><br><span class="line">        if (fib[num] !&#x3D; 0)</span><br><span class="line">            return fib[num];</span><br><span class="line">        else &#123;</span><br><span class="line">            fib[num] &#x3D; fibnacci_Mem(num - 1) + fibnacci_Mem(num - 2);</span><br><span class="line">            return fib[num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/04/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="ckb22iuge00bfzwu88fdhhrap" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构/树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/" class="article-date">
  <time datetime="2020-03-02T06:50:51.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/">树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h2><h3 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a><strong>为什么需要树这种数据结构</strong></h3><ol>
<li>数组存储方式的分析<br>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度<br>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</li>
<li>链式存储方式的分析<br>优点：在一定程度上对数组存储方式有优化(6比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。<br>缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</li>
<li>树存储方式的分析<br>能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li>
</ol>
<h3 id="树的常用术语-结合示意图理解"><a href="#树的常用术语-结合示意图理解" class="headerlink" title="树的常用术语(结合示意图理解):"></a><strong>树的常用术语(结合示意图理解):</strong></h3><p>节点<br>根节点<br>父节点<br>子节点<br>叶子节点 (没有子节点的节点)<br>节点的权(节点值)<br>路径(从root节点找到该节点的路线)<br>层<br>子树<br>树的高度(最大层数)<br>森林 :多颗子树构成森林<br><img src="/images/42.png" alt=""></p>
<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><strong>二叉树的概念</strong></h3><p>1.树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。<br>2.二叉树的子节点分为左节点和右节点。<br>3.如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为<strong>满二叉树。</strong><br>4.如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为<strong>完全二叉树。</strong></p>
<h3 id="二叉树遍历的说明"><a href="#二叉树遍历的说明" class="headerlink" title="二叉树遍历的说明"></a><strong>二叉树遍历的说明</strong></h3><p>使用前序，中序和后序对下面的二叉树进行遍历.<br><strong>前序遍历:</strong> 先输出父节点，再遍历左子树和右子树<br><strong>中序遍历:</strong> 先遍历左子树，再输出父节点，再遍历右子树<br><strong>后序遍历:</strong> 先遍历左子树，再遍历右子树，最后输出父节点<br><strong>小结:</strong> 看输出父节点的顺序，就确定是前序，中序还是后序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先创建一个二叉树</span><br><span class="line">        BinaryTree binaryTree &#x3D; new BinaryTree();</span><br><span class="line">        &#x2F;&#x2F;创建需要的结点</span><br><span class="line">        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);</span><br><span class="line">        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);</span><br><span class="line">        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);</span><br><span class="line">        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);</span><br><span class="line">        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">		System.out.println(&quot;前序遍历&quot;); &#x2F;&#x2F; 1,2,3,5,4</span><br><span class="line">		binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">		System.out.println(&quot;中序遍历&quot;);</span><br><span class="line">		binaryTree.infixOrder(); &#x2F;&#x2F; 2,1,5,3,4</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;后序遍历&quot;);</span><br><span class="line">		binaryTree.postOrder(); &#x2F;&#x2F; 2,5,4,3,1</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(binaryTree.preSearch(1));</span><br><span class="line">        System.out.println(binaryTree.preSearch(2));</span><br><span class="line">        System.out.println(binaryTree.preSearch(3));</span><br><span class="line">        System.out.println(binaryTree.preSearch(4));</span><br><span class="line">        System.out.println(binaryTree.preSearch(5));</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(binaryTree.infixSearch(1));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(2));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(3));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(4));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(5));</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(binaryTree.postSearch(1));</span><br><span class="line">        System.out.println(binaryTree.postSearch(2));</span><br><span class="line">        System.out.println(binaryTree.postSearch(3));</span><br><span class="line">        System.out.println(binaryTree.postSearch(4));</span><br><span class="line">        System.out.println(binaryTree.postSearch(5));</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        binaryTree.deleteNode(6);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    private HeroNode root;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.preOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void postOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.postOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode preSearch(int no)</span><br><span class="line">    &#123;   if(this.root!&#x3D;null)</span><br><span class="line">            return root.preSearch(no);</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode infixSearch(int no)</span><br><span class="line">    &#123;   if(this.root!&#x3D;null)</span><br><span class="line">            return root.infixSearch(no);</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode postSearch(int no)</span><br><span class="line">    &#123;   if(this.root!&#x3D;null)</span><br><span class="line">            return root.postSearch(no);</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root.getNo()&#x3D;&#x3D;num)</span><br><span class="line">        &#123;</span><br><span class="line">            HeroNode temp&#x3D;root.getRight();</span><br><span class="line">            root&#x3D;root.getLeft();</span><br><span class="line">            if(root&#x3D;&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode T&#x3D;root;</span><br><span class="line">                while(T.getRight()!&#x3D;null)</span><br><span class="line">                &#123;</span><br><span class="line">                    T&#x3D;T.getRight();</span><br><span class="line">                &#125;</span><br><span class="line">                T.setRight(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;删除成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int i&#x3D; root.deleteNode(num);</span><br><span class="line">            if(i&#x3D;&#x3D;1)</span><br><span class="line">                System.out.println(&quot;删除成功&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;不存在该节点&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HeroNode</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int no;</span><br><span class="line">    private HeroNode left;</span><br><span class="line">    private HeroNode right;</span><br><span class="line">    &#x2F;&#x2F;三种遍历算法</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public void postOrder()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;三种查找算法</span><br><span class="line">   public HeroNode preSearch(int num)</span><br><span class="line">   &#123;</span><br><span class="line">       HeroNode resNode&#x3D;null;</span><br><span class="line">       System.out.print(&quot;* &quot;);</span><br><span class="line">       if(this.no&#x3D;&#x3D;num)</span><br><span class="line">           return this;</span><br><span class="line">       if(this.left!&#x3D;null)</span><br><span class="line">           resNode&#x3D;this.left.preSearch(num);</span><br><span class="line">       if(resNode!&#x3D;null)</span><br><span class="line">           return resNode;</span><br><span class="line">       if(this.right!&#x3D;null)</span><br><span class="line">           resNode&#x3D;this.right.preSearch(num);</span><br><span class="line">       return resNode;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    public HeroNode infixSearch(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.left.infixSearch(num);</span><br><span class="line">        if(resNode!&#x3D;null)</span><br><span class="line">            return resNode;</span><br><span class="line">        System.out.print(&quot;* &quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;num)</span><br><span class="line">            return this;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.right.infixSearch(num);</span><br><span class="line">        return resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode postSearch(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.left.postSearch(num);</span><br><span class="line">        if(resNode!&#x3D;null)</span><br><span class="line">            return resNode;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.right.postSearch(num);</span><br><span class="line">        if(resNode!&#x3D;null)</span><br><span class="line">            return resNode;</span><br><span class="line">        System.out.print(&quot;* &quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;num)</span><br><span class="line">            return this;</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;删除算法(先续）</span><br><span class="line">    public int deleteNode(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left.no&#x3D;&#x3D;num)</span><br><span class="line">            &#123;   HeroNode temp&#x3D;this.left.right;</span><br><span class="line">                this.left&#x3D;this.left.left;</span><br><span class="line">                HeroNode T&#x3D;this.left;</span><br><span class="line">                if(T&#x3D;&#x3D;null)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.left&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    while(T.right!&#x3D;null)</span><br><span class="line">                        T&#x3D;T.right;</span><br><span class="line">                    T.right&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">            if(this.left.deleteNode(num)&#x3D;&#x3D;1)</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right.no&#x3D;&#x3D;num)</span><br><span class="line">            &#123;   HeroNode temp&#x3D;this.right.left;</span><br><span class="line">                this.right&#x3D;this.right.right;</span><br><span class="line">                HeroNode T&#x3D;this.right;</span><br><span class="line">                if(T&#x3D;&#x3D;null)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.right&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    while(T.left!&#x3D;null)</span><br><span class="line">                        T&#x3D;T.left;</span><br><span class="line">                    T.left&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               return this.right.deleteNode(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode(int no,String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, no&#x3D;&quot; + no +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序存储二叉树-堆排序"><a href="#顺序存储二叉树-堆排序" class="headerlink" title="顺序存储二叉树(堆排序)"></a><strong>顺序存储二叉树(堆排序)</strong></h2><p><strong>顺序存储二叉树的概念</strong><br><strong>基本说明</strong><br>从数据存储来看，数组存储方式和树<br>的存储方式可以相互转换，即数组可<br>以转换成树，树也可以转换成数组，<br>看下面的示意图。<br><strong>要求:</strong><br>下图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]<br>要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历<br><img src="/images/30.png" alt=""><br><strong>顺序存储二叉树的特点:</strong></p>
<ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n个元素的左子节点为  2 * n + 1 </li>
<li>第n个元素的右子节点为  2 * n + 2</li>
<li>第n个元素的父节点为  (n-1) / 2</li>
<li>n : 表示二叉树中的第几个元素(按0开始编号如图所示)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class ArrBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">int[] arr&#x3D;&#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">ArrBinaryTree a&#x3D;new ArrBinaryTree(arr);</span><br><span class="line">a.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArrBinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    private int arr[];</span><br><span class="line"></span><br><span class="line">    public ArrBinaryTree(int[] arr) &#123;</span><br><span class="line">        this.arr &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        this.preOrder(0);</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr&#x3D;&#x3D;null&amp;&amp;arr.length&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;数组为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        if((2*index+1)&lt;arr.length)</span><br><span class="line">        &#123;</span><br><span class="line">            preOrder(2*index+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if((2*index+2)&lt;arr.length)</span><br><span class="line">        &#123;</span><br><span class="line">            preOrder(2*index+2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a><strong>线索化二叉树</strong></h2><p>先看一个问题<br>将数列 {1, 3, 6, 8, 10, 14  } 构建成一颗二叉树.  n+1=7<br><img src="/images/44.png" alt=""></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析:"></a><strong>问题分析:</strong></h3><ol>
<li>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }</li>
<li>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</li>
<li>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?</li>
<li>解决方案-线索二叉树</li>
</ol>
<h3 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a><strong>线索二叉树基本介绍</strong></h3><ol>
<li>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为前驱结点</li>
<li>一个结点的后一个结点，称为后继结点<br><img src="/images/45.png" alt=""></li>
</ol>
<p><strong>说明: 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况:</strong><br>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.<br>right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.<br><strong>代码只实现了中序线索化和遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class ThreadedBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试一把中序线索二叉树的功能</span><br><span class="line">        HeroNode1 root &#x3D; new HeroNode1(1, &quot;tom&quot;);</span><br><span class="line">        HeroNode1 node2 &#x3D; new HeroNode1(3, &quot;jack&quot;);</span><br><span class="line">        HeroNode1 node3 &#x3D; new HeroNode1(6, &quot;smith&quot;);</span><br><span class="line">        HeroNode1 node4 &#x3D; new HeroNode1(8, &quot;mary&quot;);</span><br><span class="line">        HeroNode1 node5 &#x3D; new HeroNode1(10, &quot;king&quot;);</span><br><span class="line">        HeroNode1 node6 &#x3D; new HeroNode1(14, &quot;dim&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试中序线索化</span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试: 以10号节点测试</span><br><span class="line">        HeroNode1 leftNode &#x3D; node5.getLeft();</span><br><span class="line">        HeroNode1 rightNode &#x3D; node5.getRight();</span><br><span class="line">        System.out.println(&quot;10号结点的前驱结点是 &#x3D;&quot;  + leftNode); &#x2F;&#x2F;3</span><br><span class="line">        System.out.println(&quot;10号结点的后继结点是&#x3D;&quot;  + rightNode); &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当线索化二叉树后，能在使用原来的遍历方法</span><br><span class="line">        &#x2F;&#x2F;threadedBinaryTree.infixOrder();</span><br><span class="line">        System.out.println(node3.getRight());</span><br><span class="line">        System.out.println(&quot;使用线索化的方式遍历 线索化二叉树&quot;);</span><br><span class="line">        threadedBinaryTree.threadedList(); &#x2F;&#x2F; 8, 3, 10, 1, 14, 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class ThreadedBinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    private HeroNode1 root;</span><br><span class="line">    &#x2F;&#x2F;为了实现线索化，需要创建一个前驱结点指针,在线索化的时候pre总是指向前一个节点</span><br><span class="line">    private HeroNode1 pre&#x3D;null;</span><br><span class="line">    &#x2F;&#x2F;编写对二叉树进行中序线索化的方法</span><br><span class="line">    public void threadedNodes()</span><br><span class="line">    &#123;</span><br><span class="line">        threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">    public void threadedList()</span><br><span class="line">    &#123;</span><br><span class="line">        HeroNode1 node&#x3D;root;</span><br><span class="line">        while(node!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            while(node.getLeftType()!&#x3D;1)</span><br><span class="line">                node&#x3D;node.getLeft();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            while(node.getRight()!&#x3D;null&amp;&amp;node.getRightType()&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                node&#x3D;node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node&#x3D;node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void threadedNodes(HeroNode1 node)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;node&#x3D;&#x3D;null</span><br><span class="line">        if(node&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;线索化左子树</span><br><span class="line">        threadedNodes(node.getLeft());</span><br><span class="line">        &#x2F;&#x2F;线索化当前节点</span><br><span class="line">        if(node.getLeft()&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre!&#x3D;null&amp;&amp;pre.getRight()&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        pre&#x3D;node;</span><br><span class="line">        &#x2F;&#x2F;线索化右子树</span><br><span class="line">        threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    public void setRoot(HeroNode1 root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class HeroNode1</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int no;</span><br><span class="line">    private HeroNode1 left;</span><br><span class="line">    private HeroNode1 right;</span><br><span class="line">    &#x2F;&#x2F;如果leftType&#x3D;&#x3D;0表示指向的是左子树，是1表示指向前驱结点</span><br><span class="line">    &#x2F;&#x2F;如果rightType&#x3D;&#x3D;0表示指向的是右子树，是1表示指向后继结点</span><br><span class="line">    private int leftType;</span><br><span class="line">    private int rightType;</span><br><span class="line"></span><br><span class="line">    public int getLeftType() &#123;</span><br><span class="line">        return leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftType(int leftType) &#123;</span><br><span class="line">        this.leftType &#x3D; leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRightType() &#123;</span><br><span class="line">        return rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightType(int rightType) &#123;</span><br><span class="line">        this.rightType &#x3D; rightType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public HeroNode1(int no,String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode1 left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode1 right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode1&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, no&#x3D;&quot; + no +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a><strong>赫夫曼树</strong></h2><p><strong>基本介绍</strong></p>
<ol>
<li>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li>
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</li>
</ol>
<p><strong>赫夫曼树几个重要概念和举例说明</strong></p>
<ol>
<li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li>树的带权路径长度：树的带权路径长度规定为所有<strong>叶子结点</strong>的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li>
<li>WPL最小的就是赫夫曼树<br><img src="/images/56.png" alt=""></li>
</ol>
<p><strong>构成赫夫曼树的步骤：</strong></p>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树 </li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </li>
<li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class HuffmanTree&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[]&#x3D;&#123;13, 7, 8, 3, 29, 6, 1&#125;;</span><br><span class="line">        Node n&#x3D;createHuffman(arr);</span><br><span class="line">        n.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public static  void preOrder(Node root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null)</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">        else</span><br><span class="line">            root.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public  static Node createHuffman(int arr[])</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            Node node&#x3D;new Node(i);</span><br><span class="line"></span><br><span class="line">            nodes.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        while(nodes.size()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            Node left&#x3D;nodes.get(0);</span><br><span class="line">            Node right&#x3D;nodes.get(1);</span><br><span class="line">            Node parent&#x3D;new Node(left.value+right.value);</span><br><span class="line">            parent.left&#x3D;left;</span><br><span class="line">            parent.right&#x3D;right;</span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;为了让Node支持排序，让Node实现Comparable接口</span><br><span class="line">class Node implements Comparable&lt;Node&gt;</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示从小到大排序</span><br><span class="line">        return this.value-o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a><strong>赫夫曼编码</strong></h2><p><strong>基本介绍</strong></p>
<ol>
<li>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</li>
<li>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ol>
<h3 id="定长编码原理剖析"><a href="#定长编码原理剖析" class="headerlink" title="定长编码原理剖析"></a><strong>定长编码原理剖析</strong></h3><pre><code>通信领域中信息的处理方式1-定长编码
i like like like java do you like a java       // 共40个字符(包括空格)  
105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  //对应Ascii码
01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制
按照二进制来传递信息，总的长度是  359   (包括空格)        </code></pre><h3 id="变长编码原理剖析"><a href="#变长编码原理剖析" class="headerlink" title="变长编码原理剖析"></a><strong>变长编码原理剖析</strong></h3><pre><code>通信领域中信息的处理方式2-变长编码
i like like like java do you like a java       // 共40个字符(包括空格)
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.
按照上面给各个字符规定的编码，则我们在传输  &quot;i like like like java do you like a java&quot; 数据时，编码就是 10010110100...  
字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码(这个在赫夫曼编码中，我们还要进行举例说明, 不捉急)</code></pre><h3 id="赫夫曼编码原理剖析"><a href="#赫夫曼编码原理剖析" class="headerlink" title="赫夫曼编码原理剖析"></a><strong>赫夫曼编码原理剖析</strong></h3><pre><code>通信领域中信息的处理方式3-赫夫曼编码
i like like like java do you like a java       // 共40个字符(包括空格)
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值.(图后)</code></pre><p><img src="/images/57.png" alt=""></p>
<pre><code>根据赫夫曼树，给各个字符规定编码 ， 向左的路径为0，向右的路径为1 ， 编码如下:
o: 1000   u: 10010  d: 100110  y: 100111  i: 101
a : 110     k: 1110    e: 1111       j: 0000       v: 0001
l: 001          : 01
按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot;   字符串对应的编码为 (注意这里我们使用的无损压缩)
1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110
长度为 ： 133 
说明:
原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%
此编码满足前缀编码, 因为只有叶子节点才算入赫夫曼树，而若是前缀冲突的话其中必有一个不是叶子结点。即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性
注意： 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的（相同权值的前后问题）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class HuffmanCode &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;*String content&#x3D;&quot;i like like like java do you like a java&quot;;</span><br><span class="line">        byte[] b&#x3D;content.getBytes();</span><br><span class="line">        byte[] bytes &#x3D; zip(b);</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        byte[] bs &#x3D; decode(codes, bytes);</span><br><span class="line">        System.out.println(&quot;原来的字符串&#x3D;&quot; + new String(bs));*&#x2F;</span><br><span class="line">    String srcFile&#x3D;&quot;C:\\Users\\wjh\\Pictures\\Saved Pictures\\ccc.bmp&quot;;</span><br><span class="line">    String dstFile&#x3D;&quot;C:\\Users\\wjh\\Pictures\\Saved Pictures\\111.zip&quot;;</span><br><span class="line">    String dstFile1&#x3D;&quot;C:\\Users\\wjh\\Pictures\\Saved Pictures\\ccc1.bmp&quot;;</span><br><span class="line">    zipFile(srcFile,dstFile);</span><br><span class="line">        System.out.println(&quot;文件压缩成功&quot;);</span><br><span class="line">    unZipFile(dstFile,dstFile1);</span><br><span class="line">        System.out.println(&quot;文件解压成功&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存储叶子结点的路径</span><br><span class="line">    static StringBuilder s1&#x3D;new StringBuilder();</span><br><span class="line">    &#x2F;&#x2F;将赫夫曼编码表放到map中</span><br><span class="line">    static HashMap&lt;Byte,String&gt; codes&#x3D;new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void unZipFile(String zipFile, String dstFile) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义文件输入流</span><br><span class="line">        InputStream is &#x3D;  new FileInputStream(zipFile);</span><br><span class="line">        &#x2F;&#x2F;定义一个对象输入流</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(is);</span><br><span class="line">        &#x2F;&#x2F;定义文件的输出流</span><br><span class="line">        OutputStream os &#x3D; new FileOutputStream(dstFile);</span><br><span class="line">        &#x2F;&#x2F;读取byte数组  huffmanBytes</span><br><span class="line">        byte[] huffmanBytes &#x3D; (byte[])ois.readObject();</span><br><span class="line">        &#x2F;&#x2F;读取赫夫曼编码表</span><br><span class="line">        Map&lt;Byte,String&gt; huffmanCodes &#x3D; (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line">        &#x2F;&#x2F;解码</span><br><span class="line">        byte[] bytes &#x3D; decode(codes, huffmanBytes);</span><br><span class="line">        &#x2F;&#x2F;将bytes 数组写入到目标文件</span><br><span class="line">        &#x2F;&#x2F;写数据到 dstFile 文件</span><br><span class="line">        os.write(bytes);</span><br><span class="line">        os.close();</span><br><span class="line">        ois.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;编写一个方法，将一个文件进行压缩</span><br><span class="line">    public static void zipFile(String srcFile,String dstFile) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建输出流，存放压缩文件</span><br><span class="line">        OutputStream os&#x3D;new FileOutputStream(dstFile);</span><br><span class="line">        &#x2F;&#x2F;创建文件的输入流</span><br><span class="line">        FileInputStream is &#x3D; new FileInputStream(srcFile);</span><br><span class="line">        &#x2F;&#x2F;创建和文件输出流关联的ObjectOutputStream</span><br><span class="line">        ObjectOutputStream oos &#x3D; new ObjectOutputStream(os);</span><br><span class="line">        &#x2F;&#x2F;读取文件</span><br><span class="line">       byte[] bs&#x3D;new byte[is.available()];</span><br><span class="line">        is.read(bs);</span><br><span class="line">        is.close();</span><br><span class="line">        byte[] huffmanBytes&#x3D;zip(bs);</span><br><span class="line">        &#x2F;&#x2F;这里以对象流的方式写入赫夫曼编码，为的是我们恢复文件时使用</span><br><span class="line">        oos.writeObject(huffmanBytes);</span><br><span class="line">        &#x2F;&#x2F;这里一定要把赫夫曼编码写入压缩文件</span><br><span class="line">        oos.writeObject(codes);</span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对字符串进行压缩</span><br><span class="line">     * @param bs 传入要压缩的字节数组</span><br><span class="line">     * @return  压缩过后的字节数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] zip(byte[] bs)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;char[] chars&#x3D;content.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;NodeChar&gt; nodes &#x3D; getNodes(bs);</span><br><span class="line">        NodeChar huffman &#x3D; createHuffman(nodes);</span><br><span class="line">        HashMap&lt;Byte,String&gt; huffmanCodes&#x3D;getCodes(huffman);</span><br><span class="line">        StringBuilder s2&#x3D;new StringBuilder();</span><br><span class="line">        for (byte c : bs) &#123;</span><br><span class="line">            s2.append(huffmanCodes.get(c));</span><br><span class="line">        &#125;</span><br><span class="line">       &#x2F;&#x2F; System.out.println(s2.length());</span><br><span class="line">       &#x2F;&#x2F; System.out.println(s2.toString());</span><br><span class="line">        &#x2F;&#x2F;先计算要返回的bytes数组的长度</span><br><span class="line">        &#x2F;&#x2F;int len&#x3D;(s2.length()+7)&#x2F;8</span><br><span class="line">        int len;</span><br><span class="line">        if(s2.length()%8&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            len&#x3D;s2.length()&#x2F;8;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            len&#x3D;s2.length()&#x2F;8+1;</span><br><span class="line">        byte[] bytes&#x3D;new byte[len];</span><br><span class="line">        for (int i &#x3D; 0,index&#x3D;0; i &lt;s2.length() ; i+&#x3D;8,index++) &#123;</span><br><span class="line">            String S;</span><br><span class="line">            if(i+8&gt;s2.length())</span><br><span class="line">                S&#x3D;s2.substring(i);</span><br><span class="line">            else</span><br><span class="line">            S&#x3D;s2.substring(i,i+8);</span><br><span class="line">            bytes[index]&#x3D;(byte)Integer.parseInt(S,2);&#x2F;&#x2F;radix:2,转为二进制</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return bytes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param huffmanCodes 得到的哈弗曼编码表</span><br><span class="line">     * @param huffmanBytes 被压缩后的字节数组</span><br><span class="line">     * @return 原字符数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] decode(HashMap&lt;Byte,String&gt; huffmanCodes,byte[] huffmanBytes)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.先得到huffmanBytes对应的二进制字符串</span><br><span class="line">        StringBuilder stringBuilder&#x3D;new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;将Byte数组转成二进制字符串</span><br><span class="line">        for (int i &#x3D; 0; i &lt;huffmanBytes.length ; i++) &#123;</span><br><span class="line">            boolean flag&#x3D;(i&#x3D;&#x3D;huffmanBytes.length-1);</span><br><span class="line">            stringBuilder.append(byteToBiString(!flag,huffmanBytes[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把字符串按照指定的赫夫曼编发进行解码</span><br><span class="line">        HashMap&lt;String,Byte&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;Byte, String&gt; c : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(c.getValue(),c.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个集合，存放byte</span><br><span class="line">        List&lt;Byte&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;stringBuilder.length() ; ) &#123;</span><br><span class="line">            int count&#x3D;1;</span><br><span class="line">            boolean flag&#x3D;true;</span><br><span class="line">            Byte b&#x3D;null;</span><br><span class="line">            while(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                String key&#x3D;stringBuilder.substring(i,i+count);</span><br><span class="line">                b&#x3D;map.get(key);</span><br><span class="line">                if(b&#x3D;&#x3D;null)</span><br><span class="line">                    count++;</span><br><span class="line">                else</span><br><span class="line">                    flag&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i+&#x3D;count;</span><br><span class="line">        &#125;</span><br><span class="line">        byte b[] &#x3D; new byte[list.size()];</span><br><span class="line">        for(int i &#x3D; 0;i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param flag 看是否需要补高位，true表示需要，false表示不需要，如果是最后一个字节无需补高位</span><br><span class="line">     * @param b   传入的byte</span><br><span class="line">     * @return b对应的二进制字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToBiString(boolean flag,byte b)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;使用一个变量保存b</span><br><span class="line">        int temp&#x3D;b;</span><br><span class="line">        if(flag)</span><br><span class="line">            &#x2F;&#x2F;如果是正数，且是满8位的字节，我们需要补高位，如果是负数也无所谓结果不变。</span><br><span class="line">            temp |&#x3D;256;&#x2F;&#x2F;按位或256： 1 0000 0000 补高位</span><br><span class="line">        String str&#x3D;Integer.toBinaryString(temp);</span><br><span class="line">        if(flag)</span><br><span class="line">            return  str.substring(str.length()-8);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(temp&lt;0)</span><br><span class="line">            return str.substring(str.length()-8);</span><br><span class="line">            else</span><br><span class="line">                return str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static HashMap&lt;Byte,String&gt; getCodes(NodeChar node)</span><br><span class="line">    &#123;</span><br><span class="line">        getCodes(node,&quot;&quot;,s1);</span><br><span class="line">        return codes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param node 传入节点</span><br><span class="line">     * @param code 路径，左子节点是0，右子节点是1</span><br><span class="line">     * @param s2   拼接路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void getCodes(NodeChar node,String code,StringBuilder s2)</span><br><span class="line">    &#123;       StringBuilder s3&#x3D;new StringBuilder(s2);</span><br><span class="line">            s3.append(code);</span><br><span class="line">            if(node!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                if(node.data&#x3D;&#x3D;null)&#x2F;&#x2F;是非叶子节点</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;因为哈夫曼树的非叶子节点左右子树必不为空，所以直接递归</span><br><span class="line">                    getCodes(node.left,&quot;0&quot;,s3);</span><br><span class="line">                    getCodes(node.right,&quot;1&quot;,s3);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                   codes.put(node.data,s3.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param chars 接收的字符数组</span><br><span class="line">     * @return 存放将chars按每个字符个数转化成NodeChar的List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static List&lt;NodeChar&gt; getNodes(byte[] chars)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;NodeChar&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Byte,Integer&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for (Byte c : chars) &#123;</span><br><span class="line">            Integer count&#x3D;map.get(c);</span><br><span class="line">            if(count&#x3D;&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(c,1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(c,count+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Byte, Integer&gt; c : map.entrySet()) &#123;</span><br><span class="line">            NodeChar node&#x3D;new NodeChar(c.getKey(),c.getValue());</span><br><span class="line">            list.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static NodeChar createHuffman(List&lt;NodeChar&gt;  nodes)</span><br><span class="line">    &#123;</span><br><span class="line">        while(nodes.size()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            NodeChar lift&#x3D;nodes.get(0);</span><br><span class="line">            NodeChar right&#x3D;nodes.get(1);</span><br><span class="line">            NodeChar parent&#x3D;new NodeChar(null,lift.weight+right.weight);</span><br><span class="line">            parent.left&#x3D;lift;</span><br><span class="line">            parent.right&#x3D;right;</span><br><span class="line">            nodes.remove(lift);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class NodeChar implements Comparable&lt;NodeChar&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Byte data;</span><br><span class="line">    int weight;</span><br><span class="line">    NodeChar left;</span><br><span class="line">    NodeChar right;</span><br><span class="line"></span><br><span class="line">    public NodeChar(Byte data, int weight) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.weight &#x3D; weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(NodeChar o) &#123;</span><br><span class="line">        return this.weight-o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;NodeChar&#123;&quot; +</span><br><span class="line">                &quot;data&#x3D;&quot; + data +</span><br><span class="line">                &quot;, weight&#x3D;&quot; + weight +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(data!&#x3D;null)</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>1.如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件  [举例压一个 .ppt]<br>2.赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件]<br>3.如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. </p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><strong>二叉排序树</strong></h2><ol>
<li>使用数组<br>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢.<br>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。</li>
<li>使用链式存储-链表不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</li>
<li>使用二叉排序树<br>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点<br>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：<br><img src="/images/58.jpg" alt=""><br><img src="/images/59.jpg" alt=""></li>
</ol>
<p>二叉排序树的添加和遍历比较简单<br>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑<br><strong>1.删除叶子节点 (比如：2, 5, 9, 12)</strong><br>思路(1) 需求先去找到要删除的结点 targetNode<br>(2) 找到 targetNode 的 父结点 parent<br>(3) 确定 targetNode 是 parent 的左子结点 还是右子结点<br>(4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null;<br><strong>2.删除只有一颗子树的节点 (比如：1)</strong><br>思路<br>(1) 需求先去找到要删除的结点 targetNode<br>(2) 找到 targetNode 的 父结点 parent<br>(3) 确定 targetNode 的子结点是左子结点还是右子结点<br>(4) targetNode 是 parent 的左子结点还是右子结点<br>(5) 如果 targetNode 有左子结点<br>5.1 如果 targetNode 是 parent 的左子结点<br>parent.left = targetNode.left;<br>5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left;<br>(6) 如果 targetNode 有右子结点 6.1 如果 targetNode 是 parent 的左子结点     parent.left = targetNode.right; 6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right<br><strong>3.删除有两颗子树的节点. (比如：7, 3，10 )</strong><br>思路<br>(1) 需求先去找到要删除的结点 targetNode<br>(2) 找到 targetNode 的 父结点 parent<br>(3) 从 targetNode 的右子树找到最小的结点<br>(4) 用一个临时变量，将 最小结点的值保存 temp = 11<br>(5) 删除该最小结点<br>(6) targetNode.value = temp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class BinarySortTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;7,3,10,12,5,1,9&#125;;</span><br><span class="line">        BinarySortTree binarySortTree&#x3D;new BinarySortTree();</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            binarySortTree.add(new NodeBS(i));</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.infixOrderln();</span><br><span class="line">        binarySortTree.add(new NodeBS(2));</span><br><span class="line">        binarySortTree.infixOrderln();</span><br><span class="line">        binarySortTree.deleteNode(2);</span><br><span class="line">        binarySortTree.deleteNode(5);</span><br><span class="line">        binarySortTree.deleteNode(9);</span><br><span class="line">        binarySortTree.deleteNode(12);</span><br><span class="line">        binarySortTree.deleteNode(7);</span><br><span class="line">        binarySortTree.deleteNode(3);</span><br><span class="line">        binarySortTree.deleteNode(10);</span><br><span class="line">        binarySortTree.deleteNode(1);</span><br><span class="line"></span><br><span class="line">        binarySortTree.infixOrderln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BinarySortTree</span><br><span class="line">&#123;</span><br><span class="line">    private NodeBS root;</span><br><span class="line">    public void add(NodeBS node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null)</span><br><span class="line">            root&#x3D;node;</span><br><span class="line">        else</span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrderln()</span><br><span class="line">    &#123;</span><br><span class="line">        this.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该二叉排序树为空不可以遍历&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        NodeBS nodeD &#x3D; root.search(value);</span><br><span class="line">        if(nodeD&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;不存在该结点&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeBS nodeF &#x3D; root.searchParent(value);</span><br><span class="line">        if(nodeF!&#x3D;null)&#x2F;&#x2F;不是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.right&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.right;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.left;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeBS min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min.value);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#x2F;&#x2F;要删除的节点是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">               root&#x3D;null;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">               root&#x3D;root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeBS min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min.value);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class NodeBS</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    NodeBS left;</span><br><span class="line">    NodeBS right;</span><br><span class="line"></span><br><span class="line">    public NodeBS(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加结点的方法</span><br><span class="line">    public  void add(NodeBS node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node&#x3D;&#x3D;null)</span><br><span class="line">            return;</span><br><span class="line">        if(node.value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left&#x3D;&#x3D;null)</span><br><span class="line">                this.left&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.left.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right&#x3D;&#x3D;null)</span><br><span class="line">                this.right&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.right.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找指定节点</span><br><span class="line">     public NodeBS search(int value)</span><br><span class="line">     &#123;</span><br><span class="line">         if(value&#x3D;&#x3D;this.value)</span><br><span class="line">             return this;</span><br><span class="line">         else if(this.left!&#x3D;null&amp;&amp;value&lt;this.value)</span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">             return this.left.search(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(this.right!&#x3D;null&amp;&amp;value&gt;&#x3D;this.value)</span><br><span class="line">         &#123;</span><br><span class="line">             return  this.right.search(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             return  null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;寻找指定节点的父结点</span><br><span class="line">     public NodeBS searchParent(int value)</span><br><span class="line">     &#123;</span><br><span class="line">         if((this.left!&#x3D;null&amp;&amp;this.left.value&#x3D;&#x3D;value)</span><br><span class="line">                 ||(this.right!&#x3D;null&amp;&amp;this.right.value&#x3D;&#x3D;value))</span><br><span class="line">         &#123;</span><br><span class="line">             return this;</span><br><span class="line">         &#125;</span><br><span class="line">         else if(this.left!&#x3D;null&amp;&amp;value&lt;this.value)</span><br><span class="line">         &#123;</span><br><span class="line">            return this.left.searchParent(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else  if (this.right!&#x3D;null&amp;&amp;value&gt;&#x3D;this.value)</span><br><span class="line">         &#123;</span><br><span class="line">             return this.right.searchParent(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">             return null;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找该节点右子树下的最小节点,该节点必有右子树的情况下</span><br><span class="line">    public NodeBS serchMin()</span><br><span class="line">    &#123;</span><br><span class="line">        NodeBS r&#x3D;this.right;</span><br><span class="line">        while(r.left!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            r&#x3D;r.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public  void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        System.out.print(this);</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;  &quot;+value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a><strong>平衡二叉树(AVL树)</strong></h2><p><strong>看一个案例(说明二叉排序树可能的问题)</strong><br>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.<br><img src="/images/60.png" alt=""><br><strong>左边BST 存在的问题分析:</strong><br>左子树全部为空，从形式上看，更像一个单链表.<br>插入速度没有影响<br>查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢<br>解决方案-平衡二叉树(AVL) </p>
<p><strong>基本介绍</strong><br>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。<br>具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
<h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a><strong>单旋转</strong></h3><p><strong>左旋转</strong><br><img src="/images/61.png" alt=""><br>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void leftRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的左子树设置成当前节点的左子树</span><br><span class="line">        nodeAvl.left&#x3D;left;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的右子树设置成当前节点的右子树的左子树</span><br><span class="line">        nodeAvl.right&#x3D;this.right.left;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为右子节点的值</span><br><span class="line">        this.value&#x3D;this.right.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的右子树设置成右子树的右子树</span><br><span class="line">        this.right&#x3D;this.right.right;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的左子树设为新节点</span><br><span class="line">        this.left&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>右旋转</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void rightRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的右子树设置成当前节点的右子树</span><br><span class="line">        nodeAvl.right&#x3D;right;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的左子树设置成当前节点的左子树的右子树</span><br><span class="line">        nodeAvl.left&#x3D;this.left.right;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为左子节点的值</span><br><span class="line">        this.value&#x3D;this.left.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的左子树设置成左子树的左子树</span><br><span class="line">        this.left&#x3D;this.left.left;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的右子树设为新节点</span><br><span class="line">        this.right&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a><strong>双旋转</strong></h2><p><strong>由于单旋转有时候并不能解决问题，例如原先左子树高度比右子树高度高2，但右旋转之后右子树高度又比左子树高2</strong><br><strong>所以旋转完还是非平衡二叉树</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void doubleRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        if(rightHeight()-leftHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right.leftHeight()&gt;this.right.rightHeight())</span><br><span class="line">                this.right.rightRoate();</span><br><span class="line">            this.leftRoate();</span><br><span class="line">        &#125;</span><br><span class="line">        if(leftHeight()-rightHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left.rightHeight()&gt;this.left.leftHeight())</span><br><span class="line">                this.left.leftRoate();</span><br><span class="line">            this.rightRoate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>总代码(其中删除节点的方法可能出现问题，若二叉树中的重复值过多)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class AvlTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr1&#x3D;&#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14&#125;;</span><br><span class="line">       &#x2F;&#x2F; int[] arr&#x3D;&#123;14,13,12,11,10,9,8,7,6,5,4,3,2,1&#125;;</span><br><span class="line">       &#x2F;&#x2F; int arr[]&#x3D;&#123;10,12,8,9,7,6&#125;;</span><br><span class="line">       &#x2F;&#x2F; int arr[]&#x3D;&#123;10,11,7,6,8,9&#125;;</span><br><span class="line">        int[] arr&#x3D;new int[200];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;200; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*200);</span><br><span class="line">        &#125;</span><br><span class="line">        AvlTree avlTree&#x3D;new AvlTree();</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            avlTree.add(new NodeAvl(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;中序遍历&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class AvlTree</span><br><span class="line">&#123;</span><br><span class="line">    private NodeAvl root;</span><br><span class="line"></span><br><span class="line">    public NodeAvl getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        NodeAvl nodeD &#x3D; root.search(value);</span><br><span class="line">        deleteNode(nodeD);</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(NodeAvl nodeD)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(nodeD&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;不存在该结点&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeAvl nodeF &#x3D; root.searchParent(nodeD);</span><br><span class="line">        if(nodeF!&#x3D;null)&#x2F;&#x2F;不是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.right&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.right;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.left;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeAvl min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#x2F;&#x2F;要删除的节点是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;null;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeAvl min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nodeF!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            nodeF.doubleRoate();</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.doubleRoate();</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(NodeAvl node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null)</span><br><span class="line">            root&#x3D;node;</span><br><span class="line">        else</span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrderln()</span><br><span class="line">    &#123;</span><br><span class="line">        this.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该二叉排序树为空不可以遍历&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class NodeAvl</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    NodeAvl left;</span><br><span class="line">    NodeAvl right;</span><br><span class="line"></span><br><span class="line">    public NodeAvl(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回以该节点为根节点的树的高度</span><br><span class="line">    public  int leftHeight()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            return this.left.height();</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public int rightHeight()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            return this.right.height();</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public int height()</span><br><span class="line">    &#123;</span><br><span class="line">        return Math.max(left&#x3D;&#x3D;null?0:left.height(),right&#x3D;&#x3D;null?0:right.height())+1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加结点的方法</span><br><span class="line">    public  void add(NodeAvl node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node&#x3D;&#x3D;null)</span><br><span class="line">            return;</span><br><span class="line">        if(node.value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left&#x3D;&#x3D;null)</span><br><span class="line">                this.left&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.left.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right&#x3D;&#x3D;null)</span><br><span class="line">                this.right&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.right.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为是root调用的，所以按理来说会经过添加节点时所经过的所有节点</span><br><span class="line">        &#x2F;&#x2F;也就是说递归调用的时候就可以进行判断和调整</span><br><span class="line">        this.doubleRoate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void doubleRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        if(rightHeight()-leftHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right.leftHeight()&gt;this.right.rightHeight())</span><br><span class="line">                this.right.rightRoate();</span><br><span class="line">            this.leftRoate();</span><br><span class="line">        &#125;</span><br><span class="line">        if(leftHeight()-rightHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left.rightHeight()&gt;this.left.leftHeight())</span><br><span class="line">                this.left.leftRoate();</span><br><span class="line">            this.rightRoate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void rightRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的右子树设置成当前节点的右子树</span><br><span class="line">        nodeAvl.right&#x3D;right;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的左子树设置成当前节点的左子树的右子树</span><br><span class="line">        nodeAvl.left&#x3D;this.left.right;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为左子节点的值</span><br><span class="line">        this.value&#x3D;this.left.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的左子树设置成左子树的左子树</span><br><span class="line">        this.left&#x3D;this.left.left;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的右子树设为新节点</span><br><span class="line">        this.right&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br><span class="line">    private void leftRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的左子树设置成当前节点的左子树</span><br><span class="line">        nodeAvl.left&#x3D;left;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的右子树设置成当前节点的右子树的左子树</span><br><span class="line">        nodeAvl.right&#x3D;this.right.left;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为右子节点的值</span><br><span class="line">        this.value&#x3D;this.right.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的右子树设置成右子树的右子树</span><br><span class="line">        this.right&#x3D;this.right.right;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的左子树设为新节点</span><br><span class="line">        this.left&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找指定节点</span><br><span class="line">    public NodeAvl search(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        if(value&#x3D;&#x3D;this.value)</span><br><span class="line">            return this;</span><br><span class="line">        else if(this.left!&#x3D;null&amp;&amp;value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.right!&#x3D;null&amp;&amp;value&gt;&#x3D;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            return  this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return  null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找指定节点的父结点</span><br><span class="line">    public NodeAvl searchParent(NodeAvl NodeAvl)</span><br><span class="line">    &#123;</span><br><span class="line">        if((this.left!&#x3D;null&amp;&amp;this.left.value&#x3D;&#x3D;NodeAvl.value&amp;&amp;this.left&#x3D;&#x3D;NodeAvl)</span><br><span class="line">                ||(this.right!&#x3D;null&amp;&amp;this.right.value&#x3D;&#x3D;NodeAvl.value&amp;&amp;this.right&#x3D;&#x3D;NodeAvl))</span><br><span class="line">        &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.left!&#x3D;null&amp;&amp;NodeAvl.value&lt;&#x3D;this.value)</span><br><span class="line">        &#123;       if(this.left.searchParent(NodeAvl)!&#x3D;null)</span><br><span class="line">            return this.left.searchParent(NodeAvl);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right!&#x3D;null&amp;&amp;NodeAvl.value&gt;&#x3D;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            return this.right.searchParent(NodeAvl);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找该节点右子树下的最小节点,该节点必有右子树的情况下</span><br><span class="line">    public NodeAvl serchMin()</span><br><span class="line">    &#123;</span><br><span class="line">        NodeAvl r&#x3D;this.right;</span><br><span class="line">        while(r.left!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            r&#x3D;r.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public  void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        System.out.print(this);</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value+&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树与B树"><a href="#二叉树与B树" class="headerlink" title="二叉树与B树"></a><strong>二叉树与B树</strong></h2><h3 id="二叉树的问题分析"><a href="#二叉树的问题分析" class="headerlink" title="二叉树的问题分析"></a><strong>二叉树的问题分析</strong></h3><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树<br>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:<br>问题1：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响<br>问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</p>
<h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a><strong>多叉树</strong></h3><p>1.在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）<br>2.后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。<br>3.举例说明(下面2-3树就是一颗多叉树)<br><img src="/images/62.png" alt=""></p>
<h3 id="B树-多叉树的一种-的基本介绍"><a href="#B树-多叉树的一种-的基本介绍" class="headerlink" title="B树(多叉树的一种)的基本介绍"></a><strong>B树(多叉树的一种)的基本介绍</strong></h3><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p>
<ol>
<li>如图B树通过重新组织节点， 降低了树的高度.</li>
<li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</li>
<li>将树的度(节点的度为结点子节点的个数，树的度为最大节点度)M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中<br><img src="/images/63.png" alt=""></li>
</ol>
<p><strong>2-3树</strong><br><strong>2-3树基本介绍</strong><br>2-3树是最简单的B树结构, 具有如下特点:</p>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，且三节点本就有两个结点值.</li>
<li>2-3树是由二节点和三节点构成的树。<br><img src="/images/64.png" alt=""></li>
</ol>
<p><strong>插入规则:</strong></p>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，左子节点小于本结点右子节点大于本结点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，左子节点小于左节点，中子节点大于左节点小于右节点，右子节点大于右节点。</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。 </li>
<li>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</li>
</ol>
<h3 id="B树、B-树和B-树"><a href="#B树、B-树和B-树" class="headerlink" title="B树、B+树和B* 树"></a><strong>B树、B+树和B* 树</strong></h3><h4 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a><strong>B树的介绍</strong></h4><p> B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。<br>前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:<br>B树的说明:</p>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找<br><img src="/images/65.png" alt=""></li>
</ol>
<h4 id="B-树的介绍"><a href="#B-树的介绍" class="headerlink" title="B+树的介绍"></a><strong>B+树的介绍</strong></h4><p>B+树是B树的变体，也是一种多路搜索树。<strong>相当于将单链表分割检索</strong><br><strong>B+树的说明:</strong></p>
<ol>
<li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.<br><img src="/images/66.png" alt=""></li>
</ol>
<h4 id="B-树的介绍-1"><a href="#B-树的介绍-1" class="headerlink" title="B* 树的介绍"></a><strong>B* 树的介绍</strong></h4><p>B* 树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。<br>B* 树的说明:</p>
<ol>
<li>B* 树定义了非叶子结点关键字个数至少为(2/3)* M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>从第1个特点我们可以看出，B* 树分配新结点的概率比B+树要低，空间使用率更高</li>
<li>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</li>
<li>B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B* 树分配新结点的概率比B+树要低，空间使用率更高；<br><img src="/images/67.png" alt=""></li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><ol>
<li>二叉树：每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</li>
<li>B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>
<li>B+树：在B树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>
<li>B* 树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/" data-id="ckb22iug700aqzwu8fc4b888p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/分治算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-02T05:06:19.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/">分治算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法二：分治算法"><a href="#算法二：分治算法" class="headerlink" title="算法二：分治算法"></a><strong>算法二：分治算法</strong></h2><p><strong>分治算法介绍</strong><br>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……<br><strong>分治算法可以求解的一些经典问题</strong></p>
<blockquote>
<p>二分搜索<br>    大整数乘法<br>    棋盘覆盖<br>    合并排序<br>    快速排序<br>    线性时间选择<br>    最接近点对问题<br>    循环赛日程表<br>    汉诺塔</p>
</blockquote>
<p><strong>分治算法的基本步骤</strong><br>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解。<br>分治(Divide-and-Conquer(P))算法设计模式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if |P|≤n0</span><br><span class="line">   then return(ADHOC(P))</span><br><span class="line">&#x2F;&#x2F;将P分解为较小的子问题 P1 ,P2 ,…,Pk</span><br><span class="line">for i←1 to k</span><br><span class="line">do yi ← Divide-and-Conquer(Pi)   递归解决Pi</span><br><span class="line">T ← MERGE(y1,y2,…,yk)   合并子问题</span><br><span class="line">return(T)</span><br></pre></td></tr></table></figure>
其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</li>
</ol>
<p><strong>汉诺塔</strong><br>汉诺塔的传说<br>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p>
<h3 id="汉诺塔游戏的演示和思路分析"><a href="#汉诺塔游戏的演示和思路分析" class="headerlink" title="汉诺塔游戏的演示和思路分析"></a><strong>汉诺塔游戏的演示和思路分析</strong></h3><ol>
<li>如果是有一个盘， A-&gt;C<br>如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</li>
<li>先把 最上面的盘 A-&gt;B</li>
<li>把最下边的盘 A-&gt;C</li>
<li>把B塔的所有盘 从 B-&gt;C <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package 算法;</span><br><span class="line"></span><br><span class="line">public class Divide_and_Conquer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    hanoiTower(5,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);</span><br><span class="line">        System.out.println(times);</span><br><span class="line">    &#125;</span><br><span class="line">static int times;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param num 需要移动多少个盘子</span><br><span class="line">     * @param a   盘子原先的地方</span><br><span class="line">     * @param b   中间借用的辅助地方</span><br><span class="line">     * @param c   盘子的目的地</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public  static void hanoiTower(int num,char a,char b,char c)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1. 如果是有一个盘， A-&gt;C</span><br><span class="line">        if(num&#x3D;&#x3D;1)</span><br><span class="line">        &#123;times++;</span><br><span class="line">            System.out.println(&quot;第&quot;+num+&quot;个盘从&quot;+a+&quot;--&gt;&quot;+c);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果我们有 n &gt;&#x3D; 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘     </span><br><span class="line">        else &#123;</span><br><span class="line">             &#x2F;&#x2F;1. 先把 最上面的num-1个盘 A-&gt;B</span><br><span class="line">            hanoiTower(num - 1, a, c, b);</span><br><span class="line">            &#x2F;&#x2F;2. 把最下边的盘 A-&gt;C</span><br><span class="line">            times++;</span><br><span class="line">            System.out.println(&quot;第&quot;+num+&quot;个盘从&quot;+a+&quot;--&gt;&quot;+c);</span><br><span class="line">            &#x2F;&#x2F;3. 把B塔的所有盘 从 B-&gt;C</span><br><span class="line">            hanoiTower(num-1,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>思考</strong><br>递归最重要的思想就是不要管递归过程，只需要管现有的步骤，从头进行到尾就行了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/02/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" data-id="ckb22iugf00bizwu80dj0f09h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构/哈希表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-date">
  <time datetime="2020-03-01T11:32:03.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="哈希表的基本介绍"><a href="#哈希表的基本介绍" class="headerlink" title="哈希表的基本介绍"></a><strong>哈希表的基本介绍</strong></h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>常见的有数组+链表，数组+二叉树<br><img src="/images/40.png" alt=""></p>
<h3 id="看一个实际需求，google公司的一个上机题"><a href="#看一个实际需求，google公司的一个上机题" class="headerlink" title="看一个实际需求，google公司的一个上机题:"></a><strong>看一个实际需求，google公司的一个上机题:</strong></h3><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.<br>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)<br><img src="/images/41.png" alt=""><br><strong>数组+链表结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">public class HashTableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashTab hashTab &#x3D; new HashTab(7);</span><br><span class="line">        &#x2F;&#x2F;写一个简单的菜单</span><br><span class="line">        String key &#x3D; &quot;&quot;;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;\nadd:  添加雇员&quot;);</span><br><span class="line">            System.out.println(&quot;list: 显示雇员&quot;);</span><br><span class="line">            System.out.println(&quot;find: 查找雇员&quot;);</span><br><span class="line">            System.out.println(&quot;exit: 退出系统&quot;);</span><br><span class="line">            System.out.println(&quot;delete: 删除员工\n&quot;);</span><br><span class="line"></span><br><span class="line">            key &#x3D; scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &quot;add&quot;:</span><br><span class="line">                    System.out.println(&quot;输入id&quot;);</span><br><span class="line">                    int id &#x3D; scanner.nextInt();</span><br><span class="line">                    System.out.println(&quot;输入名字&quot;);</span><br><span class="line">                    String name &#x3D; scanner.next();</span><br><span class="line">                    &#x2F;&#x2F;创建 雇员</span><br><span class="line">                    LinkedEmp emp &#x3D; new LinkedEmp(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;list&quot;:</span><br><span class="line">                    hashTab.Show();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;find&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要查找的id&quot;);</span><br><span class="line">                    id &#x3D; scanner.nextInt();</span><br><span class="line">                    hashTab.FundEmp(id);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;delete&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要删除的id&quot;);</span><br><span class="line">                    id &#x3D; scanner.nextInt();</span><br><span class="line">                    hashTab.delete(id);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(0);</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HashTab&#123;</span><br><span class="line">private LinkedList[] EmpLinkedArray;</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">    public HashTab( int size) &#123;</span><br><span class="line">        EmpLinkedArray &#x3D; new LinkedList[size];</span><br><span class="line">        this.size &#x3D; size;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; EmpLinkedArray.length; i++) &#123;</span><br><span class="line">            EmpLinkedArray[i]&#x3D;new LinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(LinkedEmp L)</span><br><span class="line">    &#123;</span><br><span class="line">        int t&#x3D;HashFund(L);</span><br><span class="line">        EmpLinkedArray[t].add(L);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;size ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            EmpLinkedArray[i].Show(i+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void delete(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        int t&#x3D;id%size;</span><br><span class="line">        EmpLinkedArray[t].delete(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public LinkedEmp FundEmp(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        int t&#x3D;id%size;</span><br><span class="line">           return EmpLinkedArray[t].FindEmp(id);</span><br><span class="line">    &#125;</span><br><span class="line">    public int HashFund(LinkedEmp L)</span><br><span class="line">    &#123;</span><br><span class="line">        return L.id%size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class LinkedList</span><br><span class="line">&#123;</span><br><span class="line">private LinkedEmp head;</span><br><span class="line">public void add(LinkedEmp L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkedEmp temp&#x3D;head;</span><br><span class="line">    if(head&#x3D;&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        head&#x3D;L;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(temp.next!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next&#x3D;L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void delete(int id)</span><br><span class="line">&#123;</span><br><span class="line">    if(head&#x3D;&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(head.id&#x3D;&#x3D;id)</span><br><span class="line">    &#123;</span><br><span class="line">        head&#x3D;null;</span><br><span class="line">        System.out.println(&quot;已删除该员工&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        LinkedEmp temp&#x3D;head;</span><br><span class="line">        while(temp.next!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(temp.next.id&#x3D;&#x3D;id)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.next&#x3D;temp.next.next;</span><br><span class="line">                System.out.println(&quot;已删除该员工&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;不存在该员工&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public LinkedEmp FindEmp(int id)</span><br><span class="line">&#123;</span><br><span class="line">    if(head!&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkedEmp temp&#x3D;head;</span><br><span class="line">        while(temp!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(temp.id&#x3D;&#x3D;id)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;id:&quot;+temp.id+&quot;     name:&quot;+temp.name);</span><br><span class="line">                return temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;不存在该员工&quot;);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">public void Show(int no)</span><br><span class="line">&#123;</span><br><span class="line">    LinkedEmp t&#x3D;head;</span><br><span class="line">    if(head&#x3D;&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;第&quot;+no+&quot;条链表为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        System.out.println(&quot;第&quot;+(no+1)+&quot;条链表信息为&quot;);</span><br><span class="line">    &#123;   while(t!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;id:&quot;+t.id+&quot;     name:&quot;+t.name);</span><br><span class="line">            t&#x3D;t.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class LinkedEmp</span><br><span class="line">&#123;</span><br><span class="line"> int id;</span><br><span class="line"> String name;</span><br><span class="line"> String Sex;</span><br><span class="line"> int age;</span><br><span class="line"> LinkedEmp next;</span><br><span class="line">    public LinkedEmp(int id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/" data-id="ckb22iug200a4zwu828rlchj6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构/查找算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-03-01T03:18:20.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">查找算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="在java中，我们常用的查找有四种"><a href="#在java中，我们常用的查找有四种" class="headerlink" title="在java中，我们常用的查找有四种:"></a><strong>在java中，我们常用的查找有四种:</strong></h3><blockquote>
<p>1) 顺序(线性)查找<br>    2) 二分查找/折半查找<br>    3) 插值查找<br>    4) 斐波那契查找</p>
</blockquote>
<h2 id="顺序-线性-查找"><a href="#顺序-线性-查找" class="headerlink" title="顺序(线性)查找"></a><strong>顺序(线性)查找</strong></h2><p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class XianXing &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int arr[]&#x3D;&#123;1,5,54,5,2,15,5,-456,545,12,21,45,412,-1,-21,515&#125;;</span><br><span class="line">        System.out.println(seqSearch(arr,-456));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int seqSearch(int arr[],int value)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if(arr[i]&#x3D;&#x3D;value)</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找-折半查找-BinarySearch"><a href="#二分查找-折半查找-BinarySearch" class="headerlink" title="二分查找(折半查找)(BinarySearch)"></a><strong>二分查找(折半查找)(BinarySearch)</strong></h2><p>二分查找：二分查找的对象只能是有序数组<br>思路分析：先和中间下标元素比较，再选择查找方向，递归下去就找到了。<br><strong>注意：</strong>在递归的时候，必须给mid值加1或者减1</p>
<p><strong>只能查找一个元素的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ErFen &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[]&#x3D;&#123;1,8,10,89,1000,1234&#125;;</span><br><span class="line">        System.out.println(BinarySearch(arr,123,0,arr.length-1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public  static int BinarySearch(int arr[],int Value,int l,int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int m&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        while(r&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[m]&#x3D;&#x3D;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(arr[m]&lt;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                return BinarySearch(arr,Value,m+1,r);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return  BinarySearch(arr,Value,l,m-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以查找多个相同元素的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ErFen &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[]&#x3D;&#123;1,8,10,89,89,89,89,89,1000,1234&#125;;</span><br><span class="line">        System.out.println(BinarySearch(arr,89,0,arr.length-1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public  static ArrayList BinarySearch(int arr[], int Value, int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int m&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        while(r&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[m]&#x3D;&#x3D;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                int temp&#x3D;m-1;</span><br><span class="line">                ArrayList&lt;Integer&gt; a&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">                while(temp&gt;&#x3D;l&amp;&amp;arr[temp]&#x3D;&#x3D;Value)</span><br><span class="line">                &#123;</span><br><span class="line">                    a.add(temp);</span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                a.add(m);</span><br><span class="line">                temp&#x3D;m+1;</span><br><span class="line">                while(temp&lt;&#x3D;r&amp;&amp;arr[temp]&#x3D;&#x3D;Value)</span><br><span class="line">                &#123;</span><br><span class="line">                    a.add(temp);</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(arr[m]&lt;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                return BinarySearch(arr,Value,m+1,r);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return  BinarySearch(arr,Value,l,m-1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a><strong>插值查找</strong></h2><p>插值查找原理介绍:</p>
<p>1.插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。<br>2.将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.key 就是前面我们讲的findVal<br><img src="/images/38.png" alt=""><br>3.int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);<br>对应前面的代码公式：<br>int mid = left + (right – left) * (findVal– arr[left]) / (arr[right] – arr[left])<br>4.对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.<br>关键字分布不均匀的情况下，该方法不一定比折半查找要好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package 查找;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">import static 排序.GuiBing.mergeSort;</span><br><span class="line">import static 查找.ErFen.BinarySearch;</span><br><span class="line">public class ChaZhi &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int  temp[]&#x3D;new int[arr.length];</span><br><span class="line">        mergeSort(arr,0,arr.length-1,temp);</span><br><span class="line">        </span><br><span class="line">        System.out.println(ChaZhiSearch(arr,9424,0,arr.length-1));</span><br><span class="line">    &#125;</span><br><span class="line">    public  static ArrayList ChaZhiSearch(int arr[], int Value, int l, int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int m&#x3D;l+(r-l)*(Value-arr[l])&#x2F;(arr[r]-arr[l]);</span><br><span class="line">        while(r&gt;l&amp;&amp;Value&gt;&#x3D;arr[0]&amp;&amp;Value&lt;&#x3D;arr[arr.length-1])</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[m]&#x3D;&#x3D;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                int temp&#x3D;m-1;</span><br><span class="line">                ArrayList&lt;Integer&gt; a&#x3D;new ArrayList&lt;Integer&gt;();</span><br><span class="line">                while(temp&gt;&#x3D;l&amp;&amp;arr[temp]&#x3D;&#x3D;Value)</span><br><span class="line">                &#123;</span><br><span class="line">                    a.add(temp);</span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                a.add(m);</span><br><span class="line">                temp&#x3D;m+1;</span><br><span class="line">                while(temp&lt;&#x3D;r&amp;&amp;arr[temp]&#x3D;&#x3D;Value)</span><br><span class="line">                &#123;</span><br><span class="line">                    a.add(temp);</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(arr[m]&lt;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                return ChaZhiSearch(arr,Value,m+1,r);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return  ChaZhiSearch(arr,Value,l,m-1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>必须注意：</strong><br>在判断是否递归结束的条件时必须加上：Value&gt;=arr[0]&amp;&amp;Value&lt;=arr[arr.length-1]<br>因为 m=l+(r-l)* (Value-arr[l])/(arr[r]-arr[l]);若不满足上述条件，则m会越界到数组之外。导致程序出错。</p>
<h2 id="斐波那契-黄金分割法-查找算法"><a href="#斐波那契-黄金分割法-查找算法" class="headerlink" title="斐波那契(黄金分割法)查找算法"></a><strong>斐波那契(黄金分割法)查找算法</strong></h2><p><strong>斐波那契(黄金分割法)查找基本介绍:</strong>    </p>
<ol>
<li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</li>
<li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618</li>
</ol>
<p><strong>斐波那契(黄金分割法)原理:</strong><br>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列），如下图所示</p>
<p><strong>对F(k-1)-1的理解：</strong></p>
<ol>
<li>由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。(其中加的这个1就为mid)该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如下图所示。从而中间位置为mid=low+F(k-1)-1<br><img src="/images/39.png" alt="">         </li>
<li>类似的，每一子段也可以用相同的方式分割</li>
<li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class Fibonacci &#123;</span><br><span class="line"></span><br><span class="line">    public static int maxSize &#x3D; 20;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int [] arr &#x3D; &#123;1,8, 10, 89, 1000, 1234&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;index&#x3D;&quot; + fibSearch(arr, 1234));&#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;因为后面我们mid&#x3D;low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span><br><span class="line">    &#x2F;&#x2F;非递归方法得到一个斐波那契数列</span><br><span class="line">    public static int[] fib() &#123;</span><br><span class="line">        int[] f &#x3D; new int[maxSize];</span><br><span class="line">        f[0] &#x3D; 1;</span><br><span class="line">        f[1] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 2; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] &#x3D; f[i - 1] + f[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写斐波那契查找算法</span><br><span class="line">    &#x2F;&#x2F;使用非递归的方式编写算法</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param a  数组</span><br><span class="line">     * @param key 我们需要查找的关键码(值)</span><br><span class="line">     * @return 返回对应的下标，如果没有-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int fibSearch(int[] a, int key) &#123;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; a.length - 1;</span><br><span class="line">        int k &#x3D; 0; &#x2F;&#x2F;表示斐波那契分割数值的下标</span><br><span class="line">        int mid &#x3D; 0; &#x2F;&#x2F;存放mid值</span><br><span class="line">        int f[] &#x3D; fib(); &#x2F;&#x2F;获取到斐波那契数列</span><br><span class="line">        &#x2F;&#x2F;获取到斐波那契分割数值的下标</span><br><span class="line">        while(high &gt; f[k] - 1) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span><br><span class="line">        &#x2F;&#x2F;不足的部分会使用0填充</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOf(a, f[k]);</span><br><span class="line">        &#x2F;&#x2F;实际上需求使用a数组最后的数填充 temp</span><br><span class="line">        &#x2F;&#x2F;举例:</span><br><span class="line">        &#x2F;&#x2F;temp &#x3D; &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  &#x3D;&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span><br><span class="line">        for(int i &#x3D; high + 1; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] &#x3D; a[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用while来循环处理，找到我们的数 key</span><br><span class="line">        while (low &lt;&#x3D; high) &#123; &#x2F;&#x2F; 只要这个条件满足，就可以找</span><br><span class="line">            mid &#x3D; low + f[k - 1] - 1;</span><br><span class="line">            if(key &lt; temp[mid]) &#123; &#x2F;&#x2F;我们应该继续向数组的前面查找(左边)</span><br><span class="line">                high &#x3D; mid - 1;</span><br><span class="line">                &#x2F;&#x2F;为甚是 k--</span><br><span class="line">                &#x2F;&#x2F;说明</span><br><span class="line">                &#x2F;&#x2F;1. 全部元素 &#x3D; 前面的元素 + 后边元素</span><br><span class="line">                &#x2F;&#x2F;2. f[k] &#x3D; f[k-1] + f[k-2]</span><br><span class="line">                &#x2F;&#x2F;因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] &#x3D; f[k-2] + f[k-3]</span><br><span class="line">                &#x2F;&#x2F;即 在 f[k-1] 的前面继续查找 k--</span><br><span class="line">                &#x2F;&#x2F;即下次循环 mid &#x3D; f[k-1-1]-1</span><br><span class="line">                k--;</span><br><span class="line">            &#125; else if ( key &gt; temp[mid]) &#123; &#x2F;&#x2F; 我们应该继续向数组的后面查找(右边)</span><br><span class="line">                low &#x3D; mid + 1;</span><br><span class="line">                &#x2F;&#x2F;为什么是k -&#x3D;2</span><br><span class="line">                &#x2F;&#x2F;说明</span><br><span class="line">                &#x2F;&#x2F;1. 全部元素 &#x3D; 前面的元素 + 后边元素</span><br><span class="line">                &#x2F;&#x2F;2. f[k] &#x3D; f[k-1] + f[k-2]</span><br><span class="line">                &#x2F;&#x2F;3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] &#x3D; f[k-3] + f[k-4]</span><br><span class="line">                &#x2F;&#x2F;4. 即在f[k-2] 的前面进行查找 k -&#x3D;2</span><br><span class="line">                &#x2F;&#x2F;5. 即下次循环 mid &#x3D; f[k - 1 - 2] - 1</span><br><span class="line">                k -&#x3D; 2;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F;找到</span><br><span class="line">                &#x2F;&#x2F;需要确定，返回的是哪个下标,因为在原有的数组后面加了几个本不存在的数，而high正是原数组的上届。</span><br><span class="line">                if(mid &lt;&#x3D; high) &#123;</span><br><span class="line">                    return mid;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" data-id="ckb22iug500akzwu87vsu7xmw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构/排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2020-02-22T13:35:29.000Z" itemprop="datePublished">2020-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/">排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="排序算法的介绍"><a href="#排序算法的介绍" class="headerlink" title="排序算法的介绍"></a><strong>排序算法的介绍</strong></h3><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<h3 id="排序的分类："><a href="#排序的分类：" class="headerlink" title="排序的分类："></a><strong>排序的分类：</strong></h3><p>1) 内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。<br>2) 外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。<br><img src="/images/30.png" alt=""></p>
<h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a><strong>算法的时间复杂度</strong></h3><p>度量一个程序(算法)执行时间的两种方法<br>1.事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。<br>2.事前估算的方法通过分析某个算法的时间复杂度来判断哪个算法更优.</p>
<p><strong>时间频度</strong><br>基本介绍<br>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p><strong>时间复杂度</strong></p>
<blockquote>
<p>1.一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。<br>2.T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。<br>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低</p>
</blockquote>
<p><strong>排序：</strong><br>常数阶O(1)<br>对数阶O(log2n)<br>线性阶O(n)<br>线性对数阶O(nlog2n)<br>平方阶O(n^2)<br>立方阶O(n^3)<br>k次方阶O(n^k)<br>指数阶O(2^n)<br>阶乘阶(n!)</p>
<p><strong>平均时间复杂度和最坏时间复杂度</strong><br>1.平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。<br>2.最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。<br>3.平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。<br><img src="/images/31.png" alt=""></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h2><blockquote>
<p>平均时间：O(n^2)<br>    最差时间：O(n^2)<br>    稳定度：稳定<br>    额外空间：O(1)</p>
</blockquote>
<p><strong>基本介绍：</strong><br>冒泡排序（Bubble Sorting）的基本思想是：通过对待<br>排序序列从前向后（从下标较小的元素开始）,依次比较<br>相邻元素的值，若发现逆序则交换，使值较大<br>的元素逐渐从前移向后部，就象水底下的气泡一样逐渐<br>向上冒。<br>因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下<br>来没有进行过交换，就说明序列有序，因此要在排序过程中设置<br>一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MaoPao &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int b&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;int[]  a&#x3D;&#123;6,5,4,3,2,1&#125;;</span><br><span class="line">        int[] a&#x3D;new int[50000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;50000 ; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int c&#x3D;0;</span><br><span class="line">        long time&#x3D; System.currentTimeMillis();&#x2F;&#x2F;获取当前系统时间(毫秒)</span><br><span class="line">        for (int i &#x3D; 0; i &lt;a.length-1 ; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;a.length-i-1 ; j++) &#123;</span><br><span class="line">                if(a[j]&gt;a[j+1])</span><br><span class="line">                &#123;</span><br><span class="line">                    b&#x3D;a[j];</span><br><span class="line">                    a[j]&#x3D;a[j+1];</span><br><span class="line">                    a[j+1]&#x3D;b;</span><br><span class="line">                    c&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(c&#x3D;&#x3D;0)</span><br><span class="line">                break;</span><br><span class="line">            c&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;50000个随机数的排序时间为：&quot;);</span><br><span class="line">        System.out.println(System.currentTimeMillis()-time+&quot;毫秒&quot;);</span><br><span class="line">         for (int i1 : a) &#123;</span><br><span class="line">                System.out.println(i1+&quot; &quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：18970毫秒</strong></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h2><blockquote>
<p>平均时间：O(n^2)<br>    最差时间：O(n^2)<br>    稳定度：不稳定<br>    额外空间：O(1)</p>
</blockquote>
<p><strong>基本介绍</strong><br>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。<br><strong>选择排序思想:</strong></p>
<p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]-arr[<br>n-1]中选取最小值，与arr[0]交换，第二次从arr[1]<del>arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]</del>arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]<del>arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]</del>arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列</p>
<p><img src="/images/32.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class XuanZe &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[50000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;50000 ; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        long time&#x3D; System.currentTimeMillis();&#x2F;&#x2F;获取当前系统时间(毫秒)</span><br><span class="line">        for (int i &#x3D; 0; i &lt;a.length-1 ; i++) &#123;</span><br><span class="line">            int b&#x3D;a[i];</span><br><span class="line">            int c&#x3D;i;</span><br><span class="line">            for (int j &#x3D; i; j &lt;a.length ; j++) &#123;</span><br><span class="line">                if(a[j]&lt;b) &#123;</span><br><span class="line">                    b &#x3D; a[j];</span><br><span class="line">                    c&#x3D;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[c]&#x3D;a[i];</span><br><span class="line">            a[i]&#x3D;b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;50000个随机数的排序时间为：&quot;+time1+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：3752毫秒</strong></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h2><blockquote>
<p>平均时间：O(n^2)<br>    最差时间：O(n^2)<br>    稳定度：不稳定<br>    额外空间：O(1)</p>
</blockquote>
<p><strong>插入排序法介绍:</strong><br>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p>
<p><strong>插入排序法思想:</strong><br>插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。<br><img src="/images/33.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ChaRu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000 ; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;a.length ; i++) &#123;</span><br><span class="line">            int c&#x3D;a[i];</span><br><span class="line">            int d&#x3D;i-1;</span><br><span class="line">            while(d&gt;&#x3D;0&amp;&amp;c&lt;a[d])&#123;</span><br><span class="line">                a[d+1]&#x3D;a[d];</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">               a[d+1]&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：985毫秒</strong></p>
<h2 id="希尔排序-缩小增量排序-简单插入排序的升级版"><a href="#希尔排序-缩小增量排序-简单插入排序的升级版" class="headerlink" title="希尔排序(缩小增量排序)(简单插入排序的升级版)"></a><strong>希尔排序(缩小增量排序)(简单插入排序的升级版)</strong></h2><blockquote>
<p>简单插入排序存在的问题<br>    我们看简单的插入排序可能存在的问题.<br>    数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：<br>    {2,3,4,5,6,6}<br>    {2,3,4,5,5,6}<br>    {2,3,4,4,5,6}<br>    {2,3,3,4,5,6}<br>    {2,2,3,4,5,6}<br>    {1,2,3,4,5,6}<br>    结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
</blockquote>
<p><strong>希尔排序法介绍</strong><br>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<p><strong>希尔排序法基本思想</strong><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止<br><strong>代码</strong></p>
<h3 id="1-交换希尔"><a href="#1-交换希尔" class="headerlink" title="(1)交换希尔"></a><strong>(1)交换希尔</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; a.length&#x2F;2; i &gt;0 ; i&#x2F;&#x3D;2) &#123;&#x2F;&#x2F;步长</span><br><span class="line">            for (int j &#x3D; i; j &lt;a.length; j++) &#123;&#x2F;&#x2F;分组</span><br><span class="line">                for (int k &#x3D; j-i; k &gt;&#x3D;0 ; k-&#x3D;i) &#123;&#x2F;&#x2F;组内比较</span><br><span class="line">                    if(a[k]&gt;a[k+i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        t&#x3D;a[k];</span><br><span class="line">                        a[k]&#x3D;a[k+i];</span><br><span class="line">                        a[k+i]&#x3D;t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：12390毫秒</strong></p>
<h3 id="2-交换希尔加插入"><a href="#2-交换希尔加插入" class="headerlink" title="(2)交换希尔加插入"></a><strong>(2)交换希尔加插入</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; a.length&#x2F;2; i &gt;0 ; i&#x2F;&#x3D;2) &#123;&#x2F;&#x2F;步长</span><br><span class="line">            for (int j &#x3D; a.length-i; j &lt;a.length; j++) &#123;&#x2F;&#x2F;分组</span><br><span class="line">                for (int k &#x3D; j-i; k &gt;&#x3D;0 ; k-&#x3D;i) &#123;&#x2F;&#x2F;组内比较</span><br><span class="line">                    if(a[k]&gt;a[k+i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        t&#x3D;a[k];</span><br><span class="line">                        a[k]&#x3D;a[k+i];</span><br><span class="line">                        a[k+i]&#x3D;t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;a.length ; i++) &#123;</span><br><span class="line">            c&#x3D;a[i];</span><br><span class="line">            d&#x3D;i-1;</span><br><span class="line">            while(d&gt;&#x3D;0&amp;&amp;c&lt;a[d])&#123;</span><br><span class="line">                a[d+1]&#x3D;a[d];</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[d+1]&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：80000个随机数的排序时间为：181毫秒</strong></p>
<h3 id="3-移位法希尔"><a href="#3-移位法希尔" class="headerlink" title="(3)移位法希尔"></a><strong>(3)移位法希尔</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; a.length&#x2F;2; i &gt;0 ; i&#x2F;&#x3D;2) &#123;&#x2F;&#x2F;步长</span><br><span class="line">            for (int j &#x3D; i; j &lt;a.length; j+&#x3D;1) &#123;&#x2F;&#x2F;分组</span><br><span class="line">                c&#x3D;a[j];</span><br><span class="line">                d&#x3D;j-i;</span><br><span class="line">                if(a[j]&lt;a[j-i])</span><br><span class="line">                while(d&gt;&#x3D;0&amp;&amp;c&lt;a[d])&#123;</span><br><span class="line">                    a[d+i]&#x3D;a[d];</span><br><span class="line">                    d-&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                a[d+i]&#x3D;c;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：80000个随机数的排序时间为：48毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：800000个随机数的排序时间为：250(261)毫秒</strong><br><strong>8000000(800w)个随机数排序<br>执行结果：8000000个随机数的排序时间为：2875(2907)毫秒</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h2><p><strong>快速排序法介绍:</strong><br>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此达到整个数据变成有序序列</p>
<h3 id="1-帮助理解快排的代码"><a href="#1-帮助理解快排的代码" class="headerlink" title="(1)帮助理解快排的代码"></a><strong>(1)帮助理解快排的代码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class KuaiSu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        quickSort(a,0,a.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void quickSort(int[] a,int left,int right)</span><br><span class="line">    &#123;</span><br><span class="line">        int l&#x3D;left;</span><br><span class="line">        int r&#x3D;right;</span><br><span class="line">        int c&#x3D;a[(l+r)&#x2F;2];</span><br><span class="line">        System.out.println(&quot;l&#x3D;&quot;+l+&quot;;  r&#x3D;&quot;+r+&quot;;  中间数为&quot;+c+&quot;;&quot;);</span><br><span class="line">        int d;</span><br><span class="line">        while(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            while(a[l]&lt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;l&#x3D;&quot;+l+&quot;; &quot;);</span><br><span class="line">            while(a[r]&gt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;r&#x3D;&quot;+r+&quot;; &quot;);</span><br><span class="line">            if(l&gt;&#x3D;r)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             d&#x3D;a[r];</span><br><span class="line">            a[r]&#x3D;a[l];</span><br><span class="line">            a[l]&#x3D;d;</span><br><span class="line">            if(a[l]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(a[r]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l+&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">        if(l&#x3D;&#x3D;r)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;\n左递归&quot;);</span><br><span class="line">            quickSort(a,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;\n右递归&quot;);</span><br><span class="line">            quickSort(a,l,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<pre><code>[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
l=0;  r=9;  中间数为2;
l=0; r=9; 将a[l]=8和a[r]=0交换      [0, 9, 1, 7, 2, 3, 5, 4, 6, 8]
l=1; r=4; 将a[l]=9和a[r]=2交换      [0, 2, 1, 7, 9, 3, 5, 4, 6, 8]
l=1; r=2; 将a[l]=2和a[r]=1交换      [0, 1, 2, 7, 9, 3, 5, 4, 6, 8]
l=2; r=2; 
左递归
l=0;  r=1;  中间数为0;
l=0; r=0; 
右递归
l=3;  r=9;  中间数为5;
l=3; r=7; 将a[l]=7和a[r]=4交换      [0, 1, 2, 4, 9, 3, 5, 7, 6, 8]
l=4; r=6; 将a[l]=9和a[r]=5交换      [0, 1, 2, 4, 5, 3, 9, 7, 6, 8]
l=4; r=5; 将a[l]=5和a[r]=3交换      [0, 1, 2, 4, 3, 5, 9, 7, 6, 8]
l=5; r=5; 
左递归
l=3;  r=4;  中间数为4;
l=3; r=4; 将a[l]=4和a[r]=3交换      [0, 1, 2, 3, 4, 5, 9, 7, 6, 8]
l=4; r=4; 
右递归
l=6;  r=9;  中间数为7;
l=6; r=8; 将a[l]=9和a[r]=6交换      [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
l=7; r=7; 
右递归
l=8;  r=9;  中间数为9;
l=8; r=9; 将a[l]=9和a[r]=8交换      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l=9; r=9; </code></pre><h3 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="(2)测试代码"></a><strong>(2)测试代码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class KuaiSu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[8000000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;8000000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        quickSort(a,0,a.length-1);</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">          &#x2F;&#x2F;  System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void quickSort(int[] a,int left,int right)</span><br><span class="line">    &#123;</span><br><span class="line">        int l&#x3D;left;</span><br><span class="line">        int r&#x3D;right;</span><br><span class="line">        int c&#x3D;a[(l+r)&#x2F;2];</span><br><span class="line">        int d;</span><br><span class="line">        while(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            while(a[l]&lt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(a[r]&gt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l&gt;&#x3D;r)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            d&#x3D;a[r];</span><br><span class="line">            a[r]&#x3D;a[l];</span><br><span class="line">            a[l]&#x3D;d;</span><br><span class="line">            if(a[l]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(a[r]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l+&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l&#x3D;&#x3D;r)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            quickSort(a,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            quickSort(a,l,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：80000个随机数的排序时间为：39(36)(41)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：800000个随机数的排序时间为：177(189)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：80000000个随机数的排序时间为：1441(1530)毫秒</strong></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h2><p><strong>归并排序介绍:</strong><br>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题，分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><img src="/images/34.png" alt=""><br><strong>说明:</strong><br>分的时候只是为了给治提供条件，并没有其他的作用。<br>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。<br>合的时候需要用到临时数组。</p>
<p><strong>测试代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class GuiBing &#123;</span><br><span class="line">    static int  times&#x3D;0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;*int arr[]&#x3D;&#123;8,4,5,7,1,3,6,2&#125;;</span><br><span class="line">int temp[]&#x3D;new int[arr.length];</span><br><span class="line">mergeSort(arr,0,arr.length-1,temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));*&#x2F;</span><br><span class="line"></span><br><span class="line">        int[] arr&#x3D;new int[8000000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;8000000; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        int  temp[]&#x3D;new int[arr.length];</span><br><span class="line">        mergeSort(arr,0,arr.length-1,temp);</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">            &#x2F;&#x2F;  System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;归并的次数为：&quot;+times);</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分加并</span><br><span class="line">    public static void mergeSort(int[] a,int left,int right,int[] temp)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">        if(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mergeSort(a,left,mid,temp);</span><br><span class="line">            mergeSort(a,mid+1,right,temp);</span><br><span class="line">            merge(a,left,mid,right,temp);</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;并的方法</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param a             排序的原始数组</span><br><span class="line">     * @param left          左边有序序列的初始索引</span><br><span class="line">     * @param mid           中间索引</span><br><span class="line">     * @param right         最右边索引(结束索引)</span><br><span class="line">     * @param temp          中转数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void merge(int[] a,int left,int mid,int right,int[] temp)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化数据</span><br><span class="line">        int i&#x3D;left;</span><br><span class="line">        int j&#x3D;mid+1;</span><br><span class="line">        int t&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;第一步：比较</span><br><span class="line">        while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;right)</span><br><span class="line">        &#123;if(a[i]&lt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp[t]&#x3D;a[i];</span><br><span class="line">                i++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                temp[t]&#x3D;a[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第二步，将剩余的合并</span><br><span class="line">        while(i&lt;&#x3D;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[t]&#x3D;a[i];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[t]&#x3D;a[j];</span><br><span class="line">            t++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第三步，将temp复制回来</span><br><span class="line">        j&#x3D;right;</span><br><span class="line">        t--;</span><br><span class="line">        while(t&gt;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j]&#x3D;temp[t];</span><br><span class="line">            t--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>80000(8w)个随机数排序<br>执行结果：<br>归并的次数为：79999<br>80000个随机数的排序时间为：27(33)(26)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：<br>归并的次数为：799999<br>800000个随机数的排序时间为：171(162)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：<br>归并的次数为：7999999<br>80000000个随机数的排序时间为：1788(1700)毫秒</strong></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h2><p><strong>基数排序(桶排序)介绍:</strong><br>1.基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用<br>2.基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法<br>3.基数排序(Radix Sort)是桶排序的扩展<br>4.基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p><strong>基于两种不同的排序顺序，我们将基数排序分为</strong><br>    LSD（Least significant digital）：排序方式由数值的最右边（低位）开始<br>    MSD（Most significant digital）：由数值的最左边（高位）开始。</p>
<p><strong>基数排序基本思想</strong><br>基数排序是通过“分配”和“收集”过程来实现排序。<br>1)分配，先从个位开始，根据位值(0-9)分别放到0-9号桶中（比如53,个位为3，则放入3号桶中）<br>2)收集，再将放置在0 ~ 9号桶中的数据按顺序放到数组中<br>重复(1)(2)过程，从个位到最高位（比如32位无符号整形最大数4294967296，最高位10位）。</p>
<p>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤<br><img src="/images/35.png" alt=""><br><img src="/images/36.png" alt=""><br><img src="/images/37.png" alt=""><br><strong>基数排序的说明:</strong><br>基数排序是对传统桶排序的扩展，速度很快.<br>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。<br>基数排序是稳定的。<br>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a> </p>
<p><strong>测试代码(LSD)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JiShu_RadixSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F; int arr[]&#x3D;&#123;53, 3, 542, 748, 14, 214,155,21,365,4545,231,31,6542,1321,3,1,16,51,21,321,56,12 &#125;;</span><br><span class="line">        int[] arr&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;求出最大的数的位数MaxSize</span><br><span class="line">        int max&#x3D;arr[0];</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            if(i&gt;max)</span><br><span class="line">                max&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        int MaxSize&#x3D;(max+&quot;&quot;).length();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;bucket为设置的十个桶，bucketCount为每个桶先存的数据个数</span><br><span class="line">        int[][] bucket&#x3D;new int[10][arr.length];</span><br><span class="line">        int[]  bucketCount&#x3D;new int[10];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;基数排序需要遍历次数为最大数的位数，n用来求各个位。</span><br><span class="line">        for (int i &#x3D; 0,n&#x3D;1; i &lt; MaxSize; i++,n*&#x3D;10) &#123;</span><br><span class="line">            &#x2F;&#x2F;1.将数据放入桶中</span><br><span class="line">            for (int i1 : arr) &#123;</span><br><span class="line">                bucket[i1&#x2F;n%10][bucketCount[i1&#x2F;n%10]]&#x3D;i1;</span><br><span class="line">                bucketCount[i1&#x2F;n%10]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;2.从桶中将数据取回</span><br><span class="line">            int t&#x3D;0;&#x2F;&#x2F;临时变量，用来存入原数组</span><br><span class="line">            for (int i1 &#x3D; 0; i1 &lt; 10; i1++)&#x2F;&#x2F;i1表示第几个桶，总共有十个</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j &#x3D; 0; bucketCount[i1]&gt;0 ; j++,bucketCount[i1]--) &#123;</span><br><span class="line">                    arr[t++]&#x3D;bucket[i1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">             &#x2F;&#x2F;System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：<br>80000个随机数的排序时间为：14(12)(15)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：<br>800000个随机数的排序时间为：139(95)(118)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：<br>80000000个随机数的排序时间为：685(628)毫秒</strong></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h2><p><strong>堆排序基本介绍</strong></p>
<ol>
<li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</li>
<li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li>
<li>大顶堆举例说明<br><img src="/images/46.png" alt=""><br><img src="/images/47.png" alt=""><br>大顶堆特点：arr[i] &gt;= arr[2* i+1] &amp;&amp; arr[i] &gt;= arr[2* i+2] //i对应第几个节点，i从0开始编号</li>
</ol>
<p><strong>堆排序基本思想</strong></p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
</ol>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p><strong>堆排序思路和步骤</strong><br>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。<br>1).假设给定无序序列结构如下<br><img src="/images/48.png" alt=""><br>2).此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。<br><img src="/images/49.png" alt=""><br>3).找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。<br><img src="/images/50.png" alt=""><br>4)这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。<br><img src="/images/51.png" alt=""><br>此时，我们就将一个无序序列构造成了一个大顶堆。<br>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。<br>1).将堆顶元素9和末尾元素4进行交换<br><img src="/images/52.png" alt=""><br>2).重新调整结构，使其继续满足堆定义<br><img src="/images/53.png" alt=""><br>3).再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.<br><img src="/images/54.png" alt=""><br>4)后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="/images/55.png" alt=""></p>
<h3 id="再简单总结下堆排序的基本思路："><a href="#再简单总结下堆排序的基本思路：" class="headerlink" title="再简单总结下堆排序的基本思路："></a><strong>再简单总结下堆排序的基本思路：</strong></h3><ol>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package 排序;</span><br><span class="line">&#x2F;&#x2F;堆排序</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class HeapSortDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        HeapSort(a);</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">             &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">public static void HeapSort(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">&#x2F;&#x2F;先进行第一次堆调整</span><br><span class="line">    for (int i &#x3D; arr.length&#x2F;2-1; i &gt;&#x3D;0 ; i--) &#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;进行交换，并排序完所有的数</span><br><span class="line">    for (int i &#x3D; arr.length-1; i &gt;0 ; i--) &#123;</span><br><span class="line">        temp&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;arr[0];</span><br><span class="line">        arr[0]&#x3D;temp;</span><br><span class="line">        adjustHeap(arr,0,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void adjustHeap(int arr[],int i,int lenght)</span><br><span class="line">&#123; int temp&#x3D;arr[i];</span><br><span class="line">    for (int k&#x3D; i*2+1; k &lt;lenght ; k&#x3D;k*2+1) &#123;</span><br><span class="line">        if(k+1&lt;lenght&amp;&amp;arr[k]&lt;arr[k+1])</span><br><span class="line">        &#123;</span><br><span class="line">            k&#x3D;k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[k]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i]&#x3D;arr[k];</span><br><span class="line">            i&#x3D;k;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">        arr[k]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>80000(8w)个随机数排序<br>执行结果：<br>80000个随机数的排序时间为：27(17)(18)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：<br>800000个随机数的排序时间为：195(163)(200)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：<br>80000000个随机数的排序时间为：2384(2365)毫秒</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/" data-id="ckb22iug600aozwu82m34ax50" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法/二分查找算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/19/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-02-19T04:04:09.000Z" itemprop="datePublished">2020-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/19/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">二分查找算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法一：二分查找算法"><a href="#算法一：二分查找算法" class="headerlink" title="算法一：二分查找算法"></a><strong>算法一：二分查找算法</strong></h2><p><strong>递归</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ErFen &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[]&#x3D;&#123;1,8,10,89,1000,1234&#125;;</span><br><span class="line">        System.out.println(BinarySearch(arr,123,0,arr.length-1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public  static int BinarySearch(int arr[],int Value,int l,int r)</span><br><span class="line">    &#123;</span><br><span class="line">        int m&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        while(r&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            if(arr[m]&#x3D;&#x3D;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(arr[m]&lt;Value)</span><br><span class="line">            &#123;</span><br><span class="line">                return BinarySearch(arr,Value,m+1,r);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return  BinarySearch(arr,Value,l,m-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非递归</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int binarySort(int[] arr,int value)</span><br><span class="line">    &#123;</span><br><span class="line">        int h&#x3D;arr.length-1;</span><br><span class="line">        int l&#x3D;0;</span><br><span class="line">        int mid;</span><br><span class="line">        while(h&gt;&#x3D;l)</span><br><span class="line">        &#123;   mid&#x3D;(h+l)&#x2F;2;</span><br><span class="line">            if(arr[mid]&#x3D;&#x3D;value)</span><br><span class="line">                return mid;</span><br><span class="line">            else if(arr[mid]&lt;value)</span><br><span class="line">            &#123;</span><br><span class="line">                l&#x3D;mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                h&#x3D;mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/02/19/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" data-id="ckb22iugc00b8zwu8cnpy9p0g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/11/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>