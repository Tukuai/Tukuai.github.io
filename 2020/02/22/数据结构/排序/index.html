<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>排序 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="排序算法的介绍排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。 排序的分类：1) 内部排序:指将需要处理的所有数据都加载到内部存储器中进行排序。2) 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。 算法的时间复杂度度量一个程序(算法)执行时间的两种方法1.事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="https://tukuai.github.io/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="排序算法的介绍排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。 排序的分类：1) 内部排序:指将需要处理的所有数据都加载到内部存储器中进行排序。2) 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。 算法的时间复杂度度量一个程序(算法)执行时间的两种方法1.事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tukuai.github.io/images/30.png">
<meta property="og:image" content="https://tukuai.github.io/images/31.png">
<meta property="og:image" content="https://tukuai.github.io/images/32.png">
<meta property="og:image" content="https://tukuai.github.io/images/33.png">
<meta property="og:image" content="https://tukuai.github.io/images/34.png">
<meta property="og:image" content="https://tukuai.github.io/images/35.png">
<meta property="og:image" content="https://tukuai.github.io/images/36.png">
<meta property="og:image" content="https://tukuai.github.io/images/37.png">
<meta property="og:image" content="https://tukuai.github.io/images/46.png">
<meta property="og:image" content="https://tukuai.github.io/images/47.png">
<meta property="og:image" content="https://tukuai.github.io/images/48.png">
<meta property="og:image" content="https://tukuai.github.io/images/49.png">
<meta property="og:image" content="https://tukuai.github.io/images/50.png">
<meta property="og:image" content="https://tukuai.github.io/images/51.png">
<meta property="og:image" content="https://tukuai.github.io/images/52.png">
<meta property="og:image" content="https://tukuai.github.io/images/53.png">
<meta property="og:image" content="https://tukuai.github.io/images/54.png">
<meta property="og:image" content="https://tukuai.github.io/images/55.png">
<meta property="article:published_time" content="2020-02-22T13:35:29.000Z">
<meta property="article:modified_time" content="2020-04-02T07:33:39.897Z">
<meta property="article:author" content="Tukuai">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tukuai.github.io/images/30.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数据结构/排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2020-02-22T13:35:29.000Z" itemprop="datePublished">2020-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      排序
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="排序算法的介绍"><a href="#排序算法的介绍" class="headerlink" title="排序算法的介绍"></a><strong>排序算法的介绍</strong></h3><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<h3 id="排序的分类："><a href="#排序的分类：" class="headerlink" title="排序的分类："></a><strong>排序的分类：</strong></h3><p>1) 内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。<br>2) 外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。<br><img src="/images/30.png" alt=""></p>
<h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a><strong>算法的时间复杂度</strong></h3><p>度量一个程序(算法)执行时间的两种方法<br>1.事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。<br>2.事前估算的方法通过分析某个算法的时间复杂度来判断哪个算法更优.</p>
<p><strong>时间频度</strong><br>基本介绍<br>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p><strong>时间复杂度</strong></p>
<blockquote>
<p>1.一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。<br>2.T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。<br>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低</p>
</blockquote>
<p><strong>排序：</strong><br>常数阶O(1)<br>对数阶O(log2n)<br>线性阶O(n)<br>线性对数阶O(nlog2n)<br>平方阶O(n^2)<br>立方阶O(n^3)<br>k次方阶O(n^k)<br>指数阶O(2^n)<br>阶乘阶(n!)</p>
<p><strong>平均时间复杂度和最坏时间复杂度</strong><br>1.平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。<br>2.最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。<br>3.平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。<br><img src="/images/31.png" alt=""></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h2><blockquote>
<p>平均时间：O(n^2)<br>    最差时间：O(n^2)<br>    稳定度：稳定<br>    额外空间：O(1)</p>
</blockquote>
<p><strong>基本介绍：</strong><br>冒泡排序（Bubble Sorting）的基本思想是：通过对待<br>排序序列从前向后（从下标较小的元素开始）,依次比较<br>相邻元素的值，若发现逆序则交换，使值较大<br>的元素逐渐从前移向后部，就象水底下的气泡一样逐渐<br>向上冒。<br>因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下<br>来没有进行过交换，就说明序列有序，因此要在排序过程中设置<br>一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MaoPao &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int b&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;int[]  a&#x3D;&#123;6,5,4,3,2,1&#125;;</span><br><span class="line">        int[] a&#x3D;new int[50000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;50000 ; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int c&#x3D;0;</span><br><span class="line">        long time&#x3D; System.currentTimeMillis();&#x2F;&#x2F;获取当前系统时间(毫秒)</span><br><span class="line">        for (int i &#x3D; 0; i &lt;a.length-1 ; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;a.length-i-1 ; j++) &#123;</span><br><span class="line">                if(a[j]&gt;a[j+1])</span><br><span class="line">                &#123;</span><br><span class="line">                    b&#x3D;a[j];</span><br><span class="line">                    a[j]&#x3D;a[j+1];</span><br><span class="line">                    a[j+1]&#x3D;b;</span><br><span class="line">                    c&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(c&#x3D;&#x3D;0)</span><br><span class="line">                break;</span><br><span class="line">            c&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;50000个随机数的排序时间为：&quot;);</span><br><span class="line">        System.out.println(System.currentTimeMillis()-time+&quot;毫秒&quot;);</span><br><span class="line">         for (int i1 : a) &#123;</span><br><span class="line">                System.out.println(i1+&quot; &quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：18970毫秒</strong></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h2><blockquote>
<p>平均时间：O(n^2)<br>    最差时间：O(n^2)<br>    稳定度：不稳定<br>    额外空间：O(1)</p>
</blockquote>
<p><strong>基本介绍</strong><br>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。<br><strong>选择排序思想:</strong></p>
<p>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]-arr[<br>n-1]中选取最小值，与arr[0]交换，第二次从arr[1]<del>arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]</del>arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]<del>arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]</del>arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列</p>
<p><img src="/images/32.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class XuanZe &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[50000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;50000 ; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        long time&#x3D; System.currentTimeMillis();&#x2F;&#x2F;获取当前系统时间(毫秒)</span><br><span class="line">        for (int i &#x3D; 0; i &lt;a.length-1 ; i++) &#123;</span><br><span class="line">            int b&#x3D;a[i];</span><br><span class="line">            int c&#x3D;i;</span><br><span class="line">            for (int j &#x3D; i; j &lt;a.length ; j++) &#123;</span><br><span class="line">                if(a[j]&lt;b) &#123;</span><br><span class="line">                    b &#x3D; a[j];</span><br><span class="line">                    c&#x3D;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[c]&#x3D;a[i];</span><br><span class="line">            a[i]&#x3D;b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;50000个随机数的排序时间为：&quot;+time1+&quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：3752毫秒</strong></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h2><blockquote>
<p>平均时间：O(n^2)<br>    最差时间：O(n^2)<br>    稳定度：不稳定<br>    额外空间：O(1)</p>
</blockquote>
<p><strong>插入排序法介绍:</strong><br>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p>
<p><strong>插入排序法思想:</strong><br>插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。<br><img src="/images/33.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ChaRu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000 ; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;a.length ; i++) &#123;</span><br><span class="line">            int c&#x3D;a[i];</span><br><span class="line">            int d&#x3D;i-1;</span><br><span class="line">            while(d&gt;&#x3D;0&amp;&amp;c&lt;a[d])&#123;</span><br><span class="line">                a[d+1]&#x3D;a[d];</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">               a[d+1]&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：985毫秒</strong></p>
<h2 id="希尔排序-缩小增量排序-简单插入排序的升级版"><a href="#希尔排序-缩小增量排序-简单插入排序的升级版" class="headerlink" title="希尔排序(缩小增量排序)(简单插入排序的升级版)"></a><strong>希尔排序(缩小增量排序)(简单插入排序的升级版)</strong></h2><blockquote>
<p>简单插入排序存在的问题<br>    我们看简单的插入排序可能存在的问题.<br>    数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：<br>    {2,3,4,5,6,6}<br>    {2,3,4,5,5,6}<br>    {2,3,4,4,5,6}<br>    {2,3,3,4,5,6}<br>    {2,2,3,4,5,6}<br>    {1,2,3,4,5,6}<br>    结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
</blockquote>
<p><strong>希尔排序法介绍</strong><br>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<p><strong>希尔排序法基本思想</strong><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止<br><strong>代码</strong></p>
<h3 id="1-交换希尔"><a href="#1-交换希尔" class="headerlink" title="(1)交换希尔"></a><strong>(1)交换希尔</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; a.length&#x2F;2; i &gt;0 ; i&#x2F;&#x3D;2) &#123;&#x2F;&#x2F;步长</span><br><span class="line">            for (int j &#x3D; i; j &lt;a.length; j++) &#123;&#x2F;&#x2F;分组</span><br><span class="line">                for (int k &#x3D; j-i; k &gt;&#x3D;0 ; k-&#x3D;i) &#123;&#x2F;&#x2F;组内比较</span><br><span class="line">                    if(a[k]&gt;a[k+i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        t&#x3D;a[k];</span><br><span class="line">                        a[k]&#x3D;a[k+i];</span><br><span class="line">                        a[k+i]&#x3D;t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000个随机数排序<br>执行结果：80000个随机数的排序时间为：12390毫秒</strong></p>
<h3 id="2-交换希尔加插入"><a href="#2-交换希尔加插入" class="headerlink" title="(2)交换希尔加插入"></a><strong>(2)交换希尔加插入</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; a.length&#x2F;2; i &gt;0 ; i&#x2F;&#x3D;2) &#123;&#x2F;&#x2F;步长</span><br><span class="line">            for (int j &#x3D; a.length-i; j &lt;a.length; j++) &#123;&#x2F;&#x2F;分组</span><br><span class="line">                for (int k &#x3D; j-i; k &gt;&#x3D;0 ; k-&#x3D;i) &#123;&#x2F;&#x2F;组内比较</span><br><span class="line">                    if(a[k]&gt;a[k+i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        t&#x3D;a[k];</span><br><span class="line">                        a[k]&#x3D;a[k+i];</span><br><span class="line">                        a[k+i]&#x3D;t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;a.length ; i++) &#123;</span><br><span class="line">            c&#x3D;a[i];</span><br><span class="line">            d&#x3D;i-1;</span><br><span class="line">            while(d&gt;&#x3D;0&amp;&amp;c&lt;a[d])&#123;</span><br><span class="line">                a[d+1]&#x3D;a[d];</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[d+1]&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：80000个随机数的排序时间为：181毫秒</strong></p>
<h3 id="3-移位法希尔"><a href="#3-移位法希尔" class="headerlink" title="(3)移位法希尔"></a><strong>(3)移位法希尔</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; a.length&#x2F;2; i &gt;0 ; i&#x2F;&#x3D;2) &#123;&#x2F;&#x2F;步长</span><br><span class="line">            for (int j &#x3D; i; j &lt;a.length; j+&#x3D;1) &#123;&#x2F;&#x2F;分组</span><br><span class="line">                c&#x3D;a[j];</span><br><span class="line">                d&#x3D;j-i;</span><br><span class="line">                if(a[j]&lt;a[j-i])</span><br><span class="line">                while(d&gt;&#x3D;0&amp;&amp;c&lt;a[d])&#123;</span><br><span class="line">                    a[d+i]&#x3D;a[d];</span><br><span class="line">                    d-&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                a[d+i]&#x3D;c;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：80000个随机数的排序时间为：48毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：800000个随机数的排序时间为：250(261)毫秒</strong><br><strong>8000000(800w)个随机数排序<br>执行结果：8000000个随机数的排序时间为：2875(2907)毫秒</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h2><p><strong>快速排序法介绍:</strong><br>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此达到整个数据变成有序序列</p>
<h3 id="1-帮助理解快排的代码"><a href="#1-帮助理解快排的代码" class="headerlink" title="(1)帮助理解快排的代码"></a><strong>(1)帮助理解快排的代码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class KuaiSu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        quickSort(a,0,a.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void quickSort(int[] a,int left,int right)</span><br><span class="line">    &#123;</span><br><span class="line">        int l&#x3D;left;</span><br><span class="line">        int r&#x3D;right;</span><br><span class="line">        int c&#x3D;a[(l+r)&#x2F;2];</span><br><span class="line">        System.out.println(&quot;l&#x3D;&quot;+l+&quot;;  r&#x3D;&quot;+r+&quot;;  中间数为&quot;+c+&quot;;&quot;);</span><br><span class="line">        int d;</span><br><span class="line">        while(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            while(a[l]&lt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;l&#x3D;&quot;+l+&quot;; &quot;);</span><br><span class="line">            while(a[r]&gt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;r&#x3D;&quot;+r+&quot;; &quot;);</span><br><span class="line">            if(l&gt;&#x3D;r)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             d&#x3D;a[r];</span><br><span class="line">            a[r]&#x3D;a[l];</span><br><span class="line">            a[l]&#x3D;d;</span><br><span class="line">            if(a[l]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(a[r]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l+&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">        if(l&#x3D;&#x3D;r)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;\n左递归&quot;);</span><br><span class="line">            quickSort(a,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;\n右递归&quot;);</span><br><span class="line">            quickSort(a,l,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<pre><code>[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
l=0;  r=9;  中间数为2;
l=0; r=9; 将a[l]=8和a[r]=0交换      [0, 9, 1, 7, 2, 3, 5, 4, 6, 8]
l=1; r=4; 将a[l]=9和a[r]=2交换      [0, 2, 1, 7, 9, 3, 5, 4, 6, 8]
l=1; r=2; 将a[l]=2和a[r]=1交换      [0, 1, 2, 7, 9, 3, 5, 4, 6, 8]
l=2; r=2; 
左递归
l=0;  r=1;  中间数为0;
l=0; r=0; 
右递归
l=3;  r=9;  中间数为5;
l=3; r=7; 将a[l]=7和a[r]=4交换      [0, 1, 2, 4, 9, 3, 5, 7, 6, 8]
l=4; r=6; 将a[l]=9和a[r]=5交换      [0, 1, 2, 4, 5, 3, 9, 7, 6, 8]
l=4; r=5; 将a[l]=5和a[r]=3交换      [0, 1, 2, 4, 3, 5, 9, 7, 6, 8]
l=5; r=5; 
左递归
l=3;  r=4;  中间数为4;
l=3; r=4; 将a[l]=4和a[r]=3交换      [0, 1, 2, 3, 4, 5, 9, 7, 6, 8]
l=4; r=4; 
右递归
l=6;  r=9;  中间数为7;
l=6; r=8; 将a[l]=9和a[r]=6交换      [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
l=7; r=7; 
右递归
l=8;  r=9;  中间数为9;
l=8; r=9; 将a[l]=9和a[r]=8交换      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l=9; r=9; </code></pre><h3 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="(2)测试代码"></a><strong>(2)测试代码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class KuaiSu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[8000000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;8000000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        quickSort(a,0,a.length-1);</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">          &#x2F;&#x2F;  System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void quickSort(int[] a,int left,int right)</span><br><span class="line">    &#123;</span><br><span class="line">        int l&#x3D;left;</span><br><span class="line">        int r&#x3D;right;</span><br><span class="line">        int c&#x3D;a[(l+r)&#x2F;2];</span><br><span class="line">        int d;</span><br><span class="line">        while(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            while(a[l]&lt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(a[r]&gt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l&gt;&#x3D;r)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            d&#x3D;a[r];</span><br><span class="line">            a[r]&#x3D;a[l];</span><br><span class="line">            a[l]&#x3D;d;</span><br><span class="line">            if(a[l]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                r-&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(a[r]&#x3D;&#x3D;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l+&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l&#x3D;&#x3D;r)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            quickSort(a,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            quickSort(a,l,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：80000个随机数的排序时间为：39(36)(41)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：800000个随机数的排序时间为：177(189)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：80000000个随机数的排序时间为：1441(1530)毫秒</strong></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h2><p><strong>归并排序介绍:</strong><br>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题，分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><img src="/images/34.png" alt=""><br><strong>说明:</strong><br>分的时候只是为了给治提供条件，并没有其他的作用。<br>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。<br>合的时候需要用到临时数组。</p>
<p><strong>测试代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class GuiBing &#123;</span><br><span class="line">    static int  times&#x3D;0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;*int arr[]&#x3D;&#123;8,4,5,7,1,3,6,2&#125;;</span><br><span class="line">int temp[]&#x3D;new int[arr.length];</span><br><span class="line">mergeSort(arr,0,arr.length-1,temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));*&#x2F;</span><br><span class="line"></span><br><span class="line">        int[] arr&#x3D;new int[8000000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;8000000; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line">        int  temp[]&#x3D;new int[arr.length];</span><br><span class="line">        mergeSort(arr,0,arr.length-1,temp);</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">            &#x2F;&#x2F;  System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;归并的次数为：&quot;+times);</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分加并</span><br><span class="line">    public static void mergeSort(int[] a,int left,int right,int[] temp)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">        if(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mergeSort(a,left,mid,temp);</span><br><span class="line">            mergeSort(a,mid+1,right,temp);</span><br><span class="line">            merge(a,left,mid,right,temp);</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;并的方法</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param a             排序的原始数组</span><br><span class="line">     * @param left          左边有序序列的初始索引</span><br><span class="line">     * @param mid           中间索引</span><br><span class="line">     * @param right         最右边索引(结束索引)</span><br><span class="line">     * @param temp          中转数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void merge(int[] a,int left,int mid,int right,int[] temp)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化数据</span><br><span class="line">        int i&#x3D;left;</span><br><span class="line">        int j&#x3D;mid+1;</span><br><span class="line">        int t&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;第一步：比较</span><br><span class="line">        while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;right)</span><br><span class="line">        &#123;if(a[i]&lt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp[t]&#x3D;a[i];</span><br><span class="line">                i++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                temp[t]&#x3D;a[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第二步，将剩余的合并</span><br><span class="line">        while(i&lt;&#x3D;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[t]&#x3D;a[i];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[t]&#x3D;a[j];</span><br><span class="line">            t++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第三步，将temp复制回来</span><br><span class="line">        j&#x3D;right;</span><br><span class="line">        t--;</span><br><span class="line">        while(t&gt;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j]&#x3D;temp[t];</span><br><span class="line">            t--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>80000(8w)个随机数排序<br>执行结果：<br>归并的次数为：79999<br>80000个随机数的排序时间为：27(33)(26)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：<br>归并的次数为：799999<br>800000个随机数的排序时间为：171(162)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：<br>归并的次数为：7999999<br>80000000个随机数的排序时间为：1788(1700)毫秒</strong></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h2><p><strong>基数排序(桶排序)介绍:</strong><br>1.基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用<br>2.基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法<br>3.基数排序(Radix Sort)是桶排序的扩展<br>4.基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p><strong>基于两种不同的排序顺序，我们将基数排序分为</strong><br>    LSD（Least significant digital）：排序方式由数值的最右边（低位）开始<br>    MSD（Most significant digital）：由数值的最左边（高位）开始。</p>
<p><strong>基数排序基本思想</strong><br>基数排序是通过“分配”和“收集”过程来实现排序。<br>1)分配，先从个位开始，根据位值(0-9)分别放到0-9号桶中（比如53,个位为3，则放入3号桶中）<br>2)收集，再将放置在0 ~ 9号桶中的数据按顺序放到数组中<br>重复(1)(2)过程，从个位到最高位（比如32位无符号整形最大数4294967296，最高位10位）。</p>
<p>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤<br><img src="/images/35.png" alt=""><br><img src="/images/36.png" alt=""><br><img src="/images/37.png" alt=""><br><strong>基数排序的说明:</strong><br>基数排序是对传统桶排序的扩展，速度很快.<br>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。<br>基数排序是稳定的。<br>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a> </p>
<p><strong>测试代码(LSD)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JiShu_RadixSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F; int arr[]&#x3D;&#123;53, 3, 542, 748, 14, 214,155,21,365,4545,231,31,6542,1321,3,1,16,51,21,321,56,12 &#125;;</span><br><span class="line">        int[] arr&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;求出最大的数的位数MaxSize</span><br><span class="line">        int max&#x3D;arr[0];</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            if(i&gt;max)</span><br><span class="line">                max&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        int MaxSize&#x3D;(max+&quot;&quot;).length();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;bucket为设置的十个桶，bucketCount为每个桶先存的数据个数</span><br><span class="line">        int[][] bucket&#x3D;new int[10][arr.length];</span><br><span class="line">        int[]  bucketCount&#x3D;new int[10];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;基数排序需要遍历次数为最大数的位数，n用来求各个位。</span><br><span class="line">        for (int i &#x3D; 0,n&#x3D;1; i &lt; MaxSize; i++,n*&#x3D;10) &#123;</span><br><span class="line">            &#x2F;&#x2F;1.将数据放入桶中</span><br><span class="line">            for (int i1 : arr) &#123;</span><br><span class="line">                bucket[i1&#x2F;n%10][bucketCount[i1&#x2F;n%10]]&#x3D;i1;</span><br><span class="line">                bucketCount[i1&#x2F;n%10]++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;2.从桶中将数据取回</span><br><span class="line">            int t&#x3D;0;&#x2F;&#x2F;临时变量，用来存入原数组</span><br><span class="line">            for (int i1 &#x3D; 0; i1 &lt; 10; i1++)&#x2F;&#x2F;i1表示第几个桶，总共有十个</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j &#x3D; 0; bucketCount[i1]&gt;0 ; j++,bucketCount[i1]--) &#123;</span><br><span class="line">                    arr[t++]&#x3D;bucket[i1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">             &#x2F;&#x2F;System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>80000(8w)个随机数排序<br>执行结果：<br>80000个随机数的排序时间为：14(12)(15)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：<br>800000个随机数的排序时间为：139(95)(118)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：<br>80000000个随机数的排序时间为：685(628)毫秒</strong></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h2><p><strong>堆排序基本介绍</strong></p>
<ol>
<li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</li>
<li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li>
<li>大顶堆举例说明<br><img src="/images/46.png" alt=""><br><img src="/images/47.png" alt=""><br>大顶堆特点：arr[i] &gt;= arr[2* i+1] &amp;&amp; arr[i] &gt;= arr[2* i+2] //i对应第几个节点，i从0开始编号</li>
</ol>
<p><strong>堆排序基本思想</strong></p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
</ol>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p><strong>堆排序思路和步骤</strong><br>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。<br>1).假设给定无序序列结构如下<br><img src="/images/48.png" alt=""><br>2).此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。<br><img src="/images/49.png" alt=""><br>3).找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。<br><img src="/images/50.png" alt=""><br>4)这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。<br><img src="/images/51.png" alt=""><br>此时，我们就将一个无序序列构造成了一个大顶堆。<br>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。<br>1).将堆顶元素9和末尾元素4进行交换<br><img src="/images/52.png" alt=""><br>2).重新调整结构，使其继续满足堆定义<br><img src="/images/53.png" alt=""><br>3).再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.<br><img src="/images/54.png" alt=""><br>4)后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="/images/55.png" alt=""></p>
<h3 id="再简单总结下堆排序的基本思路："><a href="#再简单总结下堆排序的基本思路：" class="headerlink" title="再简单总结下堆排序的基本思路："></a><strong>再简单总结下堆排序的基本思路：</strong></h3><ol>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package 排序;</span><br><span class="line">&#x2F;&#x2F;堆排序</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class HeapSortDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a&#x3D;new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;80000; i++) &#123;</span><br><span class="line">            a[i]&#x3D;(int)(Math.random()*9000);</span><br><span class="line">        &#125;</span><br><span class="line">        int d&#x3D;0;int c&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        long time&#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        HeapSort(a);</span><br><span class="line"></span><br><span class="line">        long time1&#x3D;System.currentTimeMillis()-time;</span><br><span class="line">        int h&#x3D;0;</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            if(i&lt;h)</span><br><span class="line">                throw new RuntimeException(&quot;Cuowu&quot;);</span><br><span class="line">            h&#x3D;i;</span><br><span class="line">             &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;80000个随机数的排序时间为：&quot;+time1);</span><br><span class="line">    &#125;</span><br><span class="line">public static void HeapSort(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">&#x2F;&#x2F;先进行第一次堆调整</span><br><span class="line">    for (int i &#x3D; arr.length&#x2F;2-1; i &gt;&#x3D;0 ; i--) &#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;进行交换，并排序完所有的数</span><br><span class="line">    for (int i &#x3D; arr.length-1; i &gt;0 ; i--) &#123;</span><br><span class="line">        temp&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;arr[0];</span><br><span class="line">        arr[0]&#x3D;temp;</span><br><span class="line">        adjustHeap(arr,0,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void adjustHeap(int arr[],int i,int lenght)</span><br><span class="line">&#123; int temp&#x3D;arr[i];</span><br><span class="line">    for (int k&#x3D; i*2+1; k &lt;lenght ; k&#x3D;k*2+1) &#123;</span><br><span class="line">        if(k+1&lt;lenght&amp;&amp;arr[k]&lt;arr[k+1])</span><br><span class="line">        &#123;</span><br><span class="line">            k&#x3D;k+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[k]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i]&#x3D;arr[k];</span><br><span class="line">            i&#x3D;k;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">        arr[k]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>80000(8w)个随机数排序<br>执行结果：<br>80000个随机数的排序时间为：27(17)(18)毫秒</strong><br><strong>800000(80w)个随机数排序<br>执行结果：<br>800000个随机数的排序时间为：195(163)(200)毫秒</strong><br><strong>80000000(800w)个随机数排序<br>执行结果：<br>80000000个随机数的排序时间为：2384(2365)毫秒</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/" data-id="ckb22iug600aozwu82m34ax50" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          查找算法
        
      </div>
    </a>
  
  
    <a href="/2020/02/19/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">二分查找算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>