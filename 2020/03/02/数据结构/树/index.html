<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>树 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="二叉树为什么需要树这种数据结构 数组存储方式的分析优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 链式存储方式的分析优点：在一定程度上对数组存储方式有优化(6比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="https://tukuai.github.io/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="二叉树为什么需要树这种数据结构 数组存储方式的分析优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 链式存储方式的分析优点：在一定程度上对数组存储方式有优化(6比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tukuai.github.io/images/42.png">
<meta property="og:image" content="https://tukuai.github.io/images/30.png">
<meta property="og:image" content="https://tukuai.github.io/images/44.png">
<meta property="og:image" content="https://tukuai.github.io/images/45.png">
<meta property="og:image" content="https://tukuai.github.io/images/56.png">
<meta property="og:image" content="https://tukuai.github.io/images/57.png">
<meta property="og:image" content="https://tukuai.github.io/images/58.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/59.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/60.png">
<meta property="og:image" content="https://tukuai.github.io/images/61.png">
<meta property="og:image" content="https://tukuai.github.io/images/62.png">
<meta property="og:image" content="https://tukuai.github.io/images/63.png">
<meta property="og:image" content="https://tukuai.github.io/images/64.png">
<meta property="og:image" content="https://tukuai.github.io/images/65.png">
<meta property="og:image" content="https://tukuai.github.io/images/66.png">
<meta property="og:image" content="https://tukuai.github.io/images/67.png">
<meta property="article:published_time" content="2020-03-02T06:50:51.000Z">
<meta property="article:modified_time" content="2020-03-09T07:10:23.208Z">
<meta property="article:author" content="Tukuai">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tukuai.github.io/images/42.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数据结构/树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/" class="article-date">
  <time datetime="2020-03-02T06:50:51.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h2><h3 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a><strong>为什么需要树这种数据结构</strong></h3><ol>
<li>数组存储方式的分析<br>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度<br>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</li>
<li>链式存储方式的分析<br>优点：在一定程度上对数组存储方式有优化(6比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。<br>缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</li>
<li>树存储方式的分析<br>能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li>
</ol>
<h3 id="树的常用术语-结合示意图理解"><a href="#树的常用术语-结合示意图理解" class="headerlink" title="树的常用术语(结合示意图理解):"></a><strong>树的常用术语(结合示意图理解):</strong></h3><p>节点<br>根节点<br>父节点<br>子节点<br>叶子节点 (没有子节点的节点)<br>节点的权(节点值)<br>路径(从root节点找到该节点的路线)<br>层<br>子树<br>树的高度(最大层数)<br>森林 :多颗子树构成森林<br><img src="/images/42.png" alt=""></p>
<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><strong>二叉树的概念</strong></h3><p>1.树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。<br>2.二叉树的子节点分为左节点和右节点。<br>3.如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为<strong>满二叉树。</strong><br>4.如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为<strong>完全二叉树。</strong></p>
<h3 id="二叉树遍历的说明"><a href="#二叉树遍历的说明" class="headerlink" title="二叉树遍历的说明"></a><strong>二叉树遍历的说明</strong></h3><p>使用前序，中序和后序对下面的二叉树进行遍历.<br><strong>前序遍历:</strong> 先输出父节点，再遍历左子树和右子树<br><strong>中序遍历:</strong> 先遍历左子树，再输出父节点，再遍历右子树<br><strong>后序遍历:</strong> 先遍历左子树，再遍历右子树，最后输出父节点<br><strong>小结:</strong> 看输出父节点的顺序，就确定是前序，中序还是后序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先创建一个二叉树</span><br><span class="line">        BinaryTree binaryTree &#x3D; new BinaryTree();</span><br><span class="line">        &#x2F;&#x2F;创建需要的结点</span><br><span class="line">        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);</span><br><span class="line">        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);</span><br><span class="line">        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);</span><br><span class="line">        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);</span><br><span class="line">        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">		System.out.println(&quot;前序遍历&quot;); &#x2F;&#x2F; 1,2,3,5,4</span><br><span class="line">		binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">		System.out.println(&quot;中序遍历&quot;);</span><br><span class="line">		binaryTree.infixOrder(); &#x2F;&#x2F; 2,1,5,3,4</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;后序遍历&quot;);</span><br><span class="line">		binaryTree.postOrder(); &#x2F;&#x2F; 2,5,4,3,1</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(binaryTree.preSearch(1));</span><br><span class="line">        System.out.println(binaryTree.preSearch(2));</span><br><span class="line">        System.out.println(binaryTree.preSearch(3));</span><br><span class="line">        System.out.println(binaryTree.preSearch(4));</span><br><span class="line">        System.out.println(binaryTree.preSearch(5));</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(binaryTree.infixSearch(1));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(2));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(3));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(4));</span><br><span class="line">        System.out.println(binaryTree.infixSearch(5));</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        System.out.println(binaryTree.postSearch(1));</span><br><span class="line">        System.out.println(binaryTree.postSearch(2));</span><br><span class="line">        System.out.println(binaryTree.postSearch(3));</span><br><span class="line">        System.out.println(binaryTree.postSearch(4));</span><br><span class="line">        System.out.println(binaryTree.postSearch(5));</span><br><span class="line">        System.out.println(&quot;*****************&quot;);</span><br><span class="line">        binaryTree.deleteNode(6);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    private HeroNode root;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.preOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void postOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.postOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode preSearch(int no)</span><br><span class="line">    &#123;   if(this.root!&#x3D;null)</span><br><span class="line">            return root.preSearch(no);</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode infixSearch(int no)</span><br><span class="line">    &#123;   if(this.root!&#x3D;null)</span><br><span class="line">            return root.infixSearch(no);</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode postSearch(int no)</span><br><span class="line">    &#123;   if(this.root!&#x3D;null)</span><br><span class="line">            return root.postSearch(no);</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root.getNo()&#x3D;&#x3D;num)</span><br><span class="line">        &#123;</span><br><span class="line">            HeroNode temp&#x3D;root.getRight();</span><br><span class="line">            root&#x3D;root.getLeft();</span><br><span class="line">            if(root&#x3D;&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode T&#x3D;root;</span><br><span class="line">                while(T.getRight()!&#x3D;null)</span><br><span class="line">                &#123;</span><br><span class="line">                    T&#x3D;T.getRight();</span><br><span class="line">                &#125;</span><br><span class="line">                T.setRight(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;删除成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int i&#x3D; root.deleteNode(num);</span><br><span class="line">            if(i&#x3D;&#x3D;1)</span><br><span class="line">                System.out.println(&quot;删除成功&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;不存在该节点&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HeroNode</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int no;</span><br><span class="line">    private HeroNode left;</span><br><span class="line">    private HeroNode right;</span><br><span class="line">    &#x2F;&#x2F;三种遍历算法</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public void postOrder()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;三种查找算法</span><br><span class="line">   public HeroNode preSearch(int num)</span><br><span class="line">   &#123;</span><br><span class="line">       HeroNode resNode&#x3D;null;</span><br><span class="line">       System.out.print(&quot;* &quot;);</span><br><span class="line">       if(this.no&#x3D;&#x3D;num)</span><br><span class="line">           return this;</span><br><span class="line">       if(this.left!&#x3D;null)</span><br><span class="line">           resNode&#x3D;this.left.preSearch(num);</span><br><span class="line">       if(resNode!&#x3D;null)</span><br><span class="line">           return resNode;</span><br><span class="line">       if(this.right!&#x3D;null)</span><br><span class="line">           resNode&#x3D;this.right.preSearch(num);</span><br><span class="line">       return resNode;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    public HeroNode infixSearch(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.left.infixSearch(num);</span><br><span class="line">        if(resNode!&#x3D;null)</span><br><span class="line">            return resNode;</span><br><span class="line">        System.out.print(&quot;* &quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;num)</span><br><span class="line">            return this;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.right.infixSearch(num);</span><br><span class="line">        return resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode postSearch(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.left.postSearch(num);</span><br><span class="line">        if(resNode!&#x3D;null)</span><br><span class="line">            return resNode;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            resNode&#x3D;this.right.postSearch(num);</span><br><span class="line">        if(resNode!&#x3D;null)</span><br><span class="line">            return resNode;</span><br><span class="line">        System.out.print(&quot;* &quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;num)</span><br><span class="line">            return this;</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;删除算法(先续）</span><br><span class="line">    public int deleteNode(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left.no&#x3D;&#x3D;num)</span><br><span class="line">            &#123;   HeroNode temp&#x3D;this.left.right;</span><br><span class="line">                this.left&#x3D;this.left.left;</span><br><span class="line">                HeroNode T&#x3D;this.left;</span><br><span class="line">                if(T&#x3D;&#x3D;null)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.left&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    while(T.right!&#x3D;null)</span><br><span class="line">                        T&#x3D;T.right;</span><br><span class="line">                    T.right&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">            if(this.left.deleteNode(num)&#x3D;&#x3D;1)</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right.no&#x3D;&#x3D;num)</span><br><span class="line">            &#123;   HeroNode temp&#x3D;this.right.left;</span><br><span class="line">                this.right&#x3D;this.right.right;</span><br><span class="line">                HeroNode T&#x3D;this.right;</span><br><span class="line">                if(T&#x3D;&#x3D;null)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.right&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    while(T.left!&#x3D;null)</span><br><span class="line">                        T&#x3D;T.left;</span><br><span class="line">                    T.left&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               return this.right.deleteNode(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public HeroNode(int no,String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, no&#x3D;&quot; + no +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序存储二叉树-堆排序"><a href="#顺序存储二叉树-堆排序" class="headerlink" title="顺序存储二叉树(堆排序)"></a><strong>顺序存储二叉树(堆排序)</strong></h2><p><strong>顺序存储二叉树的概念</strong><br><strong>基本说明</strong><br>从数据存储来看，数组存储方式和树<br>的存储方式可以相互转换，即数组可<br>以转换成树，树也可以转换成数组，<br>看下面的示意图。<br><strong>要求:</strong><br>下图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]<br>要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历<br><img src="/images/30.png" alt=""><br><strong>顺序存储二叉树的特点:</strong></p>
<ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n个元素的左子节点为  2 * n + 1 </li>
<li>第n个元素的右子节点为  2 * n + 2</li>
<li>第n个元素的父节点为  (n-1) / 2</li>
<li>n : 表示二叉树中的第几个元素(按0开始编号如图所示)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class ArrBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">int[] arr&#x3D;&#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">ArrBinaryTree a&#x3D;new ArrBinaryTree(arr);</span><br><span class="line">a.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArrBinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    private int arr[];</span><br><span class="line"></span><br><span class="line">    public ArrBinaryTree(int[] arr) &#123;</span><br><span class="line">        this.arr &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        this.preOrder(0);</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr&#x3D;&#x3D;null&amp;&amp;arr.length&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;数组为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        if((2*index+1)&lt;arr.length)</span><br><span class="line">        &#123;</span><br><span class="line">            preOrder(2*index+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if((2*index+2)&lt;arr.length)</span><br><span class="line">        &#123;</span><br><span class="line">            preOrder(2*index+2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a><strong>线索化二叉树</strong></h2><p>先看一个问题<br>将数列 {1, 3, 6, 8, 10, 14  } 构建成一颗二叉树.  n+1=7<br><img src="/images/44.png" alt=""></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析:"></a><strong>问题分析:</strong></h3><ol>
<li>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }</li>
<li>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</li>
<li>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?</li>
<li>解决方案-线索二叉树</li>
</ol>
<h3 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a><strong>线索二叉树基本介绍</strong></h3><ol>
<li>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</li>
<li>一个结点的前一个结点，称为前驱结点</li>
<li>一个结点的后一个结点，称为后继结点<br><img src="/images/45.png" alt=""></li>
</ol>
<p><strong>说明: 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况:</strong><br>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.<br>right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.<br><strong>代码只实现了中序线索化和遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class ThreadedBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试一把中序线索二叉树的功能</span><br><span class="line">        HeroNode1 root &#x3D; new HeroNode1(1, &quot;tom&quot;);</span><br><span class="line">        HeroNode1 node2 &#x3D; new HeroNode1(3, &quot;jack&quot;);</span><br><span class="line">        HeroNode1 node3 &#x3D; new HeroNode1(6, &quot;smith&quot;);</span><br><span class="line">        HeroNode1 node4 &#x3D; new HeroNode1(8, &quot;mary&quot;);</span><br><span class="line">        HeroNode1 node5 &#x3D; new HeroNode1(10, &quot;king&quot;);</span><br><span class="line">        HeroNode1 node6 &#x3D; new HeroNode1(14, &quot;dim&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试中序线索化</span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试: 以10号节点测试</span><br><span class="line">        HeroNode1 leftNode &#x3D; node5.getLeft();</span><br><span class="line">        HeroNode1 rightNode &#x3D; node5.getRight();</span><br><span class="line">        System.out.println(&quot;10号结点的前驱结点是 &#x3D;&quot;  + leftNode); &#x2F;&#x2F;3</span><br><span class="line">        System.out.println(&quot;10号结点的后继结点是&#x3D;&quot;  + rightNode); &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当线索化二叉树后，能在使用原来的遍历方法</span><br><span class="line">        &#x2F;&#x2F;threadedBinaryTree.infixOrder();</span><br><span class="line">        System.out.println(node3.getRight());</span><br><span class="line">        System.out.println(&quot;使用线索化的方式遍历 线索化二叉树&quot;);</span><br><span class="line">        threadedBinaryTree.threadedList(); &#x2F;&#x2F; 8, 3, 10, 1, 14, 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class ThreadedBinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    private HeroNode1 root;</span><br><span class="line">    &#x2F;&#x2F;为了实现线索化，需要创建一个前驱结点指针,在线索化的时候pre总是指向前一个节点</span><br><span class="line">    private HeroNode1 pre&#x3D;null;</span><br><span class="line">    &#x2F;&#x2F;编写对二叉树进行中序线索化的方法</span><br><span class="line">    public void threadedNodes()</span><br><span class="line">    &#123;</span><br><span class="line">        threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">    public void threadedList()</span><br><span class="line">    &#123;</span><br><span class="line">        HeroNode1 node&#x3D;root;</span><br><span class="line">        while(node!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            while(node.getLeftType()!&#x3D;1)</span><br><span class="line">                node&#x3D;node.getLeft();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            while(node.getRight()!&#x3D;null&amp;&amp;node.getRightType()&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                node&#x3D;node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node&#x3D;node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void threadedNodes(HeroNode1 node)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;node&#x3D;&#x3D;null</span><br><span class="line">        if(node&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;线索化左子树</span><br><span class="line">        threadedNodes(node.getLeft());</span><br><span class="line">        &#x2F;&#x2F;线索化当前节点</span><br><span class="line">        if(node.getLeft()&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre!&#x3D;null&amp;&amp;pre.getRight()&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        pre&#x3D;node;</span><br><span class="line">        &#x2F;&#x2F;线索化右子树</span><br><span class="line">        threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    public void setRoot(HeroNode1 root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class HeroNode1</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int no;</span><br><span class="line">    private HeroNode1 left;</span><br><span class="line">    private HeroNode1 right;</span><br><span class="line">    &#x2F;&#x2F;如果leftType&#x3D;&#x3D;0表示指向的是左子树，是1表示指向前驱结点</span><br><span class="line">    &#x2F;&#x2F;如果rightType&#x3D;&#x3D;0表示指向的是右子树，是1表示指向后继结点</span><br><span class="line">    private int leftType;</span><br><span class="line">    private int rightType;</span><br><span class="line"></span><br><span class="line">    public int getLeftType() &#123;</span><br><span class="line">        return leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftType(int leftType) &#123;</span><br><span class="line">        this.leftType &#x3D; leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRightType() &#123;</span><br><span class="line">        return rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightType(int rightType) &#123;</span><br><span class="line">        this.rightType &#x3D; rightType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public HeroNode1(int no,String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode1 left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode1 right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode1&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, no&#x3D;&quot; + no +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a><strong>赫夫曼树</strong></h2><p><strong>基本介绍</strong></p>
<ol>
<li>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</li>
<li>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</li>
</ol>
<p><strong>赫夫曼树几个重要概念和举例说明</strong></p>
<ol>
<li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li>树的带权路径长度：树的带权路径长度规定为所有<strong>叶子结点</strong>的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li>
<li>WPL最小的就是赫夫曼树<br><img src="/images/56.png" alt=""></li>
</ol>
<p><strong>构成赫夫曼树的步骤：</strong></p>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树 </li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </li>
<li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class HuffmanTree&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[]&#x3D;&#123;13, 7, 8, 3, 29, 6, 1&#125;;</span><br><span class="line">        Node n&#x3D;createHuffman(arr);</span><br><span class="line">        n.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public static  void preOrder(Node root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null)</span><br><span class="line">            System.out.println(&quot;该树为空&quot;);</span><br><span class="line">        else</span><br><span class="line">            root.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public  static Node createHuffman(int arr[])</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            Node node&#x3D;new Node(i);</span><br><span class="line"></span><br><span class="line">            nodes.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        while(nodes.size()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            Node left&#x3D;nodes.get(0);</span><br><span class="line">            Node right&#x3D;nodes.get(1);</span><br><span class="line">            Node parent&#x3D;new Node(left.value+right.value);</span><br><span class="line">            parent.left&#x3D;left;</span><br><span class="line">            parent.right&#x3D;right;</span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;为了让Node支持排序，让Node实现Comparable接口</span><br><span class="line">class Node implements Comparable&lt;Node&gt;</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示从小到大排序</span><br><span class="line">        return this.value-o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a><strong>赫夫曼编码</strong></h2><p><strong>基本介绍</strong></p>
<ol>
<li>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</li>
<li>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ol>
<h3 id="定长编码原理剖析"><a href="#定长编码原理剖析" class="headerlink" title="定长编码原理剖析"></a><strong>定长编码原理剖析</strong></h3><pre><code>通信领域中信息的处理方式1-定长编码
i like like like java do you like a java       // 共40个字符(包括空格)  
105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  //对应Ascii码
01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制
按照二进制来传递信息，总的长度是  359   (包括空格)        </code></pre><h3 id="变长编码原理剖析"><a href="#变长编码原理剖析" class="headerlink" title="变长编码原理剖析"></a><strong>变长编码原理剖析</strong></h3><pre><code>通信领域中信息的处理方式2-变长编码
i like like like java do you like a java       // 共40个字符(包括空格)
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.
按照上面给各个字符规定的编码，则我们在传输  &quot;i like like like java do you like a java&quot; 数据时，编码就是 10010110100...  
字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码(这个在赫夫曼编码中，我们还要进行举例说明, 不捉急)</code></pre><h3 id="赫夫曼编码原理剖析"><a href="#赫夫曼编码原理剖析" class="headerlink" title="赫夫曼编码原理剖析"></a><strong>赫夫曼编码原理剖析</strong></h3><pre><code>通信领域中信息的处理方式3-赫夫曼编码
i like like like java do you like a java       // 共40个字符(包括空格)
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值.(图后)</code></pre><p><img src="/images/57.png" alt=""></p>
<pre><code>根据赫夫曼树，给各个字符规定编码 ， 向左的路径为0，向右的路径为1 ， 编码如下:
o: 1000   u: 10010  d: 100110  y: 100111  i: 101
a : 110     k: 1110    e: 1111       j: 0000       v: 0001
l: 001          : 01
按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot;   字符串对应的编码为 (注意这里我们使用的无损压缩)
1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110
长度为 ： 133 
说明:
原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%
此编码满足前缀编码, 因为只有叶子节点才算入赫夫曼树，而若是前缀冲突的话其中必有一个不是叶子结点。即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性
注意： 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的（相同权值的前后问题）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class HuffmanCode &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;*String content&#x3D;&quot;i like like like java do you like a java&quot;;</span><br><span class="line">        byte[] b&#x3D;content.getBytes();</span><br><span class="line">        byte[] bytes &#x3D; zip(b);</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        byte[] bs &#x3D; decode(codes, bytes);</span><br><span class="line">        System.out.println(&quot;原来的字符串&#x3D;&quot; + new String(bs));*&#x2F;</span><br><span class="line">    String srcFile&#x3D;&quot;C:\\Users\\wjh\\Pictures\\Saved Pictures\\ccc.bmp&quot;;</span><br><span class="line">    String dstFile&#x3D;&quot;C:\\Users\\wjh\\Pictures\\Saved Pictures\\111.zip&quot;;</span><br><span class="line">    String dstFile1&#x3D;&quot;C:\\Users\\wjh\\Pictures\\Saved Pictures\\ccc1.bmp&quot;;</span><br><span class="line">    zipFile(srcFile,dstFile);</span><br><span class="line">        System.out.println(&quot;文件压缩成功&quot;);</span><br><span class="line">    unZipFile(dstFile,dstFile1);</span><br><span class="line">        System.out.println(&quot;文件解压成功&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存储叶子结点的路径</span><br><span class="line">    static StringBuilder s1&#x3D;new StringBuilder();</span><br><span class="line">    &#x2F;&#x2F;将赫夫曼编码表放到map中</span><br><span class="line">    static HashMap&lt;Byte,String&gt; codes&#x3D;new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void unZipFile(String zipFile, String dstFile) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义文件输入流</span><br><span class="line">        InputStream is &#x3D;  new FileInputStream(zipFile);</span><br><span class="line">        &#x2F;&#x2F;定义一个对象输入流</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(is);</span><br><span class="line">        &#x2F;&#x2F;定义文件的输出流</span><br><span class="line">        OutputStream os &#x3D; new FileOutputStream(dstFile);</span><br><span class="line">        &#x2F;&#x2F;读取byte数组  huffmanBytes</span><br><span class="line">        byte[] huffmanBytes &#x3D; (byte[])ois.readObject();</span><br><span class="line">        &#x2F;&#x2F;读取赫夫曼编码表</span><br><span class="line">        Map&lt;Byte,String&gt; huffmanCodes &#x3D; (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line">        &#x2F;&#x2F;解码</span><br><span class="line">        byte[] bytes &#x3D; decode(codes, huffmanBytes);</span><br><span class="line">        &#x2F;&#x2F;将bytes 数组写入到目标文件</span><br><span class="line">        &#x2F;&#x2F;写数据到 dstFile 文件</span><br><span class="line">        os.write(bytes);</span><br><span class="line">        os.close();</span><br><span class="line">        ois.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;编写一个方法，将一个文件进行压缩</span><br><span class="line">    public static void zipFile(String srcFile,String dstFile) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建输出流，存放压缩文件</span><br><span class="line">        OutputStream os&#x3D;new FileOutputStream(dstFile);</span><br><span class="line">        &#x2F;&#x2F;创建文件的输入流</span><br><span class="line">        FileInputStream is &#x3D; new FileInputStream(srcFile);</span><br><span class="line">        &#x2F;&#x2F;创建和文件输出流关联的ObjectOutputStream</span><br><span class="line">        ObjectOutputStream oos &#x3D; new ObjectOutputStream(os);</span><br><span class="line">        &#x2F;&#x2F;读取文件</span><br><span class="line">       byte[] bs&#x3D;new byte[is.available()];</span><br><span class="line">        is.read(bs);</span><br><span class="line">        is.close();</span><br><span class="line">        byte[] huffmanBytes&#x3D;zip(bs);</span><br><span class="line">        &#x2F;&#x2F;这里以对象流的方式写入赫夫曼编码，为的是我们恢复文件时使用</span><br><span class="line">        oos.writeObject(huffmanBytes);</span><br><span class="line">        &#x2F;&#x2F;这里一定要把赫夫曼编码写入压缩文件</span><br><span class="line">        oos.writeObject(codes);</span><br><span class="line">        oos.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对字符串进行压缩</span><br><span class="line">     * @param bs 传入要压缩的字节数组</span><br><span class="line">     * @return  压缩过后的字节数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] zip(byte[] bs)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;char[] chars&#x3D;content.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;NodeChar&gt; nodes &#x3D; getNodes(bs);</span><br><span class="line">        NodeChar huffman &#x3D; createHuffman(nodes);</span><br><span class="line">        HashMap&lt;Byte,String&gt; huffmanCodes&#x3D;getCodes(huffman);</span><br><span class="line">        StringBuilder s2&#x3D;new StringBuilder();</span><br><span class="line">        for (byte c : bs) &#123;</span><br><span class="line">            s2.append(huffmanCodes.get(c));</span><br><span class="line">        &#125;</span><br><span class="line">       &#x2F;&#x2F; System.out.println(s2.length());</span><br><span class="line">       &#x2F;&#x2F; System.out.println(s2.toString());</span><br><span class="line">        &#x2F;&#x2F;先计算要返回的bytes数组的长度</span><br><span class="line">        &#x2F;&#x2F;int len&#x3D;(s2.length()+7)&#x2F;8</span><br><span class="line">        int len;</span><br><span class="line">        if(s2.length()%8&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            len&#x3D;s2.length()&#x2F;8;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            len&#x3D;s2.length()&#x2F;8+1;</span><br><span class="line">        byte[] bytes&#x3D;new byte[len];</span><br><span class="line">        for (int i &#x3D; 0,index&#x3D;0; i &lt;s2.length() ; i+&#x3D;8,index++) &#123;</span><br><span class="line">            String S;</span><br><span class="line">            if(i+8&gt;s2.length())</span><br><span class="line">                S&#x3D;s2.substring(i);</span><br><span class="line">            else</span><br><span class="line">            S&#x3D;s2.substring(i,i+8);</span><br><span class="line">            bytes[index]&#x3D;(byte)Integer.parseInt(S,2);&#x2F;&#x2F;radix:2,转为二进制</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return bytes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param huffmanCodes 得到的哈弗曼编码表</span><br><span class="line">     * @param huffmanBytes 被压缩后的字节数组</span><br><span class="line">     * @return 原字符数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] decode(HashMap&lt;Byte,String&gt; huffmanCodes,byte[] huffmanBytes)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.先得到huffmanBytes对应的二进制字符串</span><br><span class="line">        StringBuilder stringBuilder&#x3D;new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;将Byte数组转成二进制字符串</span><br><span class="line">        for (int i &#x3D; 0; i &lt;huffmanBytes.length ; i++) &#123;</span><br><span class="line">            boolean flag&#x3D;(i&#x3D;&#x3D;huffmanBytes.length-1);</span><br><span class="line">            stringBuilder.append(byteToBiString(!flag,huffmanBytes[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把字符串按照指定的赫夫曼编发进行解码</span><br><span class="line">        HashMap&lt;String,Byte&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;Byte, String&gt; c : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(c.getValue(),c.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个集合，存放byte</span><br><span class="line">        List&lt;Byte&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;stringBuilder.length() ; ) &#123;</span><br><span class="line">            int count&#x3D;1;</span><br><span class="line">            boolean flag&#x3D;true;</span><br><span class="line">            Byte b&#x3D;null;</span><br><span class="line">            while(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                String key&#x3D;stringBuilder.substring(i,i+count);</span><br><span class="line">                b&#x3D;map.get(key);</span><br><span class="line">                if(b&#x3D;&#x3D;null)</span><br><span class="line">                    count++;</span><br><span class="line">                else</span><br><span class="line">                    flag&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i+&#x3D;count;</span><br><span class="line">        &#125;</span><br><span class="line">        byte b[] &#x3D; new byte[list.size()];</span><br><span class="line">        for(int i &#x3D; 0;i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param flag 看是否需要补高位，true表示需要，false表示不需要，如果是最后一个字节无需补高位</span><br><span class="line">     * @param b   传入的byte</span><br><span class="line">     * @return b对应的二进制字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToBiString(boolean flag,byte b)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;使用一个变量保存b</span><br><span class="line">        int temp&#x3D;b;</span><br><span class="line">        if(flag)</span><br><span class="line">            &#x2F;&#x2F;如果是正数，且是满8位的字节，我们需要补高位，如果是负数也无所谓结果不变。</span><br><span class="line">            temp |&#x3D;256;&#x2F;&#x2F;按位或256： 1 0000 0000 补高位</span><br><span class="line">        String str&#x3D;Integer.toBinaryString(temp);</span><br><span class="line">        if(flag)</span><br><span class="line">            return  str.substring(str.length()-8);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(temp&lt;0)</span><br><span class="line">            return str.substring(str.length()-8);</span><br><span class="line">            else</span><br><span class="line">                return str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static HashMap&lt;Byte,String&gt; getCodes(NodeChar node)</span><br><span class="line">    &#123;</span><br><span class="line">        getCodes(node,&quot;&quot;,s1);</span><br><span class="line">        return codes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param node 传入节点</span><br><span class="line">     * @param code 路径，左子节点是0，右子节点是1</span><br><span class="line">     * @param s2   拼接路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void getCodes(NodeChar node,String code,StringBuilder s2)</span><br><span class="line">    &#123;       StringBuilder s3&#x3D;new StringBuilder(s2);</span><br><span class="line">            s3.append(code);</span><br><span class="line">            if(node!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                if(node.data&#x3D;&#x3D;null)&#x2F;&#x2F;是非叶子节点</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;因为哈夫曼树的非叶子节点左右子树必不为空，所以直接递归</span><br><span class="line">                    getCodes(node.left,&quot;0&quot;,s3);</span><br><span class="line">                    getCodes(node.right,&quot;1&quot;,s3);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                   codes.put(node.data,s3.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param chars 接收的字符数组</span><br><span class="line">     * @return 存放将chars按每个字符个数转化成NodeChar的List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static List&lt;NodeChar&gt; getNodes(byte[] chars)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;NodeChar&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Byte,Integer&gt; map&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for (Byte c : chars) &#123;</span><br><span class="line">            Integer count&#x3D;map.get(c);</span><br><span class="line">            if(count&#x3D;&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(c,1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(c,count+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Byte, Integer&gt; c : map.entrySet()) &#123;</span><br><span class="line">            NodeChar node&#x3D;new NodeChar(c.getKey(),c.getValue());</span><br><span class="line">            list.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static NodeChar createHuffman(List&lt;NodeChar&gt;  nodes)</span><br><span class="line">    &#123;</span><br><span class="line">        while(nodes.size()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            NodeChar lift&#x3D;nodes.get(0);</span><br><span class="line">            NodeChar right&#x3D;nodes.get(1);</span><br><span class="line">            NodeChar parent&#x3D;new NodeChar(null,lift.weight+right.weight);</span><br><span class="line">            parent.left&#x3D;lift;</span><br><span class="line">            parent.right&#x3D;right;</span><br><span class="line">            nodes.remove(lift);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class NodeChar implements Comparable&lt;NodeChar&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Byte data;</span><br><span class="line">    int weight;</span><br><span class="line">    NodeChar left;</span><br><span class="line">    NodeChar right;</span><br><span class="line"></span><br><span class="line">    public NodeChar(Byte data, int weight) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.weight &#x3D; weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(NodeChar o) &#123;</span><br><span class="line">        return this.weight-o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;NodeChar&#123;&quot; +</span><br><span class="line">                &quot;data&#x3D;&quot; + data +</span><br><span class="line">                &quot;, weight&#x3D;&quot; + weight +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(data!&#x3D;null)</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>1.如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件  [举例压一个 .ppt]<br>2.赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件]<br>3.如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. </p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><strong>二叉排序树</strong></h2><ol>
<li>使用数组<br>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢.<br>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。</li>
<li>使用链式存储-链表不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</li>
<li>使用二叉排序树<br>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点<br>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：<br><img src="/images/58.jpg" alt=""><br><img src="/images/59.jpg" alt=""></li>
</ol>
<p>二叉排序树的添加和遍历比较简单<br>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑<br><strong>1.删除叶子节点 (比如：2, 5, 9, 12)</strong><br>思路(1) 需求先去找到要删除的结点 targetNode<br>(2) 找到 targetNode 的 父结点 parent<br>(3) 确定 targetNode 是 parent 的左子结点 还是右子结点<br>(4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null;<br><strong>2.删除只有一颗子树的节点 (比如：1)</strong><br>思路<br>(1) 需求先去找到要删除的结点 targetNode<br>(2) 找到 targetNode 的 父结点 parent<br>(3) 确定 targetNode 的子结点是左子结点还是右子结点<br>(4) targetNode 是 parent 的左子结点还是右子结点<br>(5) 如果 targetNode 有左子结点<br>5.1 如果 targetNode 是 parent 的左子结点<br>parent.left = targetNode.left;<br>5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left;<br>(6) 如果 targetNode 有右子结点 6.1 如果 targetNode 是 parent 的左子结点     parent.left = targetNode.right; 6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right<br><strong>3.删除有两颗子树的节点. (比如：7, 3，10 )</strong><br>思路<br>(1) 需求先去找到要删除的结点 targetNode<br>(2) 找到 targetNode 的 父结点 parent<br>(3) 从 targetNode 的右子树找到最小的结点<br>(4) 用一个临时变量，将 最小结点的值保存 temp = 11<br>(5) 删除该最小结点<br>(6) targetNode.value = temp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class BinarySortTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;7,3,10,12,5,1,9&#125;;</span><br><span class="line">        BinarySortTree binarySortTree&#x3D;new BinarySortTree();</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            binarySortTree.add(new NodeBS(i));</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.infixOrderln();</span><br><span class="line">        binarySortTree.add(new NodeBS(2));</span><br><span class="line">        binarySortTree.infixOrderln();</span><br><span class="line">        binarySortTree.deleteNode(2);</span><br><span class="line">        binarySortTree.deleteNode(5);</span><br><span class="line">        binarySortTree.deleteNode(9);</span><br><span class="line">        binarySortTree.deleteNode(12);</span><br><span class="line">        binarySortTree.deleteNode(7);</span><br><span class="line">        binarySortTree.deleteNode(3);</span><br><span class="line">        binarySortTree.deleteNode(10);</span><br><span class="line">        binarySortTree.deleteNode(1);</span><br><span class="line"></span><br><span class="line">        binarySortTree.infixOrderln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BinarySortTree</span><br><span class="line">&#123;</span><br><span class="line">    private NodeBS root;</span><br><span class="line">    public void add(NodeBS node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null)</span><br><span class="line">            root&#x3D;node;</span><br><span class="line">        else</span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrderln()</span><br><span class="line">    &#123;</span><br><span class="line">        this.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该二叉排序树为空不可以遍历&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        NodeBS nodeD &#x3D; root.search(value);</span><br><span class="line">        if(nodeD&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;不存在该结点&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeBS nodeF &#x3D; root.searchParent(value);</span><br><span class="line">        if(nodeF!&#x3D;null)&#x2F;&#x2F;不是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.right&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.right;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.left;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeBS min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min.value);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#x2F;&#x2F;要删除的节点是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">               root&#x3D;null;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">               root&#x3D;root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeBS min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min.value);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class NodeBS</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    NodeBS left;</span><br><span class="line">    NodeBS right;</span><br><span class="line"></span><br><span class="line">    public NodeBS(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加结点的方法</span><br><span class="line">    public  void add(NodeBS node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node&#x3D;&#x3D;null)</span><br><span class="line">            return;</span><br><span class="line">        if(node.value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left&#x3D;&#x3D;null)</span><br><span class="line">                this.left&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.left.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right&#x3D;&#x3D;null)</span><br><span class="line">                this.right&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.right.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找指定节点</span><br><span class="line">     public NodeBS search(int value)</span><br><span class="line">     &#123;</span><br><span class="line">         if(value&#x3D;&#x3D;this.value)</span><br><span class="line">             return this;</span><br><span class="line">         else if(this.left!&#x3D;null&amp;&amp;value&lt;this.value)</span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">             return this.left.search(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else if(this.right!&#x3D;null&amp;&amp;value&gt;&#x3D;this.value)</span><br><span class="line">         &#123;</span><br><span class="line">             return  this.right.search(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             return  null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;寻找指定节点的父结点</span><br><span class="line">     public NodeBS searchParent(int value)</span><br><span class="line">     &#123;</span><br><span class="line">         if((this.left!&#x3D;null&amp;&amp;this.left.value&#x3D;&#x3D;value)</span><br><span class="line">                 ||(this.right!&#x3D;null&amp;&amp;this.right.value&#x3D;&#x3D;value))</span><br><span class="line">         &#123;</span><br><span class="line">             return this;</span><br><span class="line">         &#125;</span><br><span class="line">         else if(this.left!&#x3D;null&amp;&amp;value&lt;this.value)</span><br><span class="line">         &#123;</span><br><span class="line">            return this.left.searchParent(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else  if (this.right!&#x3D;null&amp;&amp;value&gt;&#x3D;this.value)</span><br><span class="line">         &#123;</span><br><span class="line">             return this.right.searchParent(value);</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">             return null;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找该节点右子树下的最小节点,该节点必有右子树的情况下</span><br><span class="line">    public NodeBS serchMin()</span><br><span class="line">    &#123;</span><br><span class="line">        NodeBS r&#x3D;this.right;</span><br><span class="line">        while(r.left!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            r&#x3D;r.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public  void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        System.out.print(this);</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;  &quot;+value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a><strong>平衡二叉树(AVL树)</strong></h2><p><strong>看一个案例(说明二叉排序树可能的问题)</strong><br>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.<br><img src="/images/60.png" alt=""><br><strong>左边BST 存在的问题分析:</strong><br>左子树全部为空，从形式上看，更像一个单链表.<br>插入速度没有影响<br>查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢<br>解决方案-平衡二叉树(AVL) </p>
<p><strong>基本介绍</strong><br>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。<br>具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
<h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a><strong>单旋转</strong></h3><p><strong>左旋转</strong><br><img src="/images/61.png" alt=""><br>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void leftRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的左子树设置成当前节点的左子树</span><br><span class="line">        nodeAvl.left&#x3D;left;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的右子树设置成当前节点的右子树的左子树</span><br><span class="line">        nodeAvl.right&#x3D;this.right.left;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为右子节点的值</span><br><span class="line">        this.value&#x3D;this.right.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的右子树设置成右子树的右子树</span><br><span class="line">        this.right&#x3D;this.right.right;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的左子树设为新节点</span><br><span class="line">        this.left&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>右旋转</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void rightRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的右子树设置成当前节点的右子树</span><br><span class="line">        nodeAvl.right&#x3D;right;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的左子树设置成当前节点的左子树的右子树</span><br><span class="line">        nodeAvl.left&#x3D;this.left.right;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为左子节点的值</span><br><span class="line">        this.value&#x3D;this.left.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的左子树设置成左子树的左子树</span><br><span class="line">        this.left&#x3D;this.left.left;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的右子树设为新节点</span><br><span class="line">        this.right&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a><strong>双旋转</strong></h2><p><strong>由于单旋转有时候并不能解决问题，例如原先左子树高度比右子树高度高2，但右旋转之后右子树高度又比左子树高2</strong><br><strong>所以旋转完还是非平衡二叉树</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void doubleRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        if(rightHeight()-leftHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right.leftHeight()&gt;this.right.rightHeight())</span><br><span class="line">                this.right.rightRoate();</span><br><span class="line">            this.leftRoate();</span><br><span class="line">        &#125;</span><br><span class="line">        if(leftHeight()-rightHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left.rightHeight()&gt;this.left.leftHeight())</span><br><span class="line">                this.left.leftRoate();</span><br><span class="line">            this.rightRoate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>总代码(其中删除节点的方法可能出现问题，若二叉树中的重复值过多)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">package 树;</span><br><span class="line"></span><br><span class="line">public class AvlTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr1&#x3D;&#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14&#125;;</span><br><span class="line">       &#x2F;&#x2F; int[] arr&#x3D;&#123;14,13,12,11,10,9,8,7,6,5,4,3,2,1&#125;;</span><br><span class="line">       &#x2F;&#x2F; int arr[]&#x3D;&#123;10,12,8,9,7,6&#125;;</span><br><span class="line">       &#x2F;&#x2F; int arr[]&#x3D;&#123;10,11,7,6,8,9&#125;;</span><br><span class="line">        int[] arr&#x3D;new int[200];</span><br><span class="line">        for (int i &#x3D; 0; i &lt;200; i++) &#123;</span><br><span class="line">            arr[i]&#x3D;(int)(Math.random()*200);</span><br><span class="line">        &#125;</span><br><span class="line">        AvlTree avlTree&#x3D;new AvlTree();</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            avlTree.add(new NodeAvl(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;中序遍历&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class AvlTree</span><br><span class="line">&#123;</span><br><span class="line">    private NodeAvl root;</span><br><span class="line"></span><br><span class="line">    public NodeAvl getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        NodeAvl nodeD &#x3D; root.search(value);</span><br><span class="line">        deleteNode(nodeD);</span><br><span class="line">    &#125;</span><br><span class="line">    public void deleteNode(NodeAvl nodeD)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(nodeD&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;不存在该结点&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeAvl nodeF &#x3D; root.searchParent(nodeD);</span><br><span class="line">        if(nodeF!&#x3D;null)&#x2F;&#x2F;不是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.right&#x3D;null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.right;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">                if(nodeD&#x3D;&#x3D;nodeF.left)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodeF.left&#x3D;nodeD.left;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    nodeF.right&#x3D;nodeD.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeAvl min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#x2F;&#x2F;要删除的节点是根节点</span><br><span class="line">        &#123;</span><br><span class="line">            if(nodeD.left&#x3D;&#x3D;null&amp;&amp;nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;是叶子结点</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;null;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.left&#x3D;&#x3D;null)&#x2F;&#x2F;只有右子树</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeD.right&#x3D;&#x3D;null)&#x2F;&#x2F;只有左子树</span><br><span class="line">            &#123;</span><br><span class="line">                root&#x3D;root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NodeAvl min &#x3D; nodeD.serchMin();</span><br><span class="line">                int temp&#x3D;min.value;</span><br><span class="line">                deleteNode(min);</span><br><span class="line">                nodeD.value&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nodeF!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            nodeF.doubleRoate();</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.doubleRoate();</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(NodeAvl node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null)</span><br><span class="line">            root&#x3D;node;</span><br><span class="line">        else</span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrderln()</span><br><span class="line">    &#123;</span><br><span class="line">        this.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    public void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(root!&#x3D;null)</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;该二叉排序树为空不可以遍历&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class NodeAvl</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    NodeAvl left;</span><br><span class="line">    NodeAvl right;</span><br><span class="line"></span><br><span class="line">    public NodeAvl(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回以该节点为根节点的树的高度</span><br><span class="line">    public  int leftHeight()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            return this.left.height();</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public int rightHeight()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            return this.right.height();</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public int height()</span><br><span class="line">    &#123;</span><br><span class="line">        return Math.max(left&#x3D;&#x3D;null?0:left.height(),right&#x3D;&#x3D;null?0:right.height())+1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加结点的方法</span><br><span class="line">    public  void add(NodeAvl node)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node&#x3D;&#x3D;null)</span><br><span class="line">            return;</span><br><span class="line">        if(node.value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left&#x3D;&#x3D;null)</span><br><span class="line">                this.left&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.left.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right&#x3D;&#x3D;null)</span><br><span class="line">                this.right&#x3D;node;</span><br><span class="line">            else</span><br><span class="line">                this.right.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为是root调用的，所以按理来说会经过添加节点时所经过的所有节点</span><br><span class="line">        &#x2F;&#x2F;也就是说递归调用的时候就可以进行判断和调整</span><br><span class="line">        this.doubleRoate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void doubleRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        if(rightHeight()-leftHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.right.leftHeight()&gt;this.right.rightHeight())</span><br><span class="line">                this.right.rightRoate();</span><br><span class="line">            this.leftRoate();</span><br><span class="line">        &#125;</span><br><span class="line">        if(leftHeight()-rightHeight()&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(this.left.rightHeight()&gt;this.left.leftHeight())</span><br><span class="line">                this.left.leftRoate();</span><br><span class="line">            this.rightRoate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void rightRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的右子树设置成当前节点的右子树</span><br><span class="line">        nodeAvl.right&#x3D;right;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的左子树设置成当前节点的左子树的右子树</span><br><span class="line">        nodeAvl.left&#x3D;this.left.right;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为左子节点的值</span><br><span class="line">        this.value&#x3D;this.left.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的左子树设置成左子树的左子树</span><br><span class="line">        this.left&#x3D;this.left.left;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的右子树设为新节点</span><br><span class="line">        this.right&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br><span class="line">    private void leftRoate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建一个新节点，值等于当前根节点（当前节点）的值</span><br><span class="line">        NodeAvl nodeAvl&#x3D;new NodeAvl(value);</span><br><span class="line">        &#x2F;&#x2F;2.把新节点的左子树设置成当前节点的左子树</span><br><span class="line">        nodeAvl.left&#x3D;left;</span><br><span class="line">        &#x2F;&#x2F;3.把新节点的右子树设置成当前节点的右子树的左子树</span><br><span class="line">        nodeAvl.right&#x3D;this.right.left;</span><br><span class="line">        &#x2F;&#x2F;4.把当前节点的值换为右子节点的值</span><br><span class="line">        this.value&#x3D;this.right.value;</span><br><span class="line">        &#x2F;&#x2F;5.把当前节点的右子树设置成右子树的右子树</span><br><span class="line">        this.right&#x3D;this.right.right;</span><br><span class="line">        &#x2F;&#x2F;6.把当前节点的左子树设为新节点</span><br><span class="line">        this.left&#x3D;nodeAvl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找指定节点</span><br><span class="line">    public NodeAvl search(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        if(value&#x3D;&#x3D;this.value)</span><br><span class="line">            return this;</span><br><span class="line">        else if(this.left!&#x3D;null&amp;&amp;value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.right!&#x3D;null&amp;&amp;value&gt;&#x3D;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            return  this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return  null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找指定节点的父结点</span><br><span class="line">    public NodeAvl searchParent(NodeAvl NodeAvl)</span><br><span class="line">    &#123;</span><br><span class="line">        if((this.left!&#x3D;null&amp;&amp;this.left.value&#x3D;&#x3D;NodeAvl.value&amp;&amp;this.left&#x3D;&#x3D;NodeAvl)</span><br><span class="line">                ||(this.right!&#x3D;null&amp;&amp;this.right.value&#x3D;&#x3D;NodeAvl.value&amp;&amp;this.right&#x3D;&#x3D;NodeAvl))</span><br><span class="line">        &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.left!&#x3D;null&amp;&amp;NodeAvl.value&lt;&#x3D;this.value)</span><br><span class="line">        &#123;       if(this.left.searchParent(NodeAvl)!&#x3D;null)</span><br><span class="line">            return this.left.searchParent(NodeAvl);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right!&#x3D;null&amp;&amp;NodeAvl.value&gt;&#x3D;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            return this.right.searchParent(NodeAvl);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;寻找该节点右子树下的最小节点,该节点必有右子树的情况下</span><br><span class="line">    public NodeAvl serchMin()</span><br><span class="line">    &#123;</span><br><span class="line">        NodeAvl r&#x3D;this.right;</span><br><span class="line">        while(r.left!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            r&#x3D;r.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public  void infixOrder()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this.left!&#x3D;null)</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        System.out.print(this);</span><br><span class="line">        if(this.right!&#x3D;null)</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value+&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树与B树"><a href="#二叉树与B树" class="headerlink" title="二叉树与B树"></a><strong>二叉树与B树</strong></h2><h3 id="二叉树的问题分析"><a href="#二叉树的问题分析" class="headerlink" title="二叉树的问题分析"></a><strong>二叉树的问题分析</strong></h3><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树<br>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:<br>问题1：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响<br>问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</p>
<h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a><strong>多叉树</strong></h3><p>1.在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）<br>2.后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。<br>3.举例说明(下面2-3树就是一颗多叉树)<br><img src="/images/62.png" alt=""></p>
<h3 id="B树-多叉树的一种-的基本介绍"><a href="#B树-多叉树的一种-的基本介绍" class="headerlink" title="B树(多叉树的一种)的基本介绍"></a><strong>B树(多叉树的一种)的基本介绍</strong></h3><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p>
<ol>
<li>如图B树通过重新组织节点， 降低了树的高度.</li>
<li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</li>
<li>将树的度(节点的度为结点子节点的个数，树的度为最大节点度)M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中<br><img src="/images/63.png" alt=""></li>
</ol>
<p><strong>2-3树</strong><br><strong>2-3树基本介绍</strong><br>2-3树是最简单的B树结构, 具有如下特点:</p>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，且三节点本就有两个结点值.</li>
<li>2-3树是由二节点和三节点构成的树。<br><img src="/images/64.png" alt=""></li>
</ol>
<p><strong>插入规则:</strong></p>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点，左子节点小于本结点右子节点大于本结点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点，左子节点小于左节点，中子节点大于左节点小于右节点，右子节点大于右节点。</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。 </li>
<li>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</li>
</ol>
<h3 id="B树、B-树和B-树"><a href="#B树、B-树和B-树" class="headerlink" title="B树、B+树和B* 树"></a><strong>B树、B+树和B* 树</strong></h3><h4 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a><strong>B树的介绍</strong></h4><p> B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。<br>前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:<br>B树的说明:</p>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找<br><img src="/images/65.png" alt=""></li>
</ol>
<h4 id="B-树的介绍"><a href="#B-树的介绍" class="headerlink" title="B+树的介绍"></a><strong>B+树的介绍</strong></h4><p>B+树是B树的变体，也是一种多路搜索树。<strong>相当于将单链表分割检索</strong><br><strong>B+树的说明:</strong></p>
<ol>
<li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.<br><img src="/images/66.png" alt=""></li>
</ol>
<h4 id="B-树的介绍-1"><a href="#B-树的介绍-1" class="headerlink" title="B* 树的介绍"></a><strong>B* 树的介绍</strong></h4><p>B* 树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。<br>B* 树的说明:</p>
<ol>
<li>B* 树定义了非叶子结点关键字个数至少为(2/3)* M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>从第1个特点我们可以看出，B* 树分配新结点的概率比B+树要低，空间使用率更高</li>
<li>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</li>
<li>B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B* 树分配新结点的概率比B+树要低，空间使用率更高；<br><img src="/images/67.png" alt=""></li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><ol>
<li>二叉树：每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</li>
<li>B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>
<li>B+树：在B树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>
<li>B* 树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/" data-id="ckb22iug700aqzwu8fc4b888p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/04/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          动态规划
        
      </div>
    </a>
  
  
    <a href="/2020/03/02/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">分治算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>