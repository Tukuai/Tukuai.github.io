<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>垃圾回收 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="垃圾回收Garbage Collection 如何判断对象可以回收 垃圾回收算法 分代垃圾回收 垃圾回收器 垃圾回收调优  如何判断对象可以回收1.引用计数法多出一个对象引用，则引用计数加一，少一个就减一，当其引用计数变为零的时候，就可以被当为垃圾回收了。存在重要的弊端：循环引用问题。当A对象引用B对象，而B对象引用A对象，但是没有别的对象再去引用他们两，本身他们俩都不会被使用了，但是不能被垃圾回">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收">
<meta property="og:url" content="https://tukuai.github.io/2020/03/31/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="垃圾回收Garbage Collection 如何判断对象可以回收 垃圾回收算法 分代垃圾回收 垃圾回收器 垃圾回收调优  如何判断对象可以回收1.引用计数法多出一个对象引用，则引用计数加一，少一个就减一，当其引用计数变为零的时候，就可以被当为垃圾回收了。存在重要的弊端：循环引用问题。当A对象引用B对象，而B对象引用A对象，但是没有别的对象再去引用他们两，本身他们俩都不会被使用了，但是不能被垃圾回">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tukuai.github.io/images/171.png">
<meta property="og:image" content="https://tukuai.github.io/images/172.png">
<meta property="og:image" content="https://tukuai.github.io/images/173.png">
<meta property="og:image" content="https://tukuai.github.io/images/183.png">
<meta property="og:image" content="https://tukuai.github.io/images/184.png">
<meta property="og:image" content="https://tukuai.github.io/images/185.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/186.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/187.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/188.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/189.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/190.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/191.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/192.jpg">
<meta property="og:image" content="https://tukuai.github.io/images/193.png">
<meta property="og:image" content="https://tukuai.github.io/images/194.png">
<meta property="og:image" content="https://tukuai.github.io/images/195.png">
<meta property="og:image" content="https://tukuai.github.io/images/196.png">
<meta property="article:published_time" content="2020-03-31T13:48:09.000Z">
<meta property="article:modified_time" content="2020-04-15T03:12:05.686Z">
<meta property="article:author" content="Tukuai">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tukuai.github.io/images/171.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JVM-Java虚拟机/垃圾回收" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/31/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time datetime="2020-03-31T13:48:09.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      垃圾回收
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="垃圾回收Garbage-Collection"><a href="#垃圾回收Garbage-Collection" class="headerlink" title="垃圾回收Garbage Collection"></a><strong>垃圾回收Garbage Collection</strong></h1><ol>
<li>如何判断对象可以回收</li>
<li>垃圾回收算法</li>
<li>分代垃圾回收</li>
<li>垃圾回收器</li>
<li>垃圾回收调优</li>
</ol>
<h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a><strong>如何判断对象可以回收</strong></h2><p><strong>1.引用计数法</strong><br>多出一个对象引用，则引用计数加一，少一个就减一，当其引用计数变为零的时候，就可以被当为垃圾回收了。<br>存在重要的弊端：循环引用问题。<br><img src="/images/171.png" alt=""><br>当A对象引用B对象，而B对象引用A对象，但是没有别的对象再去引用他们两，本身他们俩都不会被使用了，但是不能被垃圾回收了。<br>Python使用的就是该机制，而java使用的是可达性分析算法。</p>
<p><strong>2.可达性分析算法</strong></p>
<ul>
<li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能够沿着 GC Root(根对象：可以理解为肯定不能被当成垃圾的对象)对象为起点的引用链找到该对象，找不到，表示可以回收，也就是说该对象是否被根对象直接或者间接的引用。不是的话就可以被回收了。</li>
<li>GC Root:GC Roots基本思路就是通过一系列的称为“GC Roots”的对象作为起始点， 从这些节点开始向下搜索， 搜索所走过的路径称为引用链（Reference    Chain），当一个对象到 GC Roots 没有任何引用链相连（ 用图论的话来 说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</li>
<li>哪些对象可以作为 GC Root ?<ul>
<li>使用eclipse提供的Memory Analyzer(MAT)工具</li>
<li>需要与jmap结合使用，先用terminal指令：jmap -dump:format=b,live,file=文件名  进程id</li>
<li>format=b代表二进制,live代表截取存活对象会主动使用一次垃圾回收。文件名会自动生成文件后缀为bin，如1.bin</li>
<li>再在MAT里打开bin文件，可以查看到根对象<br><img src="/images/172.png" alt=""></li>
</ul>
<ol>
<li>System Class  </li>
<li>Native Stack，操作系统方法在调用时所引用的java对象</li>
<li>Thread，而且活动线程中局部变量所引用的对象如：New ArrayList().。注意这里指的是堆内存中的对象，而不是栈帧中的引用，如List<Integer> list1=new Arraylist().其中list1为引用，而New ArrayList()为对象</li>
<li>Busy Monitor，如线程锁对象，也是不能被回收的</li>
</ol>
</li>
</ul>
<hr>
<p><strong>四种引用</strong><br><img src="/images/173.png" alt=""><br>实线代表：强引用<br>虚线代表：其他四类引用</p>
<ol>
<li>强引用<br>我们平时所用的所有引用都几乎是强引用，能根据GCROOT通过强引用找到该对象的话，该对象都是不能被回收的。<br>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
<li>软引用（SoftReference）<br>仅由软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象，即使该对象被Root对象<strong>间接</strong>引用。<br> <strong>可以配合</strong>引用队列来释放软引用自身，软引用和弱引用都可以放到引用队列中，在垃圾释放的时候较为容易找到并释放。</li>
<li>弱引用（WeakReference）<br>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象，即使该对象被Root对象<strong>间接</strong>引用。<br> <strong>可以配合</strong>引用队列来释放弱引用自身</li>
<li>虚引用（PhantomReference）<br> <strong>必须配合</strong>引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法(Unsafe freeMemory)释放<strong>直接内存</strong>。</li>
<li>终结器引用（FinalReference）<br> <strong>必须配合</strong>引用队列使用</li>
</ol>
<ul>
<li>Object父类里都有一个叫做finallize()方法，终结方法，当对象重写这个方法，并且没有强引用引用时就可以被当作垃圾回收。</li>
<li>重写终结方法的目的就是该对象在垃圾回收时被调用。靠的就是终结器引用达到这个目的</li>
<li>当没有Root对象引用该对象时，JVM就会分配终结器引用引用该对象，当垃圾回收时可以调用终结方法。</li>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的 finalize方法，<strong>第二次 GC 时才能回收被引用对象</strong></li>
<li>所以第一次GC不会回收该对象，必须等到第二次GC</li>
<li>Finalizer线程的优先级非常低，所以可能导致终结方法迟迟不能被调用，所以这个对象占用的内存也有可能迟迟不能得到释放。</li>
<li><strong>所以不推荐使用该方法</strong></li>
</ul>
<p><strong>软(弱)引用应用</strong><br>比如我们在读取图片到list集合，但是图片资源不属于核心业务资源，若使用强引用引用该图片资源，导致内存不足，这时候可以考虑软引用或者弱引用<br>区别在于：List&lt; byte[]&gt; list = new ArrayList&lt;&gt;();和List&lt;SoftReference&lt; byte[]&gt;&gt; list = new ArrayList&lt;&gt;();<br>也就是说list先引用软引用对象，软引用对象再引用该对象</p>
<p><strong>软引用实例：：</strong></p>
<pre><code>    public class Demo2_4 {
private static final int _4MB = 4 * 1024 * 1024;
public static void main(String[] args) {
    List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
    // 引用队列
     ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
    for (int i = 0; i &lt; 5; i++) {
        // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
        SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
        System.out.println(ref.get());
        list.add(ref);
        System.out.println(list.size());
    }
    // 从队列中获取无用的 软引用对象，并移除
    Reference&lt;? extends byte[]&gt; poll = queue.poll();
    while( poll != null) {
        list.remove(poll);
        poll = queue.poll();
    }
    System.out.println(&quot;===========================&quot;);
    for (SoftReference&lt;byte[]&gt; reference : list) {
        System.out.println(reference.get());
    }
}</code></pre><p><strong>弱引用实例：：</strong></p>
<pre><code>/**
 * 演示弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class Demo2_5 {
    private static final int _4MB = 4 * 1024 * 1024;
    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+&quot; &quot;);
            }
            System.out.println();
        }
        System.out.println(&quot;循环结束：&quot; + list.size());
    }
}</code></pre><hr>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a><strong>标记清除</strong></h3><p>定义： Mark Sweep<br><img src="/images/183.png" alt=""><br>清除内存的原理：找到没root引用的内存地址，将地址放入地址列表中，下次需要使用内存空间时候，可以直接将该地址当做空闲地址，覆盖掉。<br><strong>特点</strong></p>
<ul>
<li>速度较快</li>
<li>会造成内存碎片，因为将内存分为许多段，造成空间不连续，需要较大空间时，无法正常分配。</li>
</ul>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a><strong>标记整理</strong></h3><p>定义：Mark Compact<br><img src="/images/184.png" alt=""><br>将引用的的内存进行移动，使他们排列在一起。<br>特点：</p>
<ul>
<li>速度慢，因为移动地址后，引用该对象的地址都需要加以改变。</li>
<li>没有内存碎片</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a><strong>复制</strong></h3><p>定义：Copy<br>将内存划分为两个区域，一个from，一个to，to区域先不存放数据。<br>先将from区域的被引用对象标记，再紧列复制到to区域，在复制的过程中就完成了内存的整理。然后将from全部清空。然后调换from和to<br><strong>特点</strong></p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用双倍内存空间</li>
</ul>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a><strong>分代垃圾回收</strong></h3><p><strong>虚拟机不会单独采用一种算法，而是将三种算法协同使用。</strong><br><img src="/images/185.jpg" alt=""></p>
<ul>
<li>经常使用的对象存放在老年代中，而朝生夕死的对象放在新生代之中，有利于对内存更好地管理。</li>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间不足时，触发 minor gc(新生代垃圾回收)，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1，并且交换 from to的位置， minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit），因为寿命是存在对象的寿命头中，而对象头只有4个bit。</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长，因为老年代用的不是复制算法，而是标志+清除或者标志+整理。如果说老年代垃圾回收之后内存还是不够用，就会out of memory error</li>
<li>当大对象需要放入新生代，但新生代空间肯定不够的时候，会直接放入空间足够的老年代而不会触发GC，若老年代也不放不下就会先新生代垃圾回收，再FullGC，若是还不够，就会out of memory</li>
<li>次线程的out of memory不会导致主线程的终止。</li>
</ul>
<h2 id="相关-VM-参数"><a href="#相关-VM-参数" class="headerlink" title="相关 VM 参数"></a><strong>相关 VM 参数</strong></h2><pre><code>含义                     参数
堆初始大小                 -Xms
堆最大大小                 -Xmx 或 -XX:MaxHeapSize=size
新生代大小                 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )
幸存区比例（动态）         -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy
幸存区比例               -XX:SurvivorRatio=ratio
晋升阈值                 -XX:MaxTenuringThreshold=threshold
晋升详情                 -XX:+PrintTenuringDistribution
GC详情                     -XX:+PrintGCDetails -verbose:gc
FullGC 前 MinorGC         -XX:+ScavengeBeforeFullGC</code></pre><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a><strong>垃圾回收器</strong></h2><h3 id="1-串行Serial"><a href="#1-串行Serial" class="headerlink" title="1.串行Serial"></a><strong>1.串行Serial</strong></h3><p>单线程<br>堆内存较小，适合个人电脑<br><img src="/images/186.jpg" alt=""></p>
<h3 id="2-吞吐量优先Parallel：并行"><a href="#2-吞吐量优先Parallel：并行" class="headerlink" title="2.吞吐量优先Parallel：并行"></a><strong>2.吞吐量优先Parallel：并行</strong></h3><p>多线程<br>堆内存较大，多核 cpu<br>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高<br><img src="/images/187.jpg" alt=""></p>
<h3 id="3-响应时间优先concurrent：并发"><a href="#3-响应时间优先concurrent：并发" class="headerlink" title="3.响应时间优先concurrent：并发"></a><strong>3.响应时间优先concurrent：并发</strong></h3><p>多线程<br>堆内存较大，多核 cpu<br>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5<br><img src="/images/188.jpg" alt=""></p>
<h3 id="垃圾回收器参数"><a href="#垃圾回收器参数" class="headerlink" title="垃圾回收器参数"></a><strong>垃圾回收器参数</strong></h3><ol>
<li>串行<br> -XX:+UseSerialGC = Serial(复制算法) + SerialOld(标记+整理算法)。</li>
<li>吞吐量优先<br> -XX:+UseParallelGC ~ -XX:+UseParallelOldGC<br> -XX:+UseAdaptiveSizePolicy<br> -XX:GCTimeRatio=ratio<br> -XX:MaxGCPauseMillis=ms<br> -XX:ParallelGCThreads=n</li>
<li>响应时间优先CMS<br> -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld ，若老年代的并发失败，则会退化为SerialOld，进行内存碎片的整理，但这样会导致响应时间会过长。<br> -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads<br> -XX:CMSInitiatingOccupancyFraction=percent<br> -XX:+CMSScavengeBeforeRemark标记之前先进行一次新生代垃圾回收。</li>
</ol>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a><strong>G1</strong></h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><p><strong>Garbage First</strong><br>2004 论文发布<br>2009 JDK 6u14 体验<br>2012 JDK 7u4 官方支持<br>2017 JDK 9 默认</p>
<h3 id="详情参考"><a href="#详情参考" class="headerlink" title="详情参考"></a><strong>详情参考</strong></h3><p><a href="https://www.cnblogs.com/chenpt/p/9803298.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenpt/p/9803298.html</a></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的 Region</li>
<li>整体上是 标记+整理算法，两个区域之间是复制算法</li>
</ul>
<h3 id="相关JVM-参数"><a href="#相关JVM-参数" class="headerlink" title="相关JVM 参数"></a><strong>相关JVM 参数</strong></h3><p>-XX:+UseG1GC<br>-XX:G1HeapRegionSize=size<br>-XX:MaxGCPauseMillis=time</p>
<h2 id="G1的回收阶段"><a href="#G1的回收阶段" class="headerlink" title="G1的回收阶段"></a><strong>G1的回收阶段</strong></h2><ol>
<li><strong>G1垃圾回收阶段</strong><br><img src="/images/189.jpg" alt=""></li>
<li><strong>Young Collection：会STW</strong><br>E：Eden，S：Survival，O：Old<br><img src="/images/190.jpg" alt=""><br><img src="/images/191.jpg" alt=""></li>
<li><strong>Young Collection + CM(Concurrent marking)并发标记</strong></li>
</ol>
<ul>
<li>在 Young GC 时会进行 GC Root 的初始标记</li>
<li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定：-XX:InitiatingHeapOccupancyPercent=percent （默认45%）</li>
</ul>
<ol start="4">
<li><strong>Mixed Collection</strong><br>会对 E、S、O 进行全面垃圾回收，根据最大暂停时间，会有选择性的对O(垃圾最多的区)进行垃圾回收。如果暂停时间设置的较大，则会对所有O进行垃圾回收。</li>
</ol>
<ul>
<li>最终标记（Remark）会 STW，并发标记的过程中可能漏掉的垃圾。</li>
<li>拷贝存活（Evacuation）会 STW</li>
</ul>
<p>-XX:MaxGCPauseMillis=ms<br><img src="/images/192.jpg" alt=""><br>5. <strong>Full GC</strong><br><strong>SerialGC</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足发生的垃圾收集 - full gc<br><strong>ParallelGC</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足发生的垃圾收集 - full gc<br><strong>CMS</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足，并发失败以后，这时就会退化为串行收集，这时就被称为Full GC<br><strong>G1</strong><br>    * 新生代内存不足发生的垃圾收集 - minor gc<br>    * 老年代内存不足，并发标记+混合收集阶段，这两个阶段工作的过程中如果回收速度高于新的用户线程产生垃圾的速度时，还不能被称为Full GC，这时还处于并发垃圾收集的阶段。<br>    * 当垃圾回收速度跟不上垃圾产生的速度的时候，并发收集就失败了，这时就会退化为串行收集，但也是多线程，这是就被称为Full GC<br>6. Young Collection 跨代引用<br>新生代回收的跨代引用（老年代引用新生代）问题，在对新生代进行垃圾回收的过程中，需要寻找跟对象，跟对象有一部分是来自于老年代。老年代通常的存活对象非常多，如果遍历整个老年代去找跟对象，耗费的时间会非常多，所以就使用了卡(card)表的技术,将老年代的区域再进行细分，分成一个个card，每个card大约是512K，如果老年代其中有一个对象引用了新生代的对象，那么就把这个card标记为脏卡，将来不用去找整个老年代，而是只需要去关注脏卡的区域。减少搜索范围。<br><img src="/images/193.png" alt=""></p>
<ul>
<li>卡表与 Remembered Set</li>
<li>在引用变更时通过 post-write barrier + dirty card queue </li>
<li>concurrent refinement threads 更新 Remembered Set<br><img src="/images/194.png" alt=""></li>
</ul>
<ol start="7">
<li>Remark(重标记阶段)</li>
</ol>
<ul>
<li>因为并发标记过程中，也可能用户线程对处理中的对象进行修改，若第一次该对象被判为垃圾，但之后该对象又被其他对象所引用，则就不能被认为是垃圾被回收，需要进行remark。</li>
<li>当对象的引用发生改变的时候就对该对象进行写屏障pre-write barrier，将该对象加入到一个队列satb_mark_queue之中，当并发标记结束之后，重新标记的线程就会对该队列进行重新检查。<br>pre-write barrier + satb_mark_queue</li>
</ul>
<ol start="8">
<li>JDK 8u20 字符串去重</li>
</ol>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li>
</ul>
<p>-XX:+UseStringDeduplication</p>
<ul>
<li>1.8的String底层是char[]</li>
<li>将所有新分配的字符串放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有字符串重复</li>
<li>如果它们值一样，让它们引用同一个 char[]</li>
<li>注意，与 String.intern() 不一样<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>而字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<ol start="9">
<li>JDK 8u40 并发标记类卸载<br>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有<br>卸载类的条件：<ul>
<li>类的实例都被回收掉</li>
<li>类中的类加载器都不再被使用</li>
</ul>
</li>
</ol>
<p>-XX:+ClassUnloadingWithConcurrentMark 默认启用<br>String s1 = new String(“hello”); // char[]{‘h’,’e’,’l’,’l’,’o’} String s2 = new String(“hello”); // char[]{‘h’,’e’,’l’,’l’,’o’}<br>10. JDK 8u60 回收巨型对象<br><img src="/images/195.png" alt=""></p>
<ul>
<li>一个对象大于 region 的一半时，称之为巨型对象</li>
<li>G1 不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<ol start="11">
<li>JDK 9 并发标记起始时间的调整<br>并发标记必须在堆空间占满前完成，否则退化为 FullGC<br>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent<br>JDK 9 可以动态调整</li>
</ol>
<p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值<br>进行数据采样并动态调整<br>总会添加一个安全的空档空间<br>12. JDK 9 更高效的回收<br>250+增强<br>180+bug修复<br><a href="https://docs.oracle.com/en/java/javase/12/gctuning" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/gctuning</a></p>
<h2 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a><strong>垃圾回收调优</strong></h2><p>-XX:+PrintFlagsFinal,可以查看虚拟机参数<br>-XX:+PrintFlagsFinal -version | findstr “GC”,查看跟GC相关的参数<br><strong>预备知识</strong></p>
<ul>
<li>掌握 GC 相关的 VM 参数，会基本的空间调整</li>
<li>掌握相关工具</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li>
</ul>
<h3 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a><strong>调优领域</strong></h3><ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a><strong>确定目标</strong></h3><p>【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<ul>
<li>低延迟:CMS，G1，ZGC(JDK12)</li>
<li>高吞吐量:ParallelGC</li>
<li>Zing:对外宣称零停顿</li>
</ul>
<h3 id="最快的-GC答案是不发生-GC"><a href="#最快的-GC答案是不发生-GC" class="headerlink" title="最快的 GC答案是不发生 GC"></a><strong>最快的 GC答案是不发生 GC</strong></h3><p>查看 FullGC 前后的内存占用，考虑下面几个问题</p>
<ul>
<li>数据是不是太多？<br>resultSet = statement.executeQuery(“select * from 大表 limit n”)</li>
<li>数据表示是否太臃肿？<br>对象图<br>对象大小，Integer 24 int 4</li>
<li>是否存在内存泄漏？</li>
<li><em>解决方法*</em><ul>
<li>static Map map =</li>
<li>软弱引用</li>
<li>第三方缓存实现</li>
</ul>
</li>
</ul>
<h3 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a><strong>新生代调优</strong></h3><p><strong>新生代的特点</strong></p>
<ul>
<li>所有的 new 操作的内存分配非常廉价</li>
<li>每个线程都会在伊甸园中分配私有的区域：TLAB thread-local allocation buffer</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full GC</li>
<li><em>新生代的调优方式*</em></li>
</ul>
<ol>
<li>加大新生代的内存</li>
</ol>
<p><strong>越大越好吗？</strong><br>不是，因为新生代的空间大了，则老年代的空间就会变小，则容易触发Full GC<br>-Xmn 设置新生代的初始和最大值</p>
<ul>
<li>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery).GC is performed in this region more often than in other regions. </li>
<li><strong>If the size for the young generation is too small, then a lot of minor garbage collections are performed.</strong> </li>
<li><strong>If the size is too large, then only full garbage collections are performed, which can take a long time to complete.</strong></li>
<li>Oracle recommends that you keep the size for the young generation <strong>greater than  25% and less than 50%</strong> of the overall heap size.</li>
</ul>
<p><strong>多大算合适?</strong></p>
<ul>
<li>新生代能容纳所有【并发量 * (请求-响应)】的数据</li>
<li>幸存区大到能保留【当前活跃对象+需要晋升对象】，如果幸存区较小，则可能因空间不足而把短时间存活的对象放入老年代。</li>
<li>晋升阈值配置得当，让长时间存活对象尽快晋升<ul>
<li>-XX:MaxTenuringThreshold=threshold ，调整最大晋升阈值</li>
<li>-XX:+PrintTenuringDistribution ，打印晋升的详细细节。<pre><code> Desired survivor size 48286924 bytes, new threshold 10 (max 10) 
- age 1: 28992024 bytes, 28992024 total 
- age 2: 1366864 bytes, 30358888 total 
- age 3: 1425912 bytes, 31784800 total ...</code></pre></li>
</ul>
</li>
</ul>
<h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a><strong>老年代调优</strong></h3><p>以 CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>在CMS执行的过程中，用户线程也能够并发的执行，如果用户线程产生的新的垃圾(浮动垃圾)，而再次导致内存不足，那么就会并发失败，退化为SerialOld，使用Full GC</li>
<li>先尝试不做调优，如果没有 Full GC 那么说明老年代很充裕，否则先尝试调优新生代。一般不管有没有Full GC都应该先调优新生代。<br>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</li>
</ul>
<p>-XX:CMSInitiatingOccupancyFraction=percent，控制老年代的空间占用百分之多少的时候，就进行CMS的垃圾回收，值越低触发时间就越早。一般设置为75% - 80%，<br>预留一部分空间给浮动垃圾。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h2><p><strong>案例1 Full GC 和 Minor GC频繁</strong><br>新生代空间较小<br>GC频繁说明空间紧张，当业务高峰期来了大量的对象被创建，很快就将新生代空间塞满，幸存区空间紧张，对象的晋升阈值就会变小，导致生存周期较短的对象，大量晋升到老年代，进一步触发Full GC。</p>
<p><strong>案例2 请求高峰期发生 Full GC，单次暂停时间特别长(CMS)</strong><br><img src="/images/196.png" alt=""><br>CMS耗费时间较长的阶段为重新标记。重新标记：扫描整个堆内存。若业务高峰的时候，新生代对象个数比较多，那么标记时间就会比较多，因为需要找其引用<br>解决方法：在重新标记之前，先进行一次垃圾回收<br>-XX:+CMSScavengeBeforeRemark标记之前先进行一次新生代垃圾回收。</p>
<p><strong>案例3 老年代充裕情况下，发生 Full GC(CMS jdk1.7)</strong><br>1.7采用的是永久代作为方法区的实现，而1.8采用的是元空间为方法区的实现<br>1.7及以前由于永久代的内存不足，也会触发Full GC</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/03/31/JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="ckb22iudq001vzwu8bu26ea1z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/31/LeetCode/%E5%89%91%E6%8C%87-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          剑指-青蛙跳台
        
      </div>
    </a>
  
  
    <a href="/2020/03/31/Web/Redis/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Redis</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>