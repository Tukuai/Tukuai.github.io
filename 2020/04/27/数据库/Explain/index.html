<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Explain | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="所使用的数据库CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));  CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));  CREATE TABLE">
<meta property="og:type" content="article">
<meta property="og:title" content="Explain">
<meta property="og:url" content="https://tukuai.github.io/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Explain/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="所使用的数据库CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));  CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id));  CREATE TABLE">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-27T01:06:36.000Z">
<meta property="article:modified_time" content="2020-04-28T02:42:10.894Z">
<meta property="article:author" content="Tukuai">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数据库/Explain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Explain/" class="article-date">
  <time datetime="2020-04-27T01:06:36.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Explain
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="所使用的数据库"><a href="#所使用的数据库" class="headerlink" title="所使用的数据库"></a><strong>所使用的数据库</strong></h2><pre><code>CREATE TABLE t1(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
CREATE TABLE t2(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
CREATE TABLE t3(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
CREATE TABLE t4(id INT(10) AUTO_INCREMENT,content VARCHAR(100) NULL , PRIMARY KEY (id)); 
INSERT INTO t1(content) VALUES(CONCAT(&apos;t1_&apos;,FLOOR(1+RAND() * 1000))); 
INSERT INTO t2(content) VALUES(CONCAT(&apos;t2_&apos;,FLOOR(1+RAND() * 1000))); 
INSERT INTO t3(content) VALUES(CONCAT(&apos;t3_&apos;,FLOOR(1+RAND() * 1000))); 
INSERT INTO t4(content) VALUES(CONCAT(&apos;t4_&apos;,FLOOR(1+RAND() * 1000)));</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分 析你的查询语句或是表结构的性能瓶颈。<br>通过 explain 我们可以知道以下信息：表的读取顺序，数据读取操作的类型，哪些索引可以使用，哪些索引实际使用了，表之间的引用，每张表有多少行被优化器查询等信息。<br>用法： Explain+SQL 语句。<br>Explain 执行后返回的信息：</p>
<pre><code>mysql&gt; explain select * from t1;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+</code></pre><p><strong>explain 有两个变种：</strong></p>
<p>1）explain extended：会在 explain  的基础上额外提供一些查询优化的信息。<br>紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<pre><code>mysql&gt; explain extended select * from t1,t2,t3;
+----+-------------+-------+------+---------------+------+---------+------+------+----------+-------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra             |
+----+-------------+-------+------+---------------+------+---------+------+------+----------+-------------------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 |                   |
|  1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using join buffer |
|  1 | SIMPLE      | t3    | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using join buffer |
+----+-------------+-------+------+---------------+------+---------+------+------+----------+-------------------+
3 rows in set, 1 warning (0.00 sec)
mysql&gt; show warnings
    -&gt; ;
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                                                                                                                                                                       |
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Note  | 1003 | select `db01`.`t1`.`id` AS `id`,`db01`.`t1`.`content` AS `content`,`db01`.`t2`.`id` AS `id`,`db01`.`t2`.`content` AS `content`,`db01`.`t3`.`id` AS `id`,`db01`.`t3`.`content` AS `content` from `db01`.`t1` join `db01`.`t2` join `db01`.`t3` |
+-------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</code></pre><p>2）explain partitions：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h1 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a><strong>explain中的列</strong></h1><h2 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a><strong>1.id</strong></h2><p>select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序。</p>
<p>1.id 相同，执行顺序由上至下 </p>
<pre><code>mysql&gt; explain select * from t1,t2,t3 where t1.id=t2.id and t2.id=t3.id;
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
|  1 | SIMPLE      | t1    | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    1 |       |
|  1 | SIMPLE      | t2    | eq_ref | PRIMARY       | PRIMARY | 4       | db01.t1.id |    1 |       |
|  1 | SIMPLE      | t3    | eq_ref | PRIMARY       | PRIMARY | 4       | db01.t1.id |    1 |       |
+----+-------------+-------+--------+---------------+---------+---------+------------+------+-------+
3 rows in set (0.10 sec)</code></pre><p>2.id 不同，id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行 </p>
<pre><code>mysql&gt; EXPLAIN SELECT t1.id FROM t1 WHERE t1.id IN
    -&gt;          (SELECT t2.id FROM t2 WHERE t2.id IN
    -&gt;                  (SELECT t3.id From t3 where t3.content = &apos;&apos;)
    -&gt; );
+----+--------------------+-------+-----------------+---------------+---------+---------+------+------+--------------------------+
| id | select_type        | table | type            | possible_keys | key     | key_len | ref  | rows | Extra                    |
+----+--------------------+-------+-----------------+---------------+---------+---------+------+------+--------------------------+
|  1 | PRIMARY            | t1    | index           | NULL          | PRIMARY | 4       | NULL |    1 | Using where; Using index |
|  2 | DEPENDENT SUBQUERY | t2    | unique_subquery | PRIMARY       | PRIMARY | 4       | func |    1 | Using index; Using where |
|  3 | DEPENDENT SUBQUERY | t3    | unique_subquery | PRIMARY       | PRIMARY | 4       | func |    1 | Using where              |
+----+--------------------+-------+-----------------+---------------+---------+---------+------+------+--------------------------+</code></pre><p>3.有相同也有不同<br>id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行衍生 = DERIVED<br>关注点：id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。</p>
<h2 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2.select_type"></a><strong>2.select_type</strong></h2><p>select_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。 </p>
<table>
<thead>
<tr>
<th>select_type 属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 select 查询,查询中不包含子查询或者 UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里。</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td>DEPEDENT SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询,子查询基于外层</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>无法使用缓存的子查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<p>1) simple：简单查询。查询不包含子查询和union</p>
<pre><code>mysql&gt; explain select * from film where id = 2;
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | film  | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</code></pre><p>2）primary：复杂查询中最外层的 select</p>
<p>3）subquery：包含在 select 中的子查询（不在 from 子句中）</p>
<p>4）derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p>
<p>用这个例子来了解 primary、subquery 和 derived 类型</p>
<pre><code>mysql&gt; explain select (select 1 from t1 where id=1) from (select * from t2 where id=1 ) der;
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+
|  1 | PRIMARY     | &lt;derived3&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 |             |
|  3 | DERIVED     | t2         | const  | PRIMARY       | PRIMARY | 4       |       |    1 |             |
|  2 | SUBQUERY    | t1         | const  | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</code></pre><p>5）union：在 union 中的第二个和随后的 select</p>
<p>6）union result：从 union 临时表检索结果的 select</p>
<h2 id="3-table列"><a href="#3-table列" class="headerlink" title="3.table列"></a><strong>3.table列</strong></h2><p>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 &lt; derivenN&gt; 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为 &lt; union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<h2 id="type列"><a href="#type列" class="headerlink" title="type列"></a><strong>type列</strong></h2><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。</p>
<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL<br><strong>使用的数据库</strong></p>
<pre><code>CREATE TABLE actor (
  id int(11) NOT NULL,
  name varchar(45) DEFAULT NULL,
  update_time datetime DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO actor (id, name, update_time) VALUES (1,&apos;a&apos;,&apos;2017-12-22 15:27:18&apos;), (2,&apos;b&apos;,&apos;2017-12-22 15:27:18&apos;), (3,&apos;c&apos;,&apos;2017-12-22 15:27:18&apos;);

CREATE TABLE film (
  id int(11) NOT NULL AUTO_INCREMENT,
  name varchar(10) DEFAULT NULL,
  PRIMARY KEY (id),
  KEY idx_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO film (id, name) VALUES (3,&apos;film0&apos;),(1,&apos;film1&apos;),(2,&apos;film2&apos;);

CREATE TABLE film_actor (
  id int(11) NOT NULL,
  film_id int(11) NOT NULL,
  actor_id int(11) NOT NULL,
  PRIMARY KEY (id),
  KEY idx_film_actor_id (film_id,actor_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO film_actor (id, film_id, actor_id) VALUES (1,1,1),(2,1,2),(3,2,1);</code></pre><p><strong>NULL：</strong>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p>
<pre><code>mysql&gt; explain select min(id) from film;
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                        |
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Select tables optimized away |
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</code></pre><p><strong>const, system：</strong>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。<br>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p>
<pre><code>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;
+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 |   100.00 | NULL  |
|  2 | DERIVED     | film       | const  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+
mysql&gt; show warnings;
+-------+------+---------------------------------------------------------------+
| Level | Code | Message                                                       |
+-------+------+---------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select &apos;1&apos; AS `id`,&apos;film1&apos; AS `name` from dual |
+-------+------+---------------------------------------------------------------+</code></pre><p><strong>eq_ref：</strong>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。<br>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<pre><code>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+
| id | select_type | table      | type   | possible_keys | key               | key_len | ref                     | rows | Extra       |
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+
|  1 | SIMPLE      | film_actor | index  | NULL          | idx_film_actor_id | 8       | NULL                    |    3 | Using index |
|  1 | SIMPLE      | film       | eq_ref | PRIMARY       | PRIMARY           | 4       | test.film_actor.film_id |    1 | NULL        |
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</code></pre><p><strong>ref：</strong>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<p>1.简单 select 查询，name是普通索引（非唯一索引）</p>
<pre><code>mysql&gt; explain select * from film where name = &quot;film1&quot;;
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | film  | ref  | idx_name      | idx_name | 33      | const |    1 | Using where; Using index |
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</code></pre><p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。<br>mysql&gt; explain select * from film left join film_actor on film.id = film_actor.film_id;</p>
<pre><code>+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+
| id | select_type | table      | type  | possible_keys     | key               | key_len | ref          | rows | Extra       |
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+
|  1 | SIMPLE      | film       | index | NULL              | idx_name          | 33      | NULL         |    3 | Using index |
|  1 | SIMPLE      | film_actor | ref   | idx_film_actor_id | idx_film_actor_id | 4       | test.film.id |    1 | Using index |
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</code></pre><p><strong>ref_or_null：</strong>类似ref，但是可以搜索值为NULL的行。</p>
<pre><code>mysql&gt; explain select * from film where name = &quot;film1&quot; or name is null;
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table | type        | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | film  | ref_or_null | idx_name      | idx_name | 33      | const |    2 | Using where; Using index |
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</code></pre><p><strong>index_merge：</strong>表示使用了索引合并的优化方法。 </p>
<p><strong>range：</strong>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<pre><code>mysql&gt; explain select * from actor where id &gt; 1;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | actor | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</code></pre><p><strong>index：</strong>和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。</p>
<pre><code>mysql&gt; explain select count(*) from film;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre><p><strong>ALL：</strong>即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p>
<pre><code>mysql&gt; explain select * from actor;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+</code></pre><h2 id="5-possible-keys列"><a href="#5-possible-keys列" class="headerlink" title="5.possible_keys列"></a><strong>5.possible_keys列</strong></h2><p>这一列显示查询可能使用哪些索引来查找。 </p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </p>
<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
<h2 id="6-key列"><a href="#6-key列" class="headerlink" title="6.key列"></a><strong>6.key列</strong></h2><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。</p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
<h2 id="7-key-len列"><a href="#7-key-len列" class="headerlink" title="7.key_len列"></a><strong>7.key_len列</strong></h2><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>
<p>mysql&gt; explain select * from film_actor where film_id = 2;<br>+—-+————-+————+——+——————-+——————-+———+——-+——+————-+<br>| id | select_type | table      | type | possible_keys     | key               | key_len | ref   | rows | Extra       |<br>+—-+————-+————+——+——————-+——————-+———+——-+——+————-+<br>|  1 | SIMPLE      | film_actor | ref  | idx_film_actor_id | idx_film_actor_id | 4       | const |    1 | Using index |<br>+—-+————-+————+——+——————-+——————-+———+——-+——+————-+</p>
<p>key_len计算规则如下：</p>
<pre><code>字符串
    char(n)：n字节长度
    varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2
数值类型
    tinyint：1字节
    smallint：2字节
    int：4字节
    bigint：8字节　　
时间类型　
    date：3字节
    timestamp：4字节
    datetime：8字节
如果字段允许为 NULL，需要1字节记录是否为 NULL</code></pre><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<h2 id="8-ref列"><a href="#8-ref列" class="headerlink" title="8.ref列"></a><strong>8.ref列</strong></h2><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>
<h2 id="9-rows列"><a href="#9-rows列" class="headerlink" title="9.rows列"></a><strong>9.rows列</strong></h2><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。越少越好！</p>
<h2 id="10-Extra列"><a href="#10-Extra列" class="headerlink" title="10.Extra列"></a><strong>10.Extra列</strong></h2><p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>distinct: 一旦mysql找到了与行相联合匹配的行，就不再搜索了</p>
<p>Using index：代表表示相应的 select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！ 如果同时出现 using where，表明索引被用来执行索引键值的查找;如果没有同时出现 using where，表明索引只是 用来读取数据而非利用索引执行查找。 利用索引进行了排序或分组。是性能高的表现。</p>
<p>Using where：表明使用了 where 过滤</p>
<p>Using temporary：使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<p>1.actor.name没有索引，此时创建了张临时表来distinct</p>
<pre><code>mysql&gt; explain select distinct name from actor;
+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra           |
+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using temporary |
+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</code></pre><p>2.film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</p>
<pre><code>mysql&gt; explain select distinct name from film;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | idx_name      | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre><p>Using filesort：mysql 会对结果使用一个外部索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<p>1.actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</p>
<pre><code>mysql&gt; explain select * from actor order by name;
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using filesort |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</code></pre><p>2.film.name建立了idx_name索引,此时查询时extra是using index</p>
<pre><code>mysql&gt; explain select * from film order by name;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Explain/" data-id="ckb22iufn008mzwu800ygac9m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          常见的索引失效
        
      </div>
    </a>
  
  
    <a href="/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Mysql索引</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>