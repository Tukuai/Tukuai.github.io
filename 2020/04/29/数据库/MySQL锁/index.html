<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Mysql锁 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Mysql锁的分类加锁机制：  乐观锁：先修改，保存时判断是否被更新过，应用级别 悲观锁：先获取锁，再操作修改，数据库级别  锁粒度：  表级锁：开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。 页级锁：BDB存储引擎 行级锁：Innodb存储引擎，默认选项  兼容性：  S锁，也叫做读锁、共享锁，对应于我们常用的 select * from users where id &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql锁">
<meta property="og:url" content="https://tukuai.github.io/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Mysql锁的分类加锁机制：  乐观锁：先修改，保存时判断是否被更新过，应用级别 悲观锁：先获取锁，再操作修改，数据库级别  锁粒度：  表级锁：开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。 页级锁：BDB存储引擎 行级锁：Innodb存储引擎，默认选项  兼容性：  S锁，也叫做读锁、共享锁，对应于我们常用的 select * from users where id &#x3D;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tukuai.github.io/images/257.png">
<meta property="og:image" content="https://tukuai.github.io/images/259.png">
<meta property="og:image" content="https://tukuai.github.io/images/260.png">
<meta property="og:image" content="https://tukuai.github.io/images/261.png">
<meta property="og:image" content="https://tukuai.github.io/images/262.png">
<meta property="og:image" content="https://tukuai.github.io/images/263.png">
<meta property="og:image" content="https://tukuai.github.io/images/264.png">
<meta property="og:image" content="https://tukuai.github.io/images/259.png">
<meta property="article:published_time" content="2020-04-29T06:24:20.000Z">
<meta property="article:modified_time" content="2020-04-29T15:18:25.692Z">
<meta property="article:author" content="Tukuai">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tukuai.github.io/images/257.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数据库/MySQL锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/" class="article-date">
  <time datetime="2020-04-29T06:24:20.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Mysql锁
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mysql锁的分类"><a href="#Mysql锁的分类" class="headerlink" title="Mysql锁的分类"></a><strong>Mysql锁的分类</strong></h2><p><img src="/images/257.png" alt=""><br><strong>加锁机制：</strong></p>
<ul>
<li>乐观锁：先修改，保存时判断是否被更新过，应用级别</li>
<li>悲观锁：先获取锁，再操作修改，数据库级别</li>
</ul>
<p><strong>锁粒度：</strong></p>
<ul>
<li>表级锁：开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。</li>
<li>页级锁：BDB存储引擎</li>
<li>行级锁：Innodb存储引擎，默认选项</li>
</ul>
<p><strong>兼容性：</strong></p>
<ul>
<li>S锁，也叫做读锁、共享锁，对应于我们常用的 select * from users where id =1 lock in share mode</li>
<li>X锁，也叫做写锁、排它锁、独占锁、互斥锁，对应对于select * from users where id =1 for update<br>下面这个表格是锁冲突矩阵，可以看到只有读锁和读锁之间兼容的，写锁和读锁、写锁都是冲突的。<br><img src="/images/259.png" alt=""><br>冲突的时候会阻塞当前会话，直到拿到锁或者超时<br>这里要提到的一点是，S锁 和 X锁是可以是表锁，也可以是行锁</li>
</ul>
<p><strong>锁模式分类</strong></p>
<ul>
<li>记录锁：单行记录上的锁，行锁是加在索引上的。</li>
<li>间隙锁(gap锁)：锁定记录之间的范围，但不包含记录本身。</li>
<li>间隙锁(Next Key Lock): 记录锁+ 间隙锁，锁定一个范围，包含记录本身。</li>
<li>意向锁( Intention Locks )<ul>
<li>IS: 意向共享锁</li>
<li>IX: 意向排他锁<br>  InnoDB为了支持多粒度(表锁与行锁)的锁并存，引入意向锁。意向锁是表级锁，<br>  事务在请求某一行的S锁和X锁前，需要先获得对应表的IS、IX锁。<br>  意向锁产生的主要目的是为了处理行锁和表锁之间的冲突，用于表明“某个事务正在某一行上持有了锁，或者准备去持有锁”。比如，表中的某一行上加了X锁，就不能对这张表加X锁。<br>  如果不在表上加意向锁，对表加锁的时候，都要去检查表中的某一行上是否加有行锁，多麻烦。         </li>
</ul>
</li>
<li>插入意向锁（Insert Intention Lock）<br>Gap Lock中存在一种插入意向锁，在insert操作时产生。<br>有两个作用：<ul>
<li>和next-key互斥，阻塞next-key 锁，防止插入数据，这样就不会幻读。</li>
<li>插入意向锁互相是兼容的，允许相同间隙、不同数据的并发插入</li>
</ul>
</li>
</ul>
<h2 id="加锁的sql语法"><a href="#加锁的sql语法" class="headerlink" title="加锁的sql语法"></a><strong>加锁的sql语法</strong></h2><p>后面会有多个SQL语句，先说明一下表结构</p>
<pre><code>CREATE TABLE user (
id int(11) unsigned NOT NULL AUTO_INCREMENT,
id_no varchar(255) DEFAULT NULL COMMENT &apos;身份证号&apos;,
name varchar(255) DEFAULT NULL COMMENT &apos;姓名&apos;,
mobile varchar(255) DEFAULT NULL COMMENT &apos;手机号&apos;,
age int(11) DEFAULT NULL COMMENT &apos;年龄&apos;,
address varchar(255) DEFAULT NULL COMMENT &apos;地址&apos;,
PRIMARY KEY (id),
UNIQUE KEY uniq_id_no (id_no),
KEY idx_name (name)
) ENGINE=InnoDB AUTO_INCREMENT=10002 DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;;</code></pre><p>这里有一个user表，5个字段，其中id是主键，id_no是身份证号，加了唯一索引，name是用户姓名，可以重复的，加了普通索引，手机号、年龄、地址都没有索引。</p>
<p><strong>1.普通select</strong></p>
<pre><code>select ***** from user where id =1;
begin;
select ***** from user where id =1;
commit:</code></pre><p>普通的select 语句是不加锁的。select包裹在事务中，同样也是不加锁的。where后面的条件不管多少，普通的select是不加锁的。</p>
<p><strong>2.显式加锁</strong></p>
<pre><code>select ***** from user where id =1 lock in share mode;
select ***** from user where id =1 for update;</code></pre><p>显式指出要加什么样的锁。上面一个加的是共享锁，下面的是互斥锁。<br>这里需要强调的一点，需要明确在事务中是用这些锁，不在事务中是没有意义的。</p>
<p><strong>3.隐式加锁</strong></p>
<pre><code>update user set address &apos;北京&apos; where id=1;
delete from user where id=1;</code></pre><p>update和delete也会对查询出的记录加X锁，隐式加互斥锁。加锁类型和for update 类似<br>后面只按照显式加锁的select for update 举例子，更新和删除的加锁方式是一样的。</p>
<p><strong>4.按索引类型</strong></p>
<pre><code>select ***** from user where id =1 for update;
select ***** from user where id_no =&apos;a22&apos; for update;
select ***** from user where name =&apos;王二&apos; for update;
select ***** from user where address =&apos;杭州&apos; for update;</code></pre><p>四条SQL，区别在于where条件的过滤列，分别是主键、唯一索引、普通索引、无索引。<br><img src="/images/260.png" alt=""> </p>
<p><strong>5.记录不存在的情况</strong></p>
<p>前面几个例子中，都是可以查到结果的。如果对应记录不存在会怎样？答案是锁住间隙，不允许插入。mysql要保证没有其他人可以插入，所以锁住间隙。</p>
<p><strong>6.普通 insert 语句</strong></p>
<p>在插入之前，会先在插入记录所在的间隙加上一个插入意向锁。</p>
<p>insert会对插入成功的行加上排它锁，这个排它锁是个记录锁，而非next-key锁（当然更不是gap锁了），不会阻止其他并发的事务往这条记录之前插入 。</p>
<h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a><strong>死锁的概念</strong></h2><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>
<p>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</p>
<p>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。<br><strong>产生死锁的四个必要条件：</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><strong>举个例子</strong></p>
<pre><code>mysql&gt; SELECT * FROM test;
+----+------+
| id | name |
+----+------+
|  1 | 1    |
|  5 | 5    |
| 10 | 10   |
| 15 | 15   |
| 20 | 20   |
| 25 | 25   |
+----+------+
6 rows in set (0.00 sec)</code></pre><p>当数据库的隔离级别为Repeatable Read或Serializable时,我们来看这样的两个并发事务（场景一）：<br><img src="/images/261.png" alt=""></p>
<p>上面两个并发事务一定会发生死锁（这里之所以限定RR和Serializable两个隔离级别，是因为只有这两个级别下才会有间隙锁/临键锁，而这是导致死锁的根本原因，后面会详细分析）。</p>
<p>我们再来看另外一个并发场景（场景二）：<br><img src="/images/262.png" alt=""></p>
<p>在这个并发场景下，两个事务均能成功提交，而不会有死锁。</p>
<p>在上面的示例中，我们发现，select … for update虽然可以用于解决数据库的并发操作，但在实际项目中却不建议使用，原因是当查询条件对应的记录不存在时，很容易造成死锁。分析可得是 间隙锁/临键锁。</p>
<h1 id="锁分类详解"><a href="#锁分类详解" class="headerlink" title="锁分类详解"></a><strong>锁分类详解</strong></h1><h2 id="1-锁粒度分类"><a href="#1-锁粒度分类" class="headerlink" title="1.锁粒度分类"></a><strong>1.锁粒度分类</strong></h2><p><strong>行锁</strong></p>
<ul>
<li><p>行锁一定是作用在索引上的。</p>
</li>
<li><p>行级锁定（row-level）：开销大，加锁慢；会出现死锁；</p>
</li>
<li><p>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p>由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p>
</li>
<li><p>行级锁只在存储引擎层实现，而MySQL服务器层没有实现，服务器层完全不了解存储引擎中的锁实现。</p>
</li>
<li><p>缺陷：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p>
</li>
<li><p>总结：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。</p>
</li>
</ul>
<p><strong>页级锁定(page-level)</strong></p>
<ul>
<li><p>(MySQL特有)开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
<li><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。</p>
</li>
<li><p>页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。</p>
</li>
<li><p>缺陷：页级锁定和行级锁定一样，会发生死锁。</p>
</li>
</ul>
<p><strong>表级锁定(table-level)</strong></p>
<ul>
<li><p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
</li>
<li><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。</p>
</li>
<li><p>该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。</p>
</li>
<li><p>所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p>
</li>
<li><p>缺陷：锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。</p>
</li>
</ul>
<h2 id="2-兼容性分类"><a href="#2-兼容性分类" class="headerlink" title="2.兼容性分类"></a><strong>2.兼容性分类</strong></h2><p><strong>共享锁：</strong>（又称读取，S锁）：会阻塞其他事务修改表数据。可以读。<br>若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能X锁，直到T释放A上的锁。这就保证了其他事务可以读A，但在T释放S锁之前不能对A做任何修改。<br>select * from users where id =1 lock in share mode</p>
<p><strong>排他锁：</strong>（又称写锁，X锁）:会阻塞其他事务读和写。<br>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。<br>select * from users where id =1 for update</p>
<h2 id="3-锁模式分类"><a href="#3-锁模式分类" class="headerlink" title="3.锁模式分类"></a><strong>3.锁模式分类</strong></h2><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a><strong>记录锁</strong></h3><p>记录锁存在于包括主键索引在内的唯一索引中，锁定单条索引记录<br>对单条索引记录进行加锁，锁住的是索引记录而非记录本身，即使表中没有任何索引，MySQL会自动创建一个隐式的row_id作为聚集索引来进行加锁。<br>加锁列必须为唯一索引列或主键列，否则上述语句加的锁就会变成临键锁。<br>同时查询语句必须为精准匹配（=），不能为 &gt;、&lt;、like等，否则也会退化成临键锁</p>
<pre><code>-- id 列为主键列或唯一索引列
SELECT * FROM table WHERE id = 1 FOR UPDATE;　
在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：
UPDATE SET age = 50 WHERE id = 1;　
id 为 1 的记录行会被锁住。</code></pre><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a><strong>间隙锁</strong></h3><p>间隙锁基于下面将会提到的Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。<br>间隙锁存在于非唯一索引中，锁定开区间范围内的一段间隔<br>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”，InnoDB<strong>也</strong>会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁锁。<br><strong>间隙锁的产生</strong></p>
<p>上面的文字很抽象，现在举个栗子，介绍间隙锁是怎么产生的：</p>
<p>假设有以下表t_student：（其中id为PK，name为非唯一索引）<br><img src="/images/263.png" alt=""> </p>
<p>这个时候我们发出一条这样的加锁sql语句：</p>
<p>select id,name from t_student where id &gt; 0 and id &lt; 5 for update;</p>
<p>这时候，我们命中的数据为以下着色部分：<br><img src="/images/264.png" alt=""><br>细心的朋友可能就会发现，这里缺少了条id为2的记录，我们的重点就在这里。</p>
<p>select … for update这条语句，是会对数据记录加锁的，这里因为命中了索引，加的是行锁。从数据记录来看，这里排它锁锁住数据是id为1、3和4的这3条数据。</p>
<p>但是，看看前面我们的介绍——对于键值在条件范围内但不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁。</p>
<p>键值在条件范围但是不存在的记录，就是id为2的记录，这里会对id为2数据加上间隙锁。假设这时候如果有id=2的记录insert进来了，是要等到这个事务结束以后才会执行的</p>
<p>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p>
<pre><code>SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</code></pre><p>即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。<br><strong>间隙锁的作用</strong>：防止幻读和防止数据误删/改</p>
<p><strong>区间的开闭初中数学</strong><br>(0 1) 开区间就是端点不能取 这里就是 0 和 1 不能取<br>[0 1] 闭区间就是端点可以取 这里就是 0 和 1 可以取</p>
<h3 id="临键锁-Next-Key"><a href="#临键锁-Next-Key" class="headerlink" title="临键锁(Next-Key)"></a><strong>临键锁(Next-Key)</strong></h3><p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临键锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。<br>假设有如下表：<br>MySql，InnoDB，Repeatable-Read：table(id PK, age KEY, name)</p>
<pre><code>id    age    name
1     10     Lee
3     24     Soraka
5     32     Zed
7     45     Talon</code></pre><p>该表中 age 列潜在的临键锁有：</p>
<p>(-∞, 10],<br>(10, 24],<br>(24, 32],<br>(32, 45],<br>(45, +∞],</p>
<p>在事务 A 中执行如下命令：</p>
<pre><code>-- 根据非唯一索引列 UPDATE 某条记录
UPDATE table SET name = Vladimir WHERE age = 24;
-- 或根据非唯一索引列 锁住某条记录
SELECT * FROM table WHERE age = 24 FOR UPDATE;</code></pre><p>不管执行了上述 SQL 中的哪一句，之后如果在事务 B 中执行以下命令，则该命令会被阻塞：</p>
<pre><code>INSERT INTO table VALUES(100, 26, &apos;Ezreal&apos;);</code></pre><p>很明显，事务 A 在对 age 为 24 的列进行 UPDATE 操作的同时，也获取了 (24, 32] 这个区间内的临键锁。</p>
<p>不仅如此，在执行以下 SQL 时，也会陷入阻塞等待：</p>
<pre><code>INSERT INTO table VALUES(100, 11, &apos;Ezreal&apos;);</code></pre><p>那最终我们就可以得知，在根据非唯一索引 对记录行进行 UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE 操作时，InnoDB 会获取该记录行的 临键锁 ，并同时获取该记录行下一个区间的间隙锁。</p>
<p>即事务 A在执行了上述的 SQL 后，最终被锁住的记录区间为 (10, 32)。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h3><p>InnoDB为了让表锁和行锁共存而使用了意向锁。</p>
<p>为什么没有意向锁的话，表锁和行锁不能共存？</p>
<p>举个粟子（此时假设行锁和表锁能共存）： 事务A锁住表中的一行（写锁）。事务B锁住整个表（写锁）。</p>
<p>但你就会发现一个很明显的问题，事务A既然锁住了某一行，其他事务就不可能修改这一行。这与”事务B锁住整个表就能修改表中的任意一行“形成了冲突。所以，没有意向锁的时候，行锁与表锁共存就会存在问题！<br>意向锁是如何让表锁和行锁共存的？</p>
<p>有了意向锁之后，前面例子中的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。</p>
<p>所以，意向锁的作用就是：</p>
<p>当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要的是某行（或者某些行）的排他锁定，则申请一个意向排他锁。<br>共享锁/排他锁与意向共享锁/意向排他锁的兼容性关系：<br><img src="/images/259.png" alt=""> </p>
<h2 id="4-加锁机制分类"><a href="#4-加锁机制分类" class="headerlink" title="4.加锁机制分类"></a><strong>4.加锁机制分类</strong></h2><p>乐观锁和悲观锁的思想</p>
<p>在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><p><strong>概念</strong></p>
<ul>
<li>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。</li>
<li>它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作在某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</li>
<li>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</li>
<li>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。</li>
<li>悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</li>
</ul>
<p><strong>在数据库中，悲观锁的流程如下：</strong></p>
<ul>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
</ul>
<p><strong>MySQL InnoDB中使用悲观锁</strong></p>
<p>要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
<pre><code>set autocommit=0;</code></pre><p><strong>悲观锁优点与不足</strong></p>
<ul>
<li>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。- 但是在效率方面，处理加锁的机制会让数据库产生额外的开销</li>
<li>还有增加产生死锁的机会</li>
<li>另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载</li>
<li>还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h3><p><strong>概念</strong></p>
<ul>
<li>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。</li>
<li>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。</li>
<li>在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。</li>
<li>如果其他事务有更新的话，正在提交的事务会进行回滚。</li>
<li>乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</li>
</ul>
<p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p><strong>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</strong></p>
<p>数据版本:为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
<p><strong>乐观锁使用CAS（Compare And Swep）操作保证数据一致性</strong></p>
<p><strong>使用版本号实现乐观锁</strong><br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<p><strong>乐观锁优点与不足</strong></p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何死锁。<br>但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/" data-id="ckb22iufq008yzwu8hq68cybc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          生产者消费者模式
        
      </div>
    </a>
  
  
    <a href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Mysql索引优化</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>