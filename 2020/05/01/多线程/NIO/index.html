<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>NIO | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概述java.nio 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)。新增了许多用于处理输入输出的类，这些类都被放在 java.nio包及子包下，并且对原java.io包中的很多类进行改写，新增了满足 NIO 的功能。  NIO 和 BIO 有着相同的目的和">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO">
<meta property="og:url" content="https://tukuai.github.io/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NIO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述java.nio 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)。新增了许多用于处理输入输出的类，这些类都被放在 java.nio包及子包下，并且对原java.io包中的很多类进行改写，新增了满足 NIO 的功能。  NIO 和 BIO 有着相同的目的和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tukuai.github.io/images/266.png">
<meta property="og:image" content="https://tukuai.github.io/images/267.png">
<meta property="og:image" content="https://tukuai.github.io/images/268.png">
<meta property="og:image" content="https://tukuai.github.io/images/269.png">
<meta property="og:image" content="https://tukuai.github.io/images/270.png">
<meta property="og:image" content="https://tukuai.github.io/images/271.png">
<meta property="article:published_time" content="2020-05-01T10:57:51.000Z">
<meta property="article:modified_time" content="2020-05-08T12:46:07.599Z">
<meta property="article:author" content="Tukuai">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tukuai.github.io/images/266.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Tukuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-多线程/NIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NIO/" class="article-date">
  <time datetime="2020-05-01T10:57:51.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      NIO
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>java.nio 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)。新增了许多用于处理输入输出的类，这些类都被放在 java.nio包及子包下，并且对原java.io包中的很多类进行改写，新增了满足 NIO 的功能。 </p>
<p>NIO 和 BIO 有着相同的目的和作用，但是它们的实现方式完全不同，BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多。另外，NIO 是非阻塞式的，这一点跟 BIO 也很不相同，使用它可以提供非阻塞式的高伸缩性网络。 </p>
<p><strong>NIO 主要有三大核心部分：</strong>Channel(通道)，Buffer(缓冲区), Selector(选择器)。<br>传统的 BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<br>Selector(选择区)用于监听多个通道的事件(比如：连接请求，数据到达等)，因此使用单个线程就可以监听多个客户端通道。<br><img src="/images/266.png" alt=""></p>
<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a><strong>文件IO</strong></h1><h2 id="概述和核心-API"><a href="#概述和核心-API" class="headerlink" title="概述和核心 API"></a><strong>概述和核心 API</strong></h2><p>缓冲区(Buffer)：实际上是一个容器，是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，<br>但是读取或写入的数据都必须经由 Buffer，如下图所示：<br><img src="/images/267.png" alt=""><br>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 子类有： </p>
<ul>
<li>ByteBuffer，存储字节数据到缓冲区 </li>
<li>ShortBuffer，存储字符串数据到缓冲区 </li>
<li>CharBuffer，存储字符数据到缓冲区 </li>
<li>IntBuffer，存储整数数据到缓冲区 </li>
<li>LongBuffer，存储长整型数据到缓冲区 </li>
<li>DoubleBuffer，存储小数到缓冲区 </li>
<li>FloatBuffer，存储小数到缓冲区 </li>
</ul>
<p>对于 Java 中的基本数据类型，都有一个 Buffer 类型与之相对应，最常用的自然是ByteBuffer 类(二进制数据)，该类的主要方法如下所示： </p>
<ul>
<li>public abstract ByteBuffer put(byte[] b); 存储字节数据到缓冲区 </li>
<li>public abstract byte[] get(); 从缓冲区获得字节数据 </li>
<li>public final byte[] array(); 把缓冲区数据转换成字节数组 </li>
<li>public static ByteBuffer allocate(int capacity); 设置缓冲区的初始容量 </li>
<li>public static ByteBuffer wrap(byte[] array); 把一个现成的数组放到缓冲区中使用 </li>
<li>public final Buffer flip();重置位置到初始位置 </li>
</ul>
<h2 id="通道-Channel-："><a href="#通道-Channel-：" class="headerlink" title="通道(Channel)："></a><strong>通道(Channel)：</strong></h2><p>类似于 BIO 中的 stream，例如 FileInputStream 对象，用来建立到目标(文件，网络套接字，硬件设备等)的一个连接，但是需要注意：BIO 中的 stream 是单向<br>的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的， 既可以用来进行读操作，也可以用来进行写操作。</p>
<p>常用的 Channel 类有：FileChannel、 DatagramChannel、ServerSocketChannel 和 SocketChannel。FileChannel 用于文件的数据读写，<br>DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的 数据读写。<br><img src="/images/268.png" alt=""></p>
<p><strong>FileChannel 类</strong><br>该类主要用来对本地文件进行 IO 操作，主要方法如下所示： </p>
<ul>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中 </li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中 </li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道 </li>
<li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li>
</ul>
<p><strong>案例</strong><br>接下来我们通过 NIO 实现几个案例，分别演示一下本地文件的读、写和复制操作，并和 BIO 做个对比。<br>1.往本地文件中写数据 </p>
<pre><code>@Test
public void test1() throws Exception
{
    String str=&quot;hello,nio&quot;;
    //1.创建输出流
    FileOutputStream fos=new FileOutputStream(&quot;basic.txt&quot;);
    //2.从流中得到一个通道
    FileChannel fc=fos.getChannel();
    //3.提供一个缓冲区
    ByteBuffer buffer=ByteBuffer.allocate(1024);
    //4.往缓冲区存入数据
    buffer.put(str.getBytes());
    buffer.flip();//，重置位置到初始位置，因为每次都是从当前位置向后写的
    //5.把缓冲区写到通道里面
    fc.write(buffer);
    //6.关闭
    fos.close();
} </code></pre><p>NIO 中的通道是从输出流对象里通过 getChannel 方法获取到的，该通道是双向的，既可以读，又可以写。在往通道里写数据之前，必须通过 put 方法把数据存到 ByteBuffer 中，然后通过通道的 write 方法写数据。在 write 之前，需要调用 flip 方法翻转缓冲区，把内部重置到初始位置，这样在接下来写数据时才能把所有数据写到通道里。运行效果如下图所示：<br><img src="/images/269.png" alt=""></p>
<p>2.从本地文件中读数据 </p>
<pre><code>@Test 
public void test2() throws Exception{ 
    File file=new File(&quot;basic.txt&quot;); 
    //1.创建输入流
    FileInputStream fis=new FileInputStream(file); 
    //2.从流中得到一个通道
    FileChannel fc=fis.getChannel(); 
    //3.提供一个缓冲区
    ByteBuffer buffer=ByteBuffer.allocate((int)file.length()); 
    //4.从通道读取数据并存到缓冲区中，也就是说数据会存到缓冲区中
    fc.read(buffer); 
    System.out.print(new String(buffer.array())); 
    //5.关闭
    fis.close(); 
} </code></pre><p>上述代码从输入流中获得一个通道，然后提供 ByteBuffer 缓冲区，该缓冲区的初始容量和文件的大小一样，最后通过通道的 read 方法把数据读取出来并存储到了 ByteBuffer 中。</p>
<p>3.复制文件 </p>
<p>通过 BIO 复制一个视频文件，代码如下所示： </p>
<pre><code>@Test
public void test3() throws Exception{
    FileInputStream fis=new FileInputStream(&quot;C:\\Users\\zdx\\Desktop\\oracle.mov&quot;);
    FileOutputStream fos=new FileOutputStream(&quot;d:\\oracle.mov&quot;);
    byte[] b=new byte[1024];
    while (true) {
        int res=fis.read(b);
        if(res==-1){
            break;
        }
        fos.write(b,0,res);
    }
    fis.close();
    fos.close();
} </code></pre><p>上述代码分别通过输入流和输出流实现了文件的复制，这是通过传统的 BIO 实现的</p>
<p>通过 NIO 复制相同的视频文件，代码如下所示： </p>
<pre><code>@Test
public void test4() throws Exception{
    FileInputStream fis=new FileInputStream(&quot;C:\\Users\\zdx\\Desktop\\oracle.mov&quot;);
    FileOutputStream fos=new FileOutputStream(&quot;d:\\oracle.mov&quot;);
    FileChannel sourceCh = fis.getChannel();
    FileChannel destCh = fos.getChannel();
    destCh.transferFrom(sourceCh, 0, sourceCh.size());
    sourceCh.close();
    destCh.close();
} </code></pre><p>上述代码分别从两个流中得到两个通道，sourceCh 负责读数据，destCh 负责写数据，然后直接调用 transferFrom 方法一步到位实现了文件复制。 </p>
<h1 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a><strong>网络 IO</strong></h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>前面在进行文件 IO 时用到的 FileChannel 并不支持非阻塞操作，学习 NIO 主要就是进行网络 IO，Java NIO 中的网络通道是非阻塞 IO 的实现，基于事件驱动，非常适用于服务器需要维持大量连接，但是数据交换量不大的情况，例如一些即时通信的服务等等…. </p>
<p><strong>在 Java 中编写 Socket 服务器，通常有以下几种模式：</strong> </p>
<ul>
<li><p>一个客户端连接用一个线程，优点：程序编写简单；缺点：如果连接非常多，分配的线程也会非常多，服务器可能会因为资源耗尽而崩溃。 </p>
</li>
<li><p>把每一个客户端连接交给一个拥有固定数量线程的连接池，优点：程序编写相对简单，可以处理大量的连接。确定：线程的开销非常大，连接如果非常多，排队现象会比较严重。 </p>
</li>
<li><p>使用 Java 的 NIO，用非阻塞的 IO 方式处理。这种模式可以用一个线程，处理大量的客户端连接。</p>
</li>
</ul>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a><strong>核心API</strong></h2><h3 id="1-Selector-选择器"><a href="#1-Selector-选择器" class="headerlink" title="1.Selector(选择器)"></a><strong>1.Selector(选择器)</strong></h3><p>能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。<br><img src="/images/270.png" alt=""></p>
<p>该类的常用方法如下所示： </p>
<ul>
<li><p>public static Selector open()，得到一个选择器对象 </p>
</li>
<li><p>public int select(long timeout) 监控所有注册的通道，当其中有IO操作可以进行时，将对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间 </p>
</li>
<li><p>public Set<SelectionKey> selectedKeys()，从内部集合中得到所有的 SelectionKey </p>
</li>
</ul>
<h3 id="2-SelectionKey"><a href="#2-SelectionKey" class="headerlink" title="2.SelectionKey"></a><strong>2.SelectionKey</strong></h3><p>代表了 Selector 和网络通道的注册关系,一共四种： </p>
<ul>
<li><p>int OP_ACCEPT：有新的网络连接可以 accept，值为 16 </p>
</li>
<li><p>int OP_CONNECT：代表连接已经建立，值为 8 </p>
</li>
<li><p>int OP_READ 和 int OP_WRITE：代表了读、写操作，值为 1 和 4 </p>
</li>
</ul>
<p>该类的常用方法如下所示： </p>
<ul>
<li><p>public abstract Selector selector()，得到与之关联的 Selector 对象 </p>
</li>
<li><p>public abstract SelectableChannel channel()，得到与之关联的通道 </p>
</li>
<li><p>public final Object attachment()，得到与之关联的共享数据 </p>
</li>
<li><p>public abstract SelectionKey interestOps(int ops)，设置或改变监听事件 </p>
</li>
<li><p>public final boolean isAcceptable()，是否可以 accept </p>
</li>
<li><p>public final boolean isReadable()，是否可以读 </p>
</li>
<li><p>public final boolean isWritable()，是否可以写 </p>
</li>
</ul>
<h3 id="3-ServerSocketChannel"><a href="#3-ServerSocketChannel" class="headerlink" title="3.ServerSocketChannel"></a><strong>3.ServerSocketChannel</strong></h3><p>用来在服务器端监听新的客户端 Socket 连接，常用方法如下所示： </p>
<ul>
<li><p>public static ServerSocketChannel open()，得到一个 ServerSocketChannel 通道 </p>
</li>
<li><p>public final ServerSocketChannel bind(SocketAddress local)，设置服务器端端口号 </p>
</li>
<li><p>public final SelectableChannel configureBlocking(boolean block)，设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式 </p>
</li>
<li><p>public SocketChannel accept()，接受一个连接，返回代表这个连接的通道对象 </p>
</li>
<li><p>public final SelectionKey register(Selector sel, int ops)，注册一个选择器并设置监听事件 </p>
</li>
</ul>
<h3 id="4-SocketChannel"><a href="#4-SocketChannel" class="headerlink" title="4.SocketChannel"></a><strong>4.SocketChannel</strong></h3><p>网络 IO 通道，具体负责进行读写操作。NIO 总是把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。<br>常用方法如下所示： </p>
<ul>
<li><p>public static SocketChannel open()，得到一个 SocketChannel 通道 </p>
</li>
<li><p>public final SelectableChannel configureBlocking(boolean block)，设置阻塞或非阻塞模式， 取值 false 表示采用非阻塞模式 </p>
</li>
<li><p>public boolean connect(SocketAddress remote)，连接服务器 </p>
</li>
<li><p>public boolean finishConnect()，如果上面的方法连接失败，接下来就要通过该方法完成连接操作 </p>
</li>
<li><p>public int write(ByteBuffer src)，往通道里写数据 </p>
</li>
<li><p>public int read(ByteBuffer dst)，从通道里读数据 </p>
</li>
<li><p>public final SelectionKey register(Selector sel, int ops, Object att)，注册一个选择器并设置监听事件，最后一个参数可以设置共享数据 </p>
</li>
<li><p>public final void close()，关闭通道 </p>
</li>
</ul>
<p><img src="/images/271.png" alt=""></p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a><strong>入门案例</strong></h2><p>API 学习完毕后，接下来我们使用 NIO 开发一个入门案例，实现服务器端和客户端之间的数据通信(非阻塞)。<br><strong>网络客户端程序</strong></p>
<pre><code>//网络客户端程序 
public class NIOClient {
    public static void main(String[] args) throws Exception{
        //1. 得到一个网络通道 
        SocketChannel channel=SocketChannel.open();
        //2. 设置非阻塞方式 
        channel.configureBlocking(false);
        //3. 提供服务器端的 IP 地址和端口号 
        InetSocketAddress address=new InetSocketAddress(&quot;127.0.0.1&quot;,9999);
        //4. 连接服务器端 
        if(!channel.connect(address)){
            while(!channel.finishConnect()){ //nio 作为非阻塞式的优势 
                System.out.println(&quot;Client:连接服务器端的同时，我还可以干别的一些事情&quot;);
            }
        }
        //5. 得到一个缓冲区并存入数据 
        String msg=&quot;hello,Server&quot;;
        ByteBuffer writeBuf = ByteBuffer.wrap(msg.getBytes());
        //6. 发送数据 
        channel.write(writeBuf);
        System.in.read(); //先不能关客户端，因为关了之后服务器端会报异常
    }
}</code></pre><p>上面代码通过 NIO 实现了一个客户端程序，连接上服务器端后发送了一条数据，运行效果 </p>
<p><strong>网络服务器端程序</strong></p>
<pre><code>//网络服务器端程序 
public class NIOServer {
    public static void main(String[] args) throws Exception{
        //1. 得到一个 ServerSocketChannel 对象 老大 
        ServerSocketChannel serverSocketChannel=ServerSocketChannel.open();
        //2. 得到一个 Selector 对象 
        间谍
        Selector selector=Selector.open();
        //3. 绑定一个端口号 
        serverSocketChannel.bind(new InetSocketAddress(9999));
        //4. 设置非阻塞方式 
        serverSocketChannel.configureBlocking(false);
        //5. 把 ServerSocketChannel 对象注册给 Selector 对象 
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        //6. 干活 
        while(true){
        //6.1 监控客户端 
        if(selector.select(2000)==0){             //nio 非阻塞式的优势，2000为超时时间，毫秒 
                System.out.println(&quot;Server:没有客户端搭理我，我就干点别的事&quot;);
                continue;
            }
            //6.2 得到 SelectionKey,判断通道里的事件
                //利用迭代器进行遍历 
            Iterator&lt;SelectionKey&gt; keyIterator=selector.selectedKeys().iterator();
            while(keyIterator.hasNext()){
                SelectionKey key=keyIterator.next();
            if(key.isAcceptable()){             //客户端连接请求事件 
                    System.out.println(&quot;OP_ACCEPT&quot;);
                    SocketChannel socketChannel=serverSocketChannel.accept();  //这里会默认接收iterator当前的socketChannel
                    socketChannel.configureBlocking(false);
                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));
                }
            //key.isReadable()前提条件是，必须要先连上客户端，所以写在key.isAcceptable()之后
            if(key.isReadable()){             //读取客户端数据事件 
                    SocketChannel channel=(SocketChannel) key.channel();
                    ByteBuffer buffer=(ByteBuffer) key.attachment();
                    channel.read(buffer);
                    System.out.println(&quot;客户端发来数据：&quot;+new String(buffer.array()));
                }
                //网客户端写事件，省略
                // 6.3 手动从集合中移除当前 key,防止重复处理 
                //iterator到selectedKey之后，需要将该key移除出selectedKey。如果不移出，例如OP_ACCEPT，则再下次accept之后，会产生空的SocketChannel。
                keyIterator.remove();
            }
        }
    }
}</code></pre><p>上面代码用 NIO 实现了一个服务器端程序，能不断接受客户端连接并读取客户端发过来的数据。<br>如下图所示： </p>
<h2 id="网络聊天案例"><a href="#网络聊天案例" class="headerlink" title="网络聊天案例"></a><strong>网络聊天案例</strong></h2><p>刚才我们通过 NIO 实现了一个入门案例，基本了解了 NIO 的工作方式和运行流程，接下来我们用 NIO 实现一个多人聊天案例，具体代码如下所示：<br><strong>服务器端</strong><br>使用 NIO 编写了一个聊天程序的服务器端，可以接受客户端发来的数据，并能把数据广播给所有客户端。</p>
<pre><code>public class ChatServer {
    private Selector selector;
    private ServerSocketChannel listenerChannel;
    private static final int PORT = 9999; //服务器端口 
    public ChatServer() {
        try {
            // 得到选择器 
            selector = Selector.open();
            // 打开监听通道 
            listenerChannel = ServerSocketChannel.open();
            // 绑定端口 
            listenerChannel.bind(new InetSocketAddress(PORT));
            // 设置为非阻塞模式 
            listenerChannel.configureBlocking(false);
            // 将选择器绑定到监听通道并监听 accept 事件 
            listenerChannel.register(selector, SelectionKey.OP_ACCEPT);
            printInfo(&quot;Chat Server is ready.......&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void start() {
        try {
            while (true) {         //不停轮询 
                int count = selector.select();        //获取就绪 channel 
                if (count &gt; 0) {
                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                    while (iterator.hasNext()) {
                        SelectionKey key = iterator.next();
                        // 监听到 accept 
                        if (key.isAcceptable()) {
                            SocketChannel sc = listenerChannel.accept();
                            //非阻塞模式 
                            sc.configureBlocking(false);
                            //注册到选择器上并监听 read 
                            sc.register(selector, SelectionKey.OP_READ);
                            System.out.println(sc.getRemoteAddress().toString().substring(1)+&quot;上线了...&quot;);
                            //将此对应的 channel 设置为 accept,接着准备接受其他客户端请求 
                            key.interestOps(SelectionKey.OP_ACCEPT);
                        }
                        //监听到 read 
                        if (key.isReadable()) {
                            readMsg(key);         //读取客户端发来的数据 
                        }
                        //一定要把当前 key 删掉，防止重复处理 
                        iterator.remove();
                    }
                } else {
                    System.out.println(&quot;独自在寒风中等候...&quot;);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void readMsg(SelectionKey key) {
        SocketChannel channel = null;
        try {
            // 得到关联的通道 
            channel = (SocketChannel) key.channel();
            //设置 buffer 缓冲区 
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            //从通道中读取数据并存储到缓冲区中 
            int count = channel.read(buffer);
            //如果读取到了数据 
            if (count &gt; 0) {
                //把缓冲区数据转换为字符串 
                String msg = new String(buffer.array());
                printInfo(msg);
                //将关联的 channel 设置为 read，继续准备接受数据 
                key.interestOps(SelectionKey.OP_READ);
                BroadCast(channel, msg);         //向所有客户端广播数据 
            }
            buffer.clear();
        } catch (IOException e) {
            try {
                //当客户端关闭 channel 时，进行异常如理 
                printInfo(channel.getRemoteAddress().toString().substring(1) + &quot;下线了...&quot;);
                key.cancel();         //取消注册 
                channel.close();         //关闭通道 
            } catch (IOException e1) {
                e1.printStackTrace();
            }
        }
    }
    public void BroadCast(SocketChannel except, String msg) throws IOException {
        System.out.println(&quot;发送广播...&quot;);
        //广播数据到所有的 SocketChannel 中 
        for (SelectionKey key : selector.keys()) {
            Channel targetchannel = key.channel();
            //排除自身 
            if (targetchannel instanceof SocketChannel &amp;&amp; targetchannel != except) {
                SocketChannel dest = (SocketChannel) targetchannel;
                //把数据存储到缓冲区中 
                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());
                //往通道中写数据 
                dest.write(buffer);
            }
        }
    }
    private void printInfo(String str) {         //往控制台打印消息 
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(&quot;[&quot; + sdf.format(new Date()) + &quot;] -&gt; &quot; + str);
    }
    public static void main(String[] args) {
        ChatServer server = new ChatServer();
        server.start();
    }
}</code></pre><p><strong>客户端</strong><br>通过 NIO 编写了一个聊天程序的客户端，可以向服务器端发送数据，并能接收服务器广播的数据。</p>
<pre><code>public class ChatClient {
    private final String HOST = &quot;127.0.0.1&quot;;         //服务器地址 
    private int PORT = 9999;         //服务器端口 
    private Selector selector;
    private SocketChannel socketChannel;
    private String userName;
    public ChatClient() throws IOException {
        //得到选择器 
        selector = Selector.open();
        //连接远程服务器 
        socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));
        //设置非阻塞 
        socketChannel.configureBlocking(false);
        //注册选择器并设置为 read 
        socketChannel.register(selector, SelectionKey.OP_READ);
        //得到客户端 IP 地址和端口信息，作为聊天用户名使用 
        userName = socketChannel.getLocalAddress().toString().substring(1);
        System.out.println(&quot;---------------Client(&quot; + userName + &quot;) is ready---------------&quot;);
    }
    //向服务器端发送数据 
    public void sendMsg(String msg) throws Exception {
        //如果控制台输入 bye 就关闭通道，结束聊天 
        if (msg.equalsIgnoreCase(&quot;bye&quot;)) {
            socketChannel.close();
            socketChannel = null;
            return;
        }
        msg = userName + &quot;说: &quot; + msg;
        try {
        //往通道中写数据 
            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
            //从服务器端接收数据 
    public void receiveMsg() {
        try {
            int readyChannels = selector.select();
            if (readyChannels &gt; 0) {         //有可用通道 
                Set selectedKeys = selector.selectedKeys();
                Iterator keyIterator = selectedKeys.iterator();
                while (keyIterator.hasNext()) {
                    SelectionKey sk = (SelectionKey) keyIterator.next();
                    if (sk.isReadable()) {
                        //得到关联的通道 
                        SocketChannel sc = (SocketChannel) sk.channel();
                        //得到一个缓冲区 
                        ByteBuffer buff = ByteBuffer.allocate(1024);
                        //读取数据并存储到缓冲区 
                        sc.read(buff);
                        //把缓冲区数据转换成字符串 
                        String msg = new String(buff.array());
                        System.out.println(msg.trim());
                    }
                    keyIterator.remove();         //删除当前 SelectionKey，防止重复处理 
                }
            } else {
                System.out.println(&quot;人呢？都去哪儿了？没人聊天啊...&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre><p><strong>测试代码</strong><br>运行了聊天程序的客户端，并在主线程中发送数据，在另一个线程中不断接收服务器端的广播数据，该代码运行一次就是一个聊天客户端，可以同时运行多个聊天客户端，聊天效果如下图所示</p>
<pre><code>public class TestChat {
    public static void main(String[] args) throws Exception {
        //创建一个聊天客户端对象 
        ChatClient chatClient = new ChatClient();
        new Thread() {         //单独开一个线程不断的接收服务器端广播的数据 
            public void run() {
                while (true) {
                    chatClient.receiveMsg();
                    try {         //间隔 3 秒 
                        Thread.currentThread().sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }.start();
        Scanner scanner = new Scanner(System.in);
        //在控制台输入数据并发送到服务器端 
        while (scanner.hasNextLine()) {
            String msg = scanner.nextLine();
            chatClient.sendMsg(msg);
        }
    }
}</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://tukuai.github.io/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NIO/" data-id="ckb22iufh007wzwu8fayz216a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          基础知识
        
      </div>
    </a>
  
  
    <a href="/2020/05/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Socket&ServerSocket/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Socket&amp;ServerSocket</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 12.86px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 11.43px;">LeetCode</a> <a href="/tags/Web/" style="font-size: 18.57px;">Web</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.14px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15.71px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.29px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/WHERE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB/">数据库/WHERE和ON的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%8B%E8%AF%95/">操作系统/测试</a>
          </li>
        
          <li>
            <a href="/2020/06/05/Java%E5%9F%BA%E7%A1%80/HashMap/">Java基础/HashMap</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2020/05/23/Redis/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Tukuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>